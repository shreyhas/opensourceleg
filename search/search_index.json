{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"opensourceleg","text":"<p>An open-source software library for numerical computation, data acquisition, and control of lower-limb robotic prostheses.</p> <p> </p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>The easiest and quickest way to install the opensourceleg library is via pip:</p> <pre><code>pip install opensourceleg\n</code></pre> <p>If you plan on installing the opensourceleg library on a Raspberry Pi, we recommend using opensourcelegpi tool, which is a cloud-based CI tool used to build an up-to-date OS for a Raspberry Pi that can be used headless/GUI-less to control autonomous/remote robotic systems. This tool bundles the opensourceleg library and its dependencies into a single OS image, which can be flashed onto a microSD card and used to boot a Raspberry Pi. For more information, click here.</p>"},{"location":"#developing","title":"Developing","text":"<p>To modify, develop, or contribute to the opensourceleg library, we encourage you to install Poetry, which is a python packaging and dependency management tool. Once you have Poetry installed on your local machine, you can clone the repository and install the opensourceleg library by running the following commands:</p> <pre><code>git clone https://github.com/neurobionics/opensourceleg.git\ncd opensourceleg\n\npoetry install\npoetry shell\n</code></pre> <p>Finally, install the environment and the pre-commit hooks with</p> <pre><code>make install\n</code></pre> <p>You are now ready to start development on your project! The CI/CD pipeline will be triggered when you open a pull request, merge to main, or when you create a new release.</p> <p>To finalize the set-up for publishing to PyPI or Artifactory, see here. For activating the automatic documentation with MkDocs, see here. To enable the code coverage reports, see here.</p>"},{"location":"#releasing-a-new-version","title":"Releasing a new version","text":"<ul> <li>Create an API Token on PyPI.</li> <li>Add the API Token to your projects secrets with the name <code>PYPI_TOKEN</code> by visiting this page.</li> <li>Create a new release on Github.</li> <li>Create a new tag in the form <code>*.*.*</code>.</li> <li>For more details, see here.</li> </ul>"},{"location":"#license","title":"License","text":"<p>The opensourceleg library is licensed under the terms of the LGPL-v2.1 license. This license grants users a number of freedoms:</p> <ul> <li>You are free to use the opensourceleg library for any purpose.</li> <li>You are free to modify the opensourceleg library to suit your needs.</li> <li>You can study how the opensourceleg library works and change it.</li> <li>You can distribute modified versions of the opensourceleg library.</li> </ul> <p>The GPL license ensures that all these freedoms are protected, now and in the future, requiring everyone to share their modifications when they also share the library in public.</p>"},{"location":"modules/logging/","title":"Logger","text":""},{"location":"modules/logging/#opensourceleg.logging.Logger","title":"<code>Logger</code>","text":"<p>               Bases: <code>Logger</code></p> <p>Represents a custom singleton logger class that extends the built-in Python logger. The logger provides additional functionality for tracking and logging variables to a CSV file. It supports different log levels and log formatting options.</p> <p>Parameters:</p> Name Type Description Default <code>log_path</code> <code>str</code> <p>The path to save log files.</p> <code>'./'</code> <code>log_format</code> <code>str</code> <p>The log message format.</p> <code>'[%(asctime)s] %(levelname)s: %(message)s'</code> <code>file_level</code> <code>LogLevel</code> <p>The log level for file output.</p> <code>DEBUG</code> <code>stream_level</code> <code>LogLevel</code> <p>The log level for console output.</p> <code>INFO</code> <code>file_max_bytes</code> <code>int</code> <p>The maximum size of the log file in bytes before rotation.</p> <code>0</code> <code>file_backup_count</code> <code>int</code> <p>The number of backup log files to keep.</p> <code>5</code> <code>file_name</code> <code>Union[str, None]</code> <p>The base name for the log file.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The maximum number of log entries to buffer before writing to the CSV file.</p> <code>1000</code> <code>enable_csv_logging</code> <code>bool</code> <p>Whether to enable CSV logging.</p> <code>True</code> Properties <ul> <li>file_path: The path to the log file.</li> <li>buffer_size: The maximum number of log entries to buffer.</li> <li>file_level: The log level for file output.</li> <li>stream_level: The log level for console output.</li> <li>file_max_bytes: The maximum size of the log file in bytes before rotation.</li> <li>file_backup_count: The number of backup log files to keep.</li> <li>csv_logging_enabled: Whether CSV logging is enabled.</li> <li>tracked_variable_count: The number of currently tracked variables.</li> </ul> <p>Methods:</p> Name Description <code>- **track_variable**</code> <p>Track a variable for logging.</p> <code>- **untrack_variable**</code> <p>Stop tracking a variable.</p> <code>- **flush_buffer**</code> <p>Write the buffered log entries to the CSV file.</p> <code>- **reset**</code> <p>Reset the logger state.</p> <code>- **close**</code> <p>Close the logger and flush any remaining log entries.</p> <code>- **debug**</code> <p>Log a debug message.</p> <code>- **info**</code> <p>Log an info message.</p> <code>- **warning**</code> <p>Log a warning message.</p> <code>- **error**</code> <p>Log an error message.</p> <code>- **critical**</code> <p>Log a critical message.</p> <code>- **log**</code> <p>Log a message at a specific log level.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; logger = Logger()\n&gt;&gt;&gt; logger.info(\"This is an info message\")\n[2022-01-01 12:00:00] INFO: This is an info message\n&gt;&gt;&gt; logger.debug(\"This is a debug message\")\n[2022-01-01 12:00:00] DEBUG: This is a debug message\n</code></pre> <pre><code>&gt;&gt;&gt; logger.track_variable(lambda: 42, \"answer\")\n&gt;&gt;&gt; logger.update()\n&gt;&gt;&gt; logger.flush_buffer()\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>class Logger(logging.Logger):\n    \"\"\"\n    Represents a custom singleton logger class that extends the built-in Python logger. The logger provides additional\n    functionality for tracking and logging variables to a CSV file. It supports different log levels and log formatting\n    options.\n\n    Args:\n        log_path: The path to save log files.\n        log_format: The log message format.\n        file_level: The log level for file output.\n        stream_level: The log level for console output.\n        file_max_bytes: The maximum size of the log file in bytes before rotation.\n        file_backup_count: The number of backup log files to keep.\n        file_name: The base name for the log file.\n        buffer_size: The maximum number of log entries to buffer before writing to the CSV file.\n        enable_csv_logging: Whether to enable CSV logging.\n\n    Properties:\n        - **file_path**: The path to the log file.\n        - **buffer_size**: The maximum number of log entries to buffer.\n        - **file_level**: The log level for file output.\n        - **stream_level**: The log level for console output.\n        - **file_max_bytes**: The maximum size of the log file in bytes before rotation.\n        - **file_backup_count**: The number of backup log files to keep.\n        - **csv_logging_enabled**: Whether CSV logging is enabled.\n        - **tracked_variable_count**: The number of currently tracked variables.\n\n    Methods:\n        - **track_variable**: Track a variable for logging.\n        - **untrack_variable**: Stop tracking a variable.\n        - **flush_buffer**: Write the buffered log entries to the CSV file.\n        - **reset**: Reset the logger state.\n        - **close**: Close the logger and flush any remaining log entries.\n        - **debug**: Log a debug message.\n        - **info**: Log an info message.\n        - **warning**: Log a warning message.\n        - **error**: Log an error message.\n        - **critical**: Log a critical message.\n        - **log**: Log a message at a specific log level.\n\n    Examples:\n        &gt;&gt;&gt; logger = Logger()\n        &gt;&gt;&gt; logger.info(\"This is an info message\")\n        [2022-01-01 12:00:00] INFO: This is an info message\n        &gt;&gt;&gt; logger.debug(\"This is a debug message\")\n        [2022-01-01 12:00:00] DEBUG: This is a debug message\n\n        &gt;&gt;&gt; logger.track_variable(lambda: 42, \"answer\")\n        &gt;&gt;&gt; logger.update()\n        &gt;&gt;&gt; logger.flush_buffer()\n    \"\"\"\n\n    _instance = None\n    _lock = threading.RLock()  # Reentrant lock for thread safety\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Logger\":\n        \"\"\"\n        Ensure that only one instance of Logger is created (singleton pattern).\n\n        Returns:\n            Logger: The singleton Logger instance.\n        \"\"\"\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = super().__new__(cls)\n            else:\n                logging.debug(f\"Reusing existing Logger instance: {id(cls._instance)}\")\n        return cls._instance\n\n    def __init__(\n        self,\n        log_path: str = \"./\",\n        log_format: str = \"[%(asctime)s] %(levelname)s: %(message)s\",\n        file_level: LogLevel = LogLevel.DEBUG,\n        stream_level: LogLevel = LogLevel.INFO,\n        file_max_bytes: int = 0,\n        file_backup_count: int = 5,\n        file_name: Union[str, None] = None,\n        buffer_size: int = 1000,\n        enable_csv_logging: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Logger instance.\n\n        Sets up logging paths, format, handler levels, and internal buffers for tracking variables.\n\n        Args:\n            log_path: Directory path where log files will be stored.\n            log_format: Format string for log messages.\n            file_level: Logging level for file handler.\n            stream_level: Logging level for stream (console) handler.\n            file_max_bytes: Maximum size (in bytes) for log file rotation.\n            file_backup_count: Number of backup log files to keep.\n            file_name: Optional user-specified file name prefix.\n            buffer_size: Maximum number of log records to buffer before writing to CSV.\n            enable_csv_logging: Whether to enable CSV logging.\n        \"\"\"\n        with self._lock:\n            if not hasattr(self, \"_initialized\"):\n                super().__init__(__name__)\n                self._log_path = log_path\n                self._log_format = log_format\n                self._file_level = file_level\n                self._stream_level = stream_level\n                self._file_max_bytes = file_max_bytes\n                self._file_backup_count = file_backup_count\n                self._user_file_name = file_name\n                self._enable_csv_logging = enable_csv_logging\n\n                self._file_path: str = \"\"\n                self._csv_path: str = \"\"\n                self._file: Optional[Any] = None\n                self._writer = None\n                self._is_logging = False\n                self._header_written = False\n\n                self._tracked_vars: dict[int, Callable[[], Any]] = {}\n                self._var_names: dict[int, str] = {}\n                self._buffer: deque = deque(maxlen=buffer_size)\n                self._buffer_size: int = buffer_size\n                self._error_count: dict[int, int] = {}  # Track errors per variable\n                self._max_errors_before_untrack: int = 5  # Auto-untrack after this many errors\n\n                try:\n                    self._setup_logging()\n                    self._initialized: bool = True\n                except Exception as e:\n                    print(f\"Error initializing logger: {e}\")\n                    raise\n            else:\n                self.set_file_name(file_name)\n                self.set_file_level(file_level)\n                self.set_stream_level(stream_level)\n                self.set_format(log_format)\n                self._file_max_bytes = file_max_bytes\n                self._file_backup_count = file_backup_count\n                self.set_buffer_size(buffer_size)\n                self._enable_csv_logging = enable_csv_logging\n                self._log_path = log_path\n\n    def _setup_logging(self) -&gt; None:\n        \"\"\"\n        Set up the stream logging handler.\n\n        Configures the logger level, formatter, and attaches a stream handler for console output.\n        \"\"\"\n        with self._lock:\n            if not hasattr(self, \"_stream_handler\"):  # Prevent duplicate handlers\n                self.setLevel(level=self._file_level.value)\n                self._std_formatter = logging.Formatter(self._log_format)\n                self._stream_handler = logging.StreamHandler()\n                self._stream_handler.setLevel(level=self._stream_level.value)\n                self._stream_handler.setFormatter(fmt=self._std_formatter)\n                self.addHandler(hdlr=self._stream_handler)\n\n    def set_stream_terminator(self, terminator: str) -&gt; None:\n        \"\"\"\n        Set the terminator for stream output.\n\n        Args:\n            terminator: The terminator string to use.\n        \"\"\"\n        with self._lock:\n            self._stream_handler.terminator = terminator\n\n    def _setup_file_handler(self) -&gt; None:\n        \"\"\"\n        Set up the file logging handler.\n        \"\"\"\n        with self._lock:\n            if not hasattr(self, \"_file_handler\"):  # Ensure file handler is added only once\n                try:\n                    self._generate_file_paths()\n\n                    self._file_handler = RotatingFileHandler(\n                        filename=self._file_path,\n                        mode=\"w\",\n                        maxBytes=self._file_max_bytes,\n                        backupCount=self._file_backup_count,\n                        encoding=\"utf-8\",\n                    )\n                    self._file_handler.setLevel(level=self._file_level.value)\n                    self._file_handler.setFormatter(fmt=self._std_formatter)\n                    self.addHandler(hdlr=self._file_handler)\n                except Exception as e:\n                    self.error(f\"Failed to set up file handler: {e}\")\n                    # Fall back to console-only logging\n                    self.warning(\"Falling back to console-only logging\")\n\n    def _ensure_file_handler(self) -&gt; None:\n        \"\"\"\n        Ensure that the file handler is set up.\n        \"\"\"\n        with self._lock:\n            if not hasattr(self, \"_file_handler\"):\n                self._setup_file_handler()\n\n    def track_variable(self, var_func: Callable[[], Any], name: str) -&gt; None:\n        \"\"\"\n        Track a variable for logging.\n\n        Args:\n            var_func: A callable that returns the value to track.\n            name: The name to use for the variable in logs.\n        \"\"\"\n        with self._lock:\n            var_id = id(var_func)\n            self._tracked_vars[var_id] = var_func\n            self._var_names[var_id] = name\n            self._error_count[var_id] = 0  # Initialize error count\n            self.debug(f\"Started tracking variable: {name}\")\n\n    def untrack_variable(self, var_func: Callable[[], Any]) -&gt; None:\n        \"\"\"\n        Stop tracking a variable.\n\n        Args:\n            var_func: The callable that was previously tracked.\n        \"\"\"\n        with self._lock:\n            var_id = id(var_func)\n            if var_id in self._tracked_vars:\n                name = self._var_names.get(var_id, \"unknown\")\n                self._tracked_vars.pop(var_id, None)\n                self._var_names.pop(var_id, None)\n                self._error_count.pop(var_id, None)\n                self.debug(f\"Stopped tracking variable: {name}\")\n            else:\n                self.warning(\"Attempted to untrack a variable that wasn't being tracked\")\n\n    def get_tracked_variables(self) -&gt; list[tuple[str, Any]]:\n        \"\"\"\n        Get all currently tracked variables.\n\n        Returns:\n            A list of tuples containing (name, value) for each tracked variable.\n        \"\"\"\n        with self._lock:\n            result = []\n            for var_id, get_value in self._tracked_vars.items():\n                name = self._var_names.get(var_id, \"unknown\")\n                try:\n                    value = get_value()\n                    result.append((name, value))\n                except Exception as e:\n                    result.append((name, f\"ERROR: {e}\"))\n            return result\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the Logger instance.\n\n        Returns:\n            str: A string representation including the current file path and tracked variable count.\n        \"\"\"\n        return f\"Logger(file_path={self._file_path}, tracked_vars={len(self._tracked_vars)})\"\n\n    def set_file_name(self, file_name: Union[str, None]) -&gt; None:\n        \"\"\"\n        Set the name of the log file.\n\n        Args:\n            file_name: The name to use for the log file.\n        \"\"\"\n        with self._lock:\n            try:\n                # Ensure log directory exists\n                os.makedirs(self._log_path, exist_ok=True)\n\n                # Handle None file_name case\n                if file_name is None:\n                    # Generate default name if none provided\n                    now = datetime.now()\n                    timestamp = now.strftime(\"%Y%m%d_%H%M%S\")\n                    script_name = os.path.basename(__file__).split(\".\")[0]\n                    file_name = f\"{script_name}_{timestamp}\"\n                elif \".\" in file_name:\n                    # If filename has an extension, remove it\n                    file_name = file_name.split(\".\")[0]\n\n                self._user_file_name = file_name\n                self._file_path = os.path.join(self._log_path, f\"{file_name}.log\")\n                self._csv_path = os.path.join(self._log_path, f\"{file_name}.csv\")\n\n                # If we already have a file handler, we need to recreate it\n                if hasattr(self, \"_file_handler\"):\n                    self.removeHandler(self._file_handler)\n                    self._file_handler.close()\n                    del self._file_handler\n                    self._setup_file_handler()\n\n                # Reset CSV file if it exists\n                if self._file:\n                    self.close()\n            except Exception as e:\n                self.error(f\"Error setting file name: {e}\")\n                raise\n\n    def set_file_level(self, level: LogLevel) -&gt; None:\n        \"\"\"\n        Set the log level for file output.\n\n        Args:\n            level: The log level to use.\n        \"\"\"\n        with self._lock:\n            self._file_level = level\n            if hasattr(self, \"_file_handler\"):\n                self._file_handler.setLevel(level=level.value)\n\n    def set_stream_level(self, level: LogLevel) -&gt; None:\n        \"\"\"\n        Set the log level for stream output.\n\n        Args:\n            level: The log level to use.\n        \"\"\"\n        with self._lock:\n            self._stream_level = level\n            self._stream_handler.setLevel(level=level.value)\n\n    def set_format(self, log_format: str) -&gt; None:\n        \"\"\"\n        Set the format for log messages.\n\n        Args:\n            log_format: The format string to use.\n        \"\"\"\n        with self._lock:\n            self._log_format = log_format\n            self._std_formatter = logging.Formatter(log_format)\n            if hasattr(self, \"_file_handler\"):\n                self._file_handler.setFormatter(fmt=self._std_formatter)\n            self._stream_handler.setFormatter(fmt=self._std_formatter)\n\n    def set_buffer_size(self, buffer_size: int) -&gt; None:\n        \"\"\"\n        Set the maximum number of log entries to buffer.\n\n        Args:\n            buffer_size: The maximum number of entries to buffer.\n        \"\"\"\n        with self._lock:\n            if buffer_size &lt;= 0:\n                self.warning(f\"Invalid buffer size: {buffer_size}. Using default of 1000.\")\n                buffer_size = 1000\n            self._buffer_size = buffer_size\n            # Create a new buffer with the updated size and copy over existing items\n            old_buffer = list(self._buffer)\n            self._buffer = deque(maxlen=buffer_size)\n            for item in old_buffer:\n                self._buffer.append(item)\n\n    def set_csv_logging(self, enable: bool) -&gt; None:\n        \"\"\"\n        Enable or disable CSV logging.\n\n        Args:\n            enable: Whether to enable CSV logging.\n        \"\"\"\n        with self._lock:\n            if self._enable_csv_logging != enable:\n                self._enable_csv_logging = enable\n                if not enable:\n                    self.flush_buffer()\n                    if self._file:\n                        self._file.close()\n                        self._file = None\n                        self._writer = None\n                self.debug(f\"CSV logging {'enabled' if enable else 'disabled'}\")\n\n    def set_max_errors_before_untrack(self, max_errors: int) -&gt; None:\n        \"\"\"\n        Set the maximum number of errors before untracking a variable.\n\n        Args:\n            max_errors: The maximum number of errors to allow.\n        \"\"\"\n        with self._lock:\n            if max_errors &lt; 0:\n                self.warning(f\"Invalid max_errors value: {max_errors}. Using default of 5.\")\n                max_errors = 5\n            self._max_errors_before_untrack = max_errors\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the tracked variables and write to the CSV file if the buffer is full.\n        \"\"\"\n        if not self._tracked_vars or not self._enable_csv_logging:\n            return\n\n        with self._lock:\n            data = []\n            vars_to_untrack = []\n\n            for var_id, get_value in self._tracked_vars.items():\n                try:\n                    value = get_value()\n                    data.append(str(value))\n                    # Reset error count on successful retrieval\n                    self._error_count[var_id] = 0\n                except Exception as e:\n                    var_name = self._var_names.get(var_id, \"unknown\")\n                    self.warning(f\"Error getting value for {var_name}: {e}\")\n                    data.append(\"ERROR\")\n\n                    # Increment error count and check if we should untrack\n                    self._error_count[var_id] = self._error_count.get(var_id, 0) + 1\n                    if self._error_count[var_id] &gt;= self._max_errors_before_untrack:\n                        vars_to_untrack.append((var_id, var_name))\n\n            # Only add data if we have variables to track\n            if data:\n                self._buffer.append(data)\n\n            # Untrack variables with too many errors\n            for var_id, var_name in vars_to_untrack:\n                self._tracked_vars.pop(var_id, None)\n                self._var_names.pop(var_id, None)\n                self._error_count.pop(var_id, None)\n                self.warning(\n                    f\"Auto-untracked variable {var_name} after {self._max_errors_before_untrack} consecutive errors\"\n                )\n\n            if len(self._buffer) &gt;= self._buffer_size:\n                self.flush_buffer()\n\n    def flush_buffer(self) -&gt; None:\n        \"\"\"\n        Write all buffered log entries to the CSV file.\n        \"\"\"\n        if not self._buffer or not self._enable_csv_logging:\n            return\n\n        with self._lock:\n            try:\n                self._ensure_file_handler()\n\n                if self._file is None:\n                    try:\n                        self._file = open(self._csv_path, \"w\", newline=\"\")\n                        self._writer = csv.writer(self._file)  # type: ignore[assignment]\n                    except Exception as e:\n                        self.error(f\"Failed to open CSV file {self._csv_path}: {e}\")\n                        # Clear buffer to prevent memory buildup\n                        self._buffer.clear()\n                        return\n\n                if not self._header_written:\n                    self._write_header()\n\n                try:\n                    self._writer.writerows(self._buffer)  # type: ignore[attr-defined]\n                    self._buffer.clear()\n                    self._file.flush()\n                except Exception as e:\n                    self.error(f\"Failed to write to CSV file: {e}\")\n                    # Try to recover by reopening the file\n                    if self._file:\n                        with contextlib.suppress(Exception):\n                            self._file.close()\n                    self._file = None\n                    self._writer = None\n                    self._header_written = False\n            except Exception as e:\n                self.error(f\"Unexpected error in flush_buffer: {e}\")\n\n    def _write_header(self) -&gt; None:\n        \"\"\"\n        Write the header row to the CSV file.\n        \"\"\"\n        try:\n            header = list(self._var_names.values())\n            if header:  # Only write header if we have variables\n                self._writer.writerow(header)  # type: ignore[attr-defined]\n                self._header_written = True\n        except Exception as e:\n            self.error(f\"Failed to write CSV header: {e}\")\n\n    def _generate_file_paths(self) -&gt; None:\n        \"\"\"\n        Generate the paths for log and CSV files.\n        \"\"\"\n        try:\n            # Ensure log directory exists\n            os.makedirs(self._log_path, exist_ok=True)\n\n            now = datetime.now()\n            timestamp = now.strftime(\"%Y%m%d_%H%M%S\")\n            script_name = os.path.basename(__file__).split(\".\")[0]\n\n            base_name = self._user_file_name if self._user_file_name else f\"{script_name}_{timestamp}\"\n\n            file_path = os.path.join(self._log_path, base_name)\n            self._file_path = file_path + \".log\"\n            self._csv_path = file_path + \".csv\"\n        except Exception as e:\n            print(f\"Error generating file paths: {e}\")  # Use print as logger might not be ready\n            raise\n\n    def __enter__(self) -&gt; \"Logger\":\n        \"\"\"\n        Enter the runtime context for the logger.\n\n        Returns:\n            The logger instance.\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"\n        Exit the runtime context for the logger.\n\n        Args:\n            exc_type: The exception type, if an exception occurred.\n            exc_val: The exception value, if an exception occurred.\n            exc_tb: The traceback, if an exception occurred.\n        \"\"\"\n        self.close()\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the logger state.\n        \"\"\"\n        with self._lock:\n            try:\n                self.close()\n\n                # Remove and clean up handlers\n                if hasattr(self, \"_file_handler\"):\n                    self.removeHandler(self._file_handler)\n                    self._file_handler.close()\n                    del self._file_handler\n\n                if hasattr(self, \"_stream_handler\"):\n                    self.removeHandler(self._stream_handler)\n                    self._stream_handler.close()  # Close the stream handler\n                    del self._stream_handler  # Delete the attribute\n\n                # Reinitialize logging\n                self._setup_logging()\n\n                # Reset tracking and state variables\n                self._tracked_vars.clear()\n                self._var_names.clear()\n                self._error_count.clear()\n                self._header_written = False\n                self._file = None\n                self._writer = None\n\n                self.debug(\"Logger reset successfully\")\n            except Exception as e:\n                print(f\"Error resetting logger: {e}\")  # Use print as logger might be in bad state\n\n    def close(self) -&gt; None:\n        \"\"\"\n        Close the logger and flush any remaining log entries.\n        \"\"\"\n        with self._lock:\n            try:\n                self.flush_buffer()\n                if self._file:\n                    self._file.close()\n                    self._file = None\n                    self._writer = None\n            except Exception as e:\n                self.error(f\"Error closing logger: {e}\")\n\n    def debug(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log a debug message.\n\n        Args:\n            msg: The message to log.\n            *args: Additional arguments for the message.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().debug(msg, *args, **kwargs)\n\n    def info(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log an info message.\n\n        Args:\n            msg: The message to log.\n            *args: Additional arguments for the message.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().info(msg, *args, **kwargs)\n\n    def warning(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log a warning message.\n\n        Args:\n            msg: The message to log.\n            *args: Additional arguments for the message.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().warning(msg, *args, **kwargs)\n\n    def error(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log an error message.\n\n        Args:\n            msg: The message to log.\n            *args: Additional arguments for the message.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().error(msg, *args, **kwargs)\n\n    def critical(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log a critical message.\n\n        Args:\n            msg: The message to log.\n            *args: Additional arguments for the message.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().critical(msg, *args, **kwargs)\n\n    def log(self, level: int, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log a message at a specific level.\n\n        Args:\n            level: The log level to use.\n            msg: The message to log.\n            *args: Additional arguments for the message.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().log(level, msg, *args, **kwargs)\n\n    @property\n    def file_path(self) -&gt; Optional[str]:\n        \"\"\"\n        Get the path to the log file.\n\n        Returns:\n            The path to the log file.\n        \"\"\"\n        return self._file_path\n\n    @property\n    def csv_path(self) -&gt; Optional[str]:\n        \"\"\"\n        Get the path to the CSV file.\n\n        Returns:\n            The path to the CSV file.\n        \"\"\"\n        return self._csv_path\n\n    @property\n    def log_path(self) -&gt; str:\n        \"\"\"\n        Get the path to the log directory.\n\n        Returns:\n            The path to the log directory.\n        \"\"\"\n        return self._log_path\n\n    @property\n    def buffer_size(self) -&gt; int:\n        \"\"\"\n        Get the maximum number of log entries to buffer.\n\n        Returns:\n            The maximum number of entries to buffer.\n        \"\"\"\n        return self._buffer_size\n\n    @property\n    def file_level(self) -&gt; LogLevel:\n        \"\"\"\n        Get the log level for file output.\n\n        Returns:\n            The log level for file output.\n        \"\"\"\n        return self._file_level\n\n    @property\n    def stream_level(self) -&gt; LogLevel:\n        \"\"\"\n        Get the log level for stream output.\n\n        Returns:\n            The log level for stream output.\n        \"\"\"\n        return self._stream_level\n\n    @property\n    def file_max_bytes(self) -&gt; int:\n        \"\"\"\n        Get the maximum size of the log file in bytes.\n\n        Returns:\n            The maximum size of the log file in bytes.\n        \"\"\"\n        return self._file_max_bytes\n\n    @property\n    def file_backup_count(self) -&gt; int:\n        \"\"\"\n        Get the number of backup log files to keep.\n\n        Returns:\n            The number of backup log files to keep.\n        \"\"\"\n        return self._file_backup_count\n\n    @property\n    def csv_logging_enabled(self) -&gt; bool:\n        \"\"\"\n        Check if CSV logging is enabled.\n\n        Returns:\n            True if CSV logging is enabled, False otherwise.\n        \"\"\"\n        return self._enable_csv_logging\n\n    @property\n    def tracked_variable_count(self) -&gt; int:\n        \"\"\"\n        Get the number of currently tracked variables.\n\n        Returns:\n            The number of currently tracked variables.\n        \"\"\"\n        return len(self._tracked_vars)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.buffer_size","title":"<code>buffer_size: int</code>  <code>property</code>","text":"<p>Get the maximum number of log entries to buffer.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum number of entries to buffer.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.csv_logging_enabled","title":"<code>csv_logging_enabled: bool</code>  <code>property</code>","text":"<p>Check if CSV logging is enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if CSV logging is enabled, False otherwise.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.csv_path","title":"<code>csv_path: Optional[str]</code>  <code>property</code>","text":"<p>Get the path to the CSV file.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The path to the CSV file.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.file_backup_count","title":"<code>file_backup_count: int</code>  <code>property</code>","text":"<p>Get the number of backup log files to keep.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of backup log files to keep.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.file_level","title":"<code>file_level: LogLevel</code>  <code>property</code>","text":"<p>Get the log level for file output.</p> <p>Returns:</p> Type Description <code>LogLevel</code> <p>The log level for file output.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.file_max_bytes","title":"<code>file_max_bytes: int</code>  <code>property</code>","text":"<p>Get the maximum size of the log file in bytes.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum size of the log file in bytes.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.file_path","title":"<code>file_path: Optional[str]</code>  <code>property</code>","text":"<p>Get the path to the log file.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The path to the log file.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.log_path","title":"<code>log_path: str</code>  <code>property</code>","text":"<p>Get the path to the log directory.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path to the log directory.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.stream_level","title":"<code>stream_level: LogLevel</code>  <code>property</code>","text":"<p>Get the log level for stream output.</p> <p>Returns:</p> Type Description <code>LogLevel</code> <p>The log level for stream output.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.tracked_variable_count","title":"<code>tracked_variable_count: int</code>  <code>property</code>","text":"<p>Get the number of currently tracked variables.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of currently tracked variables.</p>"},{"location":"modules/logging/#opensourceleg.logging.Logger.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context for the logger.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>The logger instance.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __enter__(self) -&gt; \"Logger\":\n    \"\"\"\n    Enter the runtime context for the logger.\n\n    Returns:\n        The logger instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the runtime context for the logger.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>The exception type, if an exception occurred.</p> required <code>exc_val</code> <code>Any</code> <p>The exception value, if an exception occurred.</p> required <code>exc_tb</code> <code>Any</code> <p>The traceback, if an exception occurred.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"\n    Exit the runtime context for the logger.\n\n    Args:\n        exc_type: The exception type, if an exception occurred.\n        exc_val: The exception value, if an exception occurred.\n        exc_tb: The traceback, if an exception occurred.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.__init__","title":"<code>__init__(log_path='./', log_format='[%(asctime)s] %(levelname)s: %(message)s', file_level=LogLevel.DEBUG, stream_level=LogLevel.INFO, file_max_bytes=0, file_backup_count=5, file_name=None, buffer_size=1000, enable_csv_logging=True)</code>","text":"<p>Initialize the Logger instance.</p> <p>Sets up logging paths, format, handler levels, and internal buffers for tracking variables.</p> <p>Parameters:</p> Name Type Description Default <code>log_path</code> <code>str</code> <p>Directory path where log files will be stored.</p> <code>'./'</code> <code>log_format</code> <code>str</code> <p>Format string for log messages.</p> <code>'[%(asctime)s] %(levelname)s: %(message)s'</code> <code>file_level</code> <code>LogLevel</code> <p>Logging level for file handler.</p> <code>DEBUG</code> <code>stream_level</code> <code>LogLevel</code> <p>Logging level for stream (console) handler.</p> <code>INFO</code> <code>file_max_bytes</code> <code>int</code> <p>Maximum size (in bytes) for log file rotation.</p> <code>0</code> <code>file_backup_count</code> <code>int</code> <p>Number of backup log files to keep.</p> <code>5</code> <code>file_name</code> <code>Union[str, None]</code> <p>Optional user-specified file name prefix.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>Maximum number of log records to buffer before writing to CSV.</p> <code>1000</code> <code>enable_csv_logging</code> <code>bool</code> <p>Whether to enable CSV logging.</p> <code>True</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __init__(\n    self,\n    log_path: str = \"./\",\n    log_format: str = \"[%(asctime)s] %(levelname)s: %(message)s\",\n    file_level: LogLevel = LogLevel.DEBUG,\n    stream_level: LogLevel = LogLevel.INFO,\n    file_max_bytes: int = 0,\n    file_backup_count: int = 5,\n    file_name: Union[str, None] = None,\n    buffer_size: int = 1000,\n    enable_csv_logging: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize the Logger instance.\n\n    Sets up logging paths, format, handler levels, and internal buffers for tracking variables.\n\n    Args:\n        log_path: Directory path where log files will be stored.\n        log_format: Format string for log messages.\n        file_level: Logging level for file handler.\n        stream_level: Logging level for stream (console) handler.\n        file_max_bytes: Maximum size (in bytes) for log file rotation.\n        file_backup_count: Number of backup log files to keep.\n        file_name: Optional user-specified file name prefix.\n        buffer_size: Maximum number of log records to buffer before writing to CSV.\n        enable_csv_logging: Whether to enable CSV logging.\n    \"\"\"\n    with self._lock:\n        if not hasattr(self, \"_initialized\"):\n            super().__init__(__name__)\n            self._log_path = log_path\n            self._log_format = log_format\n            self._file_level = file_level\n            self._stream_level = stream_level\n            self._file_max_bytes = file_max_bytes\n            self._file_backup_count = file_backup_count\n            self._user_file_name = file_name\n            self._enable_csv_logging = enable_csv_logging\n\n            self._file_path: str = \"\"\n            self._csv_path: str = \"\"\n            self._file: Optional[Any] = None\n            self._writer = None\n            self._is_logging = False\n            self._header_written = False\n\n            self._tracked_vars: dict[int, Callable[[], Any]] = {}\n            self._var_names: dict[int, str] = {}\n            self._buffer: deque = deque(maxlen=buffer_size)\n            self._buffer_size: int = buffer_size\n            self._error_count: dict[int, int] = {}  # Track errors per variable\n            self._max_errors_before_untrack: int = 5  # Auto-untrack after this many errors\n\n            try:\n                self._setup_logging()\n                self._initialized: bool = True\n            except Exception as e:\n                print(f\"Error initializing logger: {e}\")\n                raise\n        else:\n            self.set_file_name(file_name)\n            self.set_file_level(file_level)\n            self.set_stream_level(stream_level)\n            self.set_format(log_format)\n            self._file_max_bytes = file_max_bytes\n            self._file_backup_count = file_backup_count\n            self.set_buffer_size(buffer_size)\n            self._enable_csv_logging = enable_csv_logging\n            self._log_path = log_path\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.__new__","title":"<code>__new__(*args, **kwargs)</code>","text":"<p>Ensure that only one instance of Logger is created (singleton pattern).</p> <p>Returns:</p> Name Type Description <code>Logger</code> <code>Logger</code> <p>The singleton Logger instance.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Logger\":\n    \"\"\"\n    Ensure that only one instance of Logger is created (singleton pattern).\n\n    Returns:\n        Logger: The singleton Logger instance.\n    \"\"\"\n    with cls._lock:\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        else:\n            logging.debug(f\"Reusing existing Logger instance: {id(cls._instance)}\")\n    return cls._instance\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Logger instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation including the current file path and tracked variable count.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the Logger instance.\n\n    Returns:\n        str: A string representation including the current file path and tracked variable count.\n    \"\"\"\n    return f\"Logger(file_path={self._file_path}, tracked_vars={len(self._tracked_vars)})\"\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.close","title":"<code>close()</code>","text":"<p>Close the logger and flush any remaining log entries.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Close the logger and flush any remaining log entries.\n    \"\"\"\n    with self._lock:\n        try:\n            self.flush_buffer()\n            if self._file:\n                self._file.close()\n                self._file = None\n                self._writer = None\n        except Exception as e:\n            self.error(f\"Error closing logger: {e}\")\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.critical","title":"<code>critical(msg, *args, **kwargs)</code>","text":"<p>Log a critical message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments for the message.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def critical(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log a critical message.\n\n    Args:\n        msg: The message to log.\n        *args: Additional arguments for the message.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().critical(msg, *args, **kwargs)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.debug","title":"<code>debug(msg, *args, **kwargs)</code>","text":"<p>Log a debug message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments for the message.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def debug(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log a debug message.\n\n    Args:\n        msg: The message to log.\n        *args: Additional arguments for the message.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().debug(msg, *args, **kwargs)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.error","title":"<code>error(msg, *args, **kwargs)</code>","text":"<p>Log an error message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments for the message.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def error(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log an error message.\n\n    Args:\n        msg: The message to log.\n        *args: Additional arguments for the message.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().error(msg, *args, **kwargs)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.flush_buffer","title":"<code>flush_buffer()</code>","text":"<p>Write all buffered log entries to the CSV file.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def flush_buffer(self) -&gt; None:\n    \"\"\"\n    Write all buffered log entries to the CSV file.\n    \"\"\"\n    if not self._buffer or not self._enable_csv_logging:\n        return\n\n    with self._lock:\n        try:\n            self._ensure_file_handler()\n\n            if self._file is None:\n                try:\n                    self._file = open(self._csv_path, \"w\", newline=\"\")\n                    self._writer = csv.writer(self._file)  # type: ignore[assignment]\n                except Exception as e:\n                    self.error(f\"Failed to open CSV file {self._csv_path}: {e}\")\n                    # Clear buffer to prevent memory buildup\n                    self._buffer.clear()\n                    return\n\n            if not self._header_written:\n                self._write_header()\n\n            try:\n                self._writer.writerows(self._buffer)  # type: ignore[attr-defined]\n                self._buffer.clear()\n                self._file.flush()\n            except Exception as e:\n                self.error(f\"Failed to write to CSV file: {e}\")\n                # Try to recover by reopening the file\n                if self._file:\n                    with contextlib.suppress(Exception):\n                        self._file.close()\n                self._file = None\n                self._writer = None\n                self._header_written = False\n        except Exception as e:\n            self.error(f\"Unexpected error in flush_buffer: {e}\")\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.get_tracked_variables","title":"<code>get_tracked_variables()</code>","text":"<p>Get all currently tracked variables.</p> <p>Returns:</p> Type Description <code>list[tuple[str, Any]]</code> <p>A list of tuples containing (name, value) for each tracked variable.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def get_tracked_variables(self) -&gt; list[tuple[str, Any]]:\n    \"\"\"\n    Get all currently tracked variables.\n\n    Returns:\n        A list of tuples containing (name, value) for each tracked variable.\n    \"\"\"\n    with self._lock:\n        result = []\n        for var_id, get_value in self._tracked_vars.items():\n            name = self._var_names.get(var_id, \"unknown\")\n            try:\n                value = get_value()\n                result.append((name, value))\n            except Exception as e:\n                result.append((name, f\"ERROR: {e}\"))\n        return result\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.info","title":"<code>info(msg, *args, **kwargs)</code>","text":"<p>Log an info message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments for the message.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def info(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log an info message.\n\n    Args:\n        msg: The message to log.\n        *args: Additional arguments for the message.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().info(msg, *args, **kwargs)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.log","title":"<code>log(level, msg, *args, **kwargs)</code>","text":"<p>Log a message at a specific level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The log level to use.</p> required <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments for the message.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def log(self, level: int, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log a message at a specific level.\n\n    Args:\n        level: The log level to use.\n        msg: The message to log.\n        *args: Additional arguments for the message.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().log(level, msg, *args, **kwargs)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.reset","title":"<code>reset()</code>","text":"<p>Reset the logger state.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the logger state.\n    \"\"\"\n    with self._lock:\n        try:\n            self.close()\n\n            # Remove and clean up handlers\n            if hasattr(self, \"_file_handler\"):\n                self.removeHandler(self._file_handler)\n                self._file_handler.close()\n                del self._file_handler\n\n            if hasattr(self, \"_stream_handler\"):\n                self.removeHandler(self._stream_handler)\n                self._stream_handler.close()  # Close the stream handler\n                del self._stream_handler  # Delete the attribute\n\n            # Reinitialize logging\n            self._setup_logging()\n\n            # Reset tracking and state variables\n            self._tracked_vars.clear()\n            self._var_names.clear()\n            self._error_count.clear()\n            self._header_written = False\n            self._file = None\n            self._writer = None\n\n            self.debug(\"Logger reset successfully\")\n        except Exception as e:\n            print(f\"Error resetting logger: {e}\")  # Use print as logger might be in bad state\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.set_buffer_size","title":"<code>set_buffer_size(buffer_size)</code>","text":"<p>Set the maximum number of log entries to buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>The maximum number of entries to buffer.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_buffer_size(self, buffer_size: int) -&gt; None:\n    \"\"\"\n    Set the maximum number of log entries to buffer.\n\n    Args:\n        buffer_size: The maximum number of entries to buffer.\n    \"\"\"\n    with self._lock:\n        if buffer_size &lt;= 0:\n            self.warning(f\"Invalid buffer size: {buffer_size}. Using default of 1000.\")\n            buffer_size = 1000\n        self._buffer_size = buffer_size\n        # Create a new buffer with the updated size and copy over existing items\n        old_buffer = list(self._buffer)\n        self._buffer = deque(maxlen=buffer_size)\n        for item in old_buffer:\n            self._buffer.append(item)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.set_csv_logging","title":"<code>set_csv_logging(enable)</code>","text":"<p>Enable or disable CSV logging.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable CSV logging.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_csv_logging(self, enable: bool) -&gt; None:\n    \"\"\"\n    Enable or disable CSV logging.\n\n    Args:\n        enable: Whether to enable CSV logging.\n    \"\"\"\n    with self._lock:\n        if self._enable_csv_logging != enable:\n            self._enable_csv_logging = enable\n            if not enable:\n                self.flush_buffer()\n                if self._file:\n                    self._file.close()\n                    self._file = None\n                    self._writer = None\n            self.debug(f\"CSV logging {'enabled' if enable else 'disabled'}\")\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.set_file_level","title":"<code>set_file_level(level)</code>","text":"<p>Set the log level for file output.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>LogLevel</code> <p>The log level to use.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_file_level(self, level: LogLevel) -&gt; None:\n    \"\"\"\n    Set the log level for file output.\n\n    Args:\n        level: The log level to use.\n    \"\"\"\n    with self._lock:\n        self._file_level = level\n        if hasattr(self, \"_file_handler\"):\n            self._file_handler.setLevel(level=level.value)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.set_file_name","title":"<code>set_file_name(file_name)</code>","text":"<p>Set the name of the log file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, None]</code> <p>The name to use for the log file.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_file_name(self, file_name: Union[str, None]) -&gt; None:\n    \"\"\"\n    Set the name of the log file.\n\n    Args:\n        file_name: The name to use for the log file.\n    \"\"\"\n    with self._lock:\n        try:\n            # Ensure log directory exists\n            os.makedirs(self._log_path, exist_ok=True)\n\n            # Handle None file_name case\n            if file_name is None:\n                # Generate default name if none provided\n                now = datetime.now()\n                timestamp = now.strftime(\"%Y%m%d_%H%M%S\")\n                script_name = os.path.basename(__file__).split(\".\")[0]\n                file_name = f\"{script_name}_{timestamp}\"\n            elif \".\" in file_name:\n                # If filename has an extension, remove it\n                file_name = file_name.split(\".\")[0]\n\n            self._user_file_name = file_name\n            self._file_path = os.path.join(self._log_path, f\"{file_name}.log\")\n            self._csv_path = os.path.join(self._log_path, f\"{file_name}.csv\")\n\n            # If we already have a file handler, we need to recreate it\n            if hasattr(self, \"_file_handler\"):\n                self.removeHandler(self._file_handler)\n                self._file_handler.close()\n                del self._file_handler\n                self._setup_file_handler()\n\n            # Reset CSV file if it exists\n            if self._file:\n                self.close()\n        except Exception as e:\n            self.error(f\"Error setting file name: {e}\")\n            raise\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.set_format","title":"<code>set_format(log_format)</code>","text":"<p>Set the format for log messages.</p> <p>Parameters:</p> Name Type Description Default <code>log_format</code> <code>str</code> <p>The format string to use.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_format(self, log_format: str) -&gt; None:\n    \"\"\"\n    Set the format for log messages.\n\n    Args:\n        log_format: The format string to use.\n    \"\"\"\n    with self._lock:\n        self._log_format = log_format\n        self._std_formatter = logging.Formatter(log_format)\n        if hasattr(self, \"_file_handler\"):\n            self._file_handler.setFormatter(fmt=self._std_formatter)\n        self._stream_handler.setFormatter(fmt=self._std_formatter)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.set_max_errors_before_untrack","title":"<code>set_max_errors_before_untrack(max_errors)</code>","text":"<p>Set the maximum number of errors before untracking a variable.</p> <p>Parameters:</p> Name Type Description Default <code>max_errors</code> <code>int</code> <p>The maximum number of errors to allow.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_max_errors_before_untrack(self, max_errors: int) -&gt; None:\n    \"\"\"\n    Set the maximum number of errors before untracking a variable.\n\n    Args:\n        max_errors: The maximum number of errors to allow.\n    \"\"\"\n    with self._lock:\n        if max_errors &lt; 0:\n            self.warning(f\"Invalid max_errors value: {max_errors}. Using default of 5.\")\n            max_errors = 5\n        self._max_errors_before_untrack = max_errors\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.set_stream_level","title":"<code>set_stream_level(level)</code>","text":"<p>Set the log level for stream output.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>LogLevel</code> <p>The log level to use.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_stream_level(self, level: LogLevel) -&gt; None:\n    \"\"\"\n    Set the log level for stream output.\n\n    Args:\n        level: The log level to use.\n    \"\"\"\n    with self._lock:\n        self._stream_level = level\n        self._stream_handler.setLevel(level=level.value)\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.set_stream_terminator","title":"<code>set_stream_terminator(terminator)</code>","text":"<p>Set the terminator for stream output.</p> <p>Parameters:</p> Name Type Description Default <code>terminator</code> <code>str</code> <p>The terminator string to use.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_stream_terminator(self, terminator: str) -&gt; None:\n    \"\"\"\n    Set the terminator for stream output.\n\n    Args:\n        terminator: The terminator string to use.\n    \"\"\"\n    with self._lock:\n        self._stream_handler.terminator = terminator\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.track_variable","title":"<code>track_variable(var_func, name)</code>","text":"<p>Track a variable for logging.</p> <p>Parameters:</p> Name Type Description Default <code>var_func</code> <code>Callable[[], Any]</code> <p>A callable that returns the value to track.</p> required <code>name</code> <code>str</code> <p>The name to use for the variable in logs.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def track_variable(self, var_func: Callable[[], Any], name: str) -&gt; None:\n    \"\"\"\n    Track a variable for logging.\n\n    Args:\n        var_func: A callable that returns the value to track.\n        name: The name to use for the variable in logs.\n    \"\"\"\n    with self._lock:\n        var_id = id(var_func)\n        self._tracked_vars[var_id] = var_func\n        self._var_names[var_id] = name\n        self._error_count[var_id] = 0  # Initialize error count\n        self.debug(f\"Started tracking variable: {name}\")\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.untrack_variable","title":"<code>untrack_variable(var_func)</code>","text":"<p>Stop tracking a variable.</p> <p>Parameters:</p> Name Type Description Default <code>var_func</code> <code>Callable[[], Any]</code> <p>The callable that was previously tracked.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def untrack_variable(self, var_func: Callable[[], Any]) -&gt; None:\n    \"\"\"\n    Stop tracking a variable.\n\n    Args:\n        var_func: The callable that was previously tracked.\n    \"\"\"\n    with self._lock:\n        var_id = id(var_func)\n        if var_id in self._tracked_vars:\n            name = self._var_names.get(var_id, \"unknown\")\n            self._tracked_vars.pop(var_id, None)\n            self._var_names.pop(var_id, None)\n            self._error_count.pop(var_id, None)\n            self.debug(f\"Stopped tracking variable: {name}\")\n        else:\n            self.warning(\"Attempted to untrack a variable that wasn't being tracked\")\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.update","title":"<code>update()</code>","text":"<p>Update the tracked variables and write to the CSV file if the buffer is full.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Update the tracked variables and write to the CSV file if the buffer is full.\n    \"\"\"\n    if not self._tracked_vars or not self._enable_csv_logging:\n        return\n\n    with self._lock:\n        data = []\n        vars_to_untrack = []\n\n        for var_id, get_value in self._tracked_vars.items():\n            try:\n                value = get_value()\n                data.append(str(value))\n                # Reset error count on successful retrieval\n                self._error_count[var_id] = 0\n            except Exception as e:\n                var_name = self._var_names.get(var_id, \"unknown\")\n                self.warning(f\"Error getting value for {var_name}: {e}\")\n                data.append(\"ERROR\")\n\n                # Increment error count and check if we should untrack\n                self._error_count[var_id] = self._error_count.get(var_id, 0) + 1\n                if self._error_count[var_id] &gt;= self._max_errors_before_untrack:\n                    vars_to_untrack.append((var_id, var_name))\n\n        # Only add data if we have variables to track\n        if data:\n            self._buffer.append(data)\n\n        # Untrack variables with too many errors\n        for var_id, var_name in vars_to_untrack:\n            self._tracked_vars.pop(var_id, None)\n            self._var_names.pop(var_id, None)\n            self._error_count.pop(var_id, None)\n            self.warning(\n                f\"Auto-untracked variable {var_name} after {self._max_errors_before_untrack} consecutive errors\"\n            )\n\n        if len(self._buffer) &gt;= self._buffer_size:\n            self.flush_buffer()\n</code></pre>"},{"location":"modules/logging/#opensourceleg.logging.Logger.warning","title":"<code>warning(msg, *args, **kwargs)</code>","text":"<p>Log a warning message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments for the message.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def warning(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log a warning message.\n\n    Args:\n        msg: The message to log.\n        *args: Additional arguments for the message.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().warning(msg, *args, **kwargs)\n</code></pre>"},{"location":"modules/safety/","title":"Safety","text":""},{"location":"modules/safety/#opensourceleg.safety.SafetyDecorators","title":"<code>SafetyDecorators</code>  <code>dataclass</code>","text":"<p>Dataclass that contains all safety decorators.</p> <p>Attributes:</p> Name Type Description <code>is_changing</code> <p>Decorator to check if a property's value is changing.</p> <code>is_negative</code> <p>Decorator to check if a property's value is negative.</p> <code>is_positive</code> <p>Decorator to check if a property's value is positive.</p> <code>is_zero</code> <p>Decorator to check if a property's value is zero.</p> <code>is_within_range</code> <p>Decorator to check if a property's value is within a given range.</p> <code>is_greater_than</code> <p>Decorator to check if a property's value is greater than a given value.</p> <code>is_less_than</code> <p>Decorator to check if a property's value is less than a given value.</p> <code>custom_criteria</code> <p>Decorator to check if a property's value meets a custom criteria.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>@dataclass\nclass SafetyDecorators:\n    \"\"\"\n    Dataclass that contains all safety decorators.\n\n    Attributes:\n        is_changing: Decorator to check if a property's value is changing.\n        is_negative: Decorator to check if a property's value is negative.\n        is_positive: Decorator to check if a property's value is positive.\n        is_zero: Decorator to check if a property's value is zero.\n        is_within_range: Decorator to check if a property's value is within a given range.\n        is_greater_than: Decorator to check if a property's value is greater than a given value.\n        is_less_than: Decorator to check if a property's value is less than a given value.\n        custom_criteria: Decorator to check if a property's value meets a custom criteria.\n    \"\"\"\n\n    is_changing = is_changing\n    is_negative = is_negative\n    is_positive = is_positive\n    is_zero = is_zero\n    is_within_range = is_within_range\n    is_greater_than = is_greater_than\n    is_less_than = is_less_than\n    custom_criteria = custom_criteria\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.SafetyManager","title":"<code>SafetyManager</code>","text":"<p>The SafetyManager class enables the addition of safety decorators to an object's properties, specifically to their getters. When the 'start' method is invoked, these decorators are applied to the properties of the objects stored in the 'safe_objects' dictionary. The original objects are then replaced with subclasses that incorporate the decorated properties. Invoking the 'update' method accesses the properties of the objects in the 'safe_objects' dictionary, thereby triggering the decorators.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>class SafetyManager:\n    \"\"\"\n    The SafetyManager class enables the addition of safety decorators to an object's properties,\n    specifically to their getters. When the 'start' method is invoked, these decorators are applied\n    to the properties of the objects stored in the 'safe_objects' dictionary. The original objects\n    are then replaced with subclasses that incorporate the decorated properties.\n    Invoking the 'update' method accesses the properties of the objects in the 'safe_objects' dictionary,\n    thereby triggering the decorators.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._safe_objects: dict[object, dict[str, list[Callable]]] = {}\n\n    def add_safety(self, instance: object, attribute: str, decorator: Callable) -&gt; None:\n        \"\"\"\n        Adds a safety decorator to the given object's attribute. The decorator will be applied to the property's getter.\n\n        Args:\n            instance (object): Object that contains the attribute.\n            attribute (str): Name of the attribute.\n            decorator (Callable): Safety decorator to be applied to the attribute.\n\n        Raises:\n            AttributeError: If the attribute does not exist in the given object.\n            Warning: If the attribute is not a property. The SafetyManager only works on properties.\n        \"\"\"\n\n        if not hasattr(instance, attribute):\n            print(f\"Error: The attribute '{attribute}' does not exist in the given object.\")\n            return\n\n        original_attribute = getattr(instance.__class__, attribute, None)\n        if not isinstance(original_attribute, property):\n            print(\n                f\"Warning: The attribute '{attribute}' is not a property. The SafetyManager only works on properties.\"\n            )\n            return\n\n        if instance in self._safe_objects:\n            if attribute in self._safe_objects[instance]:\n                self._safe_objects[instance][attribute].append(decorator)\n            else:\n                self._safe_objects[instance][attribute] = [decorator]\n        else:\n            self._safe_objects[instance] = {attribute: [decorator]}\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Applies all decorators to the properties of the objects in the safe_objects dictionary.\n\n        Example:\n        &gt;&gt;&gt; safety_manager = SafetyManager()\n        &gt;&gt;&gt; safety_manager.add_safety(sensor, \"value\", SafetyDecorators.is_changing(\"value\"))\n        &gt;&gt;&gt; safety_manager.add_safety(sensor, \"a\", SafetyDecorators.is_positive())\n        &gt;&gt;&gt; safety_manager.start()\n        \"\"\"\n        for container, safe_attributes in self.safe_objects.items():\n            container_subclass = type(f\"{container.__class__.__name__}:SAFE\", (container.__class__,), {})\n            for attribute_name, attribute_decorators in safe_attributes.items():\n                original_property = getattr(container.__class__, attribute_name)\n                decorated_getter = original_property.fget\n                for attribute_decorator in reversed(attribute_decorators):\n                    decorated_getter = attribute_decorator(decorated_getter)\n\n                setattr(\n                    container_subclass,\n                    attribute_name,\n                    property(decorated_getter, original_property.fset, original_property.fdel),\n                )\n\n            container.__class__ = container_subclass\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Accesses the properties of the objects in the safe_objects dictionary, thereby triggering the decorators.\n\n        Example:\n        TODO: Add example\n        \"\"\"\n        for container, safe_attributes in self.safe_objects.items():\n            for attribute_name, _ in safe_attributes.items():\n                getattr(container, attribute_name)\n\n    @property\n    def safe_objects(self) -&gt; dict[object, dict[str, list[Callable]]]:\n        return self._safe_objects\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.SafetyManager.add_safety","title":"<code>add_safety(instance, attribute, decorator)</code>","text":"<p>Adds a safety decorator to the given object's attribute. The decorator will be applied to the property's getter.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>object</code> <p>Object that contains the attribute.</p> required <code>attribute</code> <code>str</code> <p>Name of the attribute.</p> required <code>decorator</code> <code>Callable</code> <p>Safety decorator to be applied to the attribute.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute does not exist in the given object.</p> <code>Warning</code> <p>If the attribute is not a property. The SafetyManager only works on properties.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def add_safety(self, instance: object, attribute: str, decorator: Callable) -&gt; None:\n    \"\"\"\n    Adds a safety decorator to the given object's attribute. The decorator will be applied to the property's getter.\n\n    Args:\n        instance (object): Object that contains the attribute.\n        attribute (str): Name of the attribute.\n        decorator (Callable): Safety decorator to be applied to the attribute.\n\n    Raises:\n        AttributeError: If the attribute does not exist in the given object.\n        Warning: If the attribute is not a property. The SafetyManager only works on properties.\n    \"\"\"\n\n    if not hasattr(instance, attribute):\n        print(f\"Error: The attribute '{attribute}' does not exist in the given object.\")\n        return\n\n    original_attribute = getattr(instance.__class__, attribute, None)\n    if not isinstance(original_attribute, property):\n        print(\n            f\"Warning: The attribute '{attribute}' is not a property. The SafetyManager only works on properties.\"\n        )\n        return\n\n    if instance in self._safe_objects:\n        if attribute in self._safe_objects[instance]:\n            self._safe_objects[instance][attribute].append(decorator)\n        else:\n            self._safe_objects[instance][attribute] = [decorator]\n    else:\n        self._safe_objects[instance] = {attribute: [decorator]}\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.SafetyManager.start","title":"<code>start()</code>","text":"<p>Applies all decorators to the properties of the objects in the safe_objects dictionary.</p> <p>Example:</p> <p>safety_manager = SafetyManager() safety_manager.add_safety(sensor, \"value\", SafetyDecorators.is_changing(\"value\")) safety_manager.add_safety(sensor, \"a\", SafetyDecorators.is_positive()) safety_manager.start()</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Applies all decorators to the properties of the objects in the safe_objects dictionary.\n\n    Example:\n    &gt;&gt;&gt; safety_manager = SafetyManager()\n    &gt;&gt;&gt; safety_manager.add_safety(sensor, \"value\", SafetyDecorators.is_changing(\"value\"))\n    &gt;&gt;&gt; safety_manager.add_safety(sensor, \"a\", SafetyDecorators.is_positive())\n    &gt;&gt;&gt; safety_manager.start()\n    \"\"\"\n    for container, safe_attributes in self.safe_objects.items():\n        container_subclass = type(f\"{container.__class__.__name__}:SAFE\", (container.__class__,), {})\n        for attribute_name, attribute_decorators in safe_attributes.items():\n            original_property = getattr(container.__class__, attribute_name)\n            decorated_getter = original_property.fget\n            for attribute_decorator in reversed(attribute_decorators):\n                decorated_getter = attribute_decorator(decorated_getter)\n\n            setattr(\n                container_subclass,\n                attribute_name,\n                property(decorated_getter, original_property.fset, original_property.fdel),\n            )\n\n        container.__class__ = container_subclass\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.SafetyManager.update","title":"<code>update()</code>","text":"<p>Accesses the properties of the objects in the safe_objects dictionary, thereby triggering the decorators.</p> <p>Example: TODO: Add example</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Accesses the properties of the objects in the safe_objects dictionary, thereby triggering the decorators.\n\n    Example:\n    TODO: Add example\n    \"\"\"\n    for container, safe_attributes in self.safe_objects.items():\n        for attribute_name, _ in safe_attributes.items():\n            getattr(container, attribute_name)\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.custom_criteria","title":"<code>custom_criteria(criteria)</code>","text":"<p>Creates a decorator to check if a property's value meets a custom criteria. The criteria is a function that takes the property's value as an argument and returns a boolean.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <code>Callable</code> <p>Custom criteria function.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value does not meet the custom criteria.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def custom_criteria(criteria: Callable) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value meets a custom criteria. The criteria is a\n    function that takes the property's value as an argument and returns a boolean.\n\n    Args:\n        criteria (Callable): Custom criteria function.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value does not meet the custom criteria.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if not criteria(value):\n                raise ValueError(\"Value does not meet custom criteria\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.is_changing","title":"<code>is_changing(attribute_name, max_points=10, threshold=1e-06, proxy_attribute_name=None)</code>","text":"<p>Creates a decorator to check if a property's value is changing. If the standard deviation of the last 'max_points' values is less than 'threshold', the decorator will raise an error or return a proxy attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attribute_name</code> <code>str</code> <p>Name of the attribute.</p> required <code>max_points</code> <code>int</code> <p>Number of points to consider. Defaults to 10.</p> <code>10</code> <code>threshold</code> <code>float</code> <p>Threshold for the standard deviation. Defaults to 1e-6.</p> <code>1e-06</code> <code>proxy_attribute_name</code> <code>Optional[str]</code> <p>Name of the proxy attribute to return if the property is not changing. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property is not changing and no proxy attribute is provided.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def is_changing(\n    attribute_name: str,\n    max_points: int = 10,\n    threshold: float = 1e-6,\n    proxy_attribute_name: Optional[str] = None,\n) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is changing.\n    If the standard deviation of the last 'max_points' values is less than 'threshold',\n    the decorator will raise an error or return a proxy attribute.\n\n    Args:\n        attribute_name: Name of the attribute.\n        max_points: Number of points to consider. Defaults to 10.\n        threshold: Threshold for the standard deviation. Defaults to 1e-6.\n        proxy_attribute_name: Name of the proxy attribute to return if the property is not changing. Defaults to None.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property is not changing and no proxy attribute is provided.\n\n    \"\"\"\n\n    history_key = f\"_{attribute_name}_history\"\n    proxy_key = f\"_{attribute_name}_proxy\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            instance.__dict__.setdefault(history_key, deque(maxlen=max_points))\n\n            if proxy_attribute_name is not None and getattr(instance, proxy_key):\n                return getattr(instance, proxy_attribute_name)\n\n            value = func(instance, *args, **kwargs)\n            history = getattr(instance, history_key)\n            history.append(value)\n            if len(history) == max_points:\n                current_std = np.std(list(history))\n                if current_std &lt; threshold:\n                    if proxy_attribute_name is not None:\n                        print(f\"{attribute_name} isn't changing, returning {proxy_attribute_name}\")\n                        if not hasattr(instance, proxy_key):\n                            setattr(instance, proxy_key, True)\n                        return getattr(instance, proxy_attribute_name)\n                    else:\n                        raise ValueError(f\"{attribute_name} is not changing\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.is_greater_than","title":"<code>is_greater_than(min_value, clamp=False, equality=False)</code>","text":"<p>Creates a decorator to check if a property's value is greater than a given value. Gives user choice to implement is_greater_than_or_equal_to with equality bool</p> <p>Parameters:</p> Name Type Description Default <code>min_value</code> <code>float</code> <p>Minimum value to check against.</p> required <code>clamp</code> <code>bool</code> <p>If True, the decorator will return the clamped value instead of raising an error. Defaults to False.</p> <code>False</code> <code>equality</code> <code>bool</code> <p>If True, the decorator will check for is greater than or equal to, instead of is greater than.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is less than or equal to the minimum value</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def is_greater_than(min_value: float, clamp: bool = False, equality: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is greater than a given value. Gives user\n    choice to implement is_greater_than_or_equal_to with equality bool\n\n    Args:\n        min_value: Minimum value to check against.\n        clamp: If True, the decorator will return the clamped value instead of raising an error. Defaults to False.\n        equality: If True, the decorator will check for is greater than or equal to, instead of is greater than.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is less than or equal to the minimum value\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if equality:\n                if value &lt; min_value:\n                    if clamp:\n                        return min_value\n                    raise ValueError(f\"Value must be greater than or equal to {min_value}\")\n            else:\n                if value &lt;= min_value:\n                    if clamp:\n                        return min_value\n                    raise ValueError(f\"Value must be greater than {min_value}\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.is_less_than","title":"<code>is_less_than(max_value, clamp=False, equality=False)</code>","text":"<p>Creates a decorator to check if a property's value is less than a given value. Gives user choice to implement is_less_than_or_equal_to with equality bool</p> <p>Parameters:</p> Name Type Description Default <code>max_value</code> <code>float</code> <p>Maximum value to check against.</p> required <code>clamp</code> <code>bool</code> <p>If True, the decorator will return the clamped value instead of raising an error. Defaults to False.</p> <code>False</code> <code>equality</code> <code>bool</code> <p>If True, the decorator will check for is less than or equal to, instead of is less than.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is greater than or equal to the maximum value</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def is_less_than(max_value: float, clamp: bool = False, equality: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is less than a given value. Gives user\n    choice to implement is_less_than_or_equal_to with equality bool\n\n    Args:\n        max_value: Maximum value to check against.\n        clamp: If True, the decorator will return the clamped value instead of raising an error. Defaults to False.\n        equality: If True, the decorator will check for is less than or equal to, instead of is less than.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is greater than or equal to the maximum value\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if equality:\n                if value &gt; max_value:\n                    if clamp:\n                        return max_value\n                    raise ValueError(f\"Value must be less than or equal to {max_value}\")\n            else:\n                if value &gt;= max_value:\n                    if clamp:\n                        return max_value\n                    raise ValueError(f\"Value must be less than {max_value}\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.is_negative","title":"<code>is_negative(clamp=False)</code>","text":"<p>Creates a decorator to check if a property's value is negative.</p> <p>Parameters:</p> Name Type Description Default <code>clamp</code> <code>bool</code> <p>If True, the decorator will return 0 instead of raising an error. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is not negative.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def is_negative(clamp: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is negative.\n\n    Args:\n        clamp (bool): If True, the decorator will return 0 instead of raising an error. Defaults to False.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is not negative.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if value &gt;= 0:\n                if clamp:\n                    return 0\n                raise ValueError(\"Value must be negative\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.is_positive","title":"<code>is_positive(clamp=False)</code>","text":"<p>Creates a decorator to check if a property's value is positive.</p> <p>Parameters:</p> Name Type Description Default <code>clamp</code> <code>bool</code> <p>If True, the decorator will return 0 instead of raising an error. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is not positive.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def is_positive(clamp: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is positive.\n\n    Args:\n        clamp (bool): If True, the decorator will return 0 instead of raising an error. Defaults to False.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is not positive.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if value &lt;= 0:\n                if clamp:\n                    return 0\n                raise ValueError(\"Value must be positive\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.is_within_range","title":"<code>is_within_range(min_value, max_value, clamp=False)</code>","text":"<p>Creates a decorator to check if a property's value is within a given range.</p> <p>Parameters:</p> Name Type Description Default <code>min_value</code> <code>float</code> <p>Minimum value of the range.</p> required <code>max_value</code> <code>float</code> <p>Maximum value of the range.</p> required <code>clamp</code> <code>bool</code> <p>If True, the decorator will return the clamped value instead of raising an error. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the maximum value is less than or equal to the minimum value.</p> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def is_within_range(min_value: float, max_value: float, clamp: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is within a given range.\n\n    Args:\n        min_value: Minimum value of the range.\n        max_value: Maximum value of the range.\n        clamp: If True, the decorator will return the clamped value instead of raising an error. Defaults to False.\n\n    Raises:\n        ValueError: If the maximum value is less than or equal to the minimum value.\n\n    Returns:\n        Callable: Decorator function.\n    \"\"\"\n\n    if max_value &lt;= min_value:\n        raise ValueError(\"Maximum value must be greater than minimum value of range\")\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if value &lt; min_value or value &gt; max_value:\n                if clamp:\n                    return min(max_value, max(min_value, value))\n                raise ValueError(f\"Value must be within {min_value} and {max_value}\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"modules/safety/#opensourceleg.safety.is_zero","title":"<code>is_zero(clamp=False)</code>","text":"<p>Creates a decorator to check if a property's value is zero.</p> <p>Parameters:</p> Name Type Description Default <code>clamp</code> <code>bool</code> <p>If True, the decorator will return 0 instead of raising an error. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is not zero.</p> Source code in <code>opensourceleg/safety/safety.py</code> <pre><code>def is_zero(clamp: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is zero.\n\n    Args:\n        clamp (bool): If True, the decorator will return 0 instead of raising an error. Defaults to False.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is not zero.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if value != 0:\n                if clamp:\n                    return 0\n                raise ValueError(\"Value must be zero\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"modules/time/","title":"Time","text":""},{"location":"modules/time/#opensourceleg.time.SoftRealtimeLoop","title":"<code>SoftRealtimeLoop</code>","text":"<p>Soft Realtime Loop---a class designed to allow clean exits from infinite loops with the potential for post-loop cleanup operations executing.</p> <p>The Loop Killer object watches for the key shutdown signals on the UNIX operating system (which runs on the PI) when it detects a shutdown signal, it sets a flag, which is used by the Soft Realtime Loop to stop iterating. Typically, it detects the CTRL-C from your keyboard, which sends a SIGTERM signal.</p> <p>the function_in_loop argument to the Soft Realtime Loop's blocking_loop method is the function to be run every loop. A typical usage would set function_in_loop to be a method of an object, so that the object could store program state. See the 'ifmain' for two examples.</p> <p>This library will soon be hosted as a PIP module and added as a python dependency. https://github.com/UM-LoCoLab/NeuroLocoMiddleware/blob/main/SoftRealtimeLoop.py</p>"},{"location":"modules/time/#opensourceleg.time.SoftRealtimeLoop--author-gray-c-thomas-phd","title":"Author: Gray C. Thomas, Ph.D","text":""},{"location":"modules/time/#opensourceleg.time.SoftRealtimeLoop--httpsgithubcomgraythomas-httpsgraythomasgithubio","title":"https://github.com/GrayThomas, https://graythomas.github.io","text":"Source code in <code>opensourceleg/time/time.py</code> <pre><code>class SoftRealtimeLoop:\n    \"\"\"\n    Soft Realtime Loop---a class designed to allow clean exits from infinite loops\n    with the potential for post-loop cleanup operations executing.\n\n    The Loop Killer object watches for the key shutdown signals on the UNIX operating system (which runs on the PI)\n    when it detects a shutdown signal, it sets a flag, which is used by the Soft Realtime Loop to stop iterating.\n    Typically, it detects the CTRL-C from your keyboard, which sends a SIGTERM signal.\n\n    the function_in_loop argument to the Soft Realtime Loop's blocking_loop method is the function to be run every loop.\n    A typical usage would set function_in_loop to be a method of an object, so that the object could store\n    program state. See the 'ifmain' for two examples.\n\n    This library will soon be hosted as a PIP module and added as a python dependency.\n    https://github.com/UM-LoCoLab/NeuroLocoMiddleware/blob/main/SoftRealtimeLoop.py\n\n    # Author: Gray C. Thomas, Ph.D\n    # https://github.com/GrayThomas, https://graythomas.github.io\n\n    \"\"\"\n\n    def __init__(self, dt: float = 0.001, report: bool = True, fade: float = 0.0):\n        self.t0: float = time.monotonic()\n        self.t1: float = self.t0\n        self.killer: LoopKiller = LoopKiller(fade_time=fade)\n        self.dt: float = dt\n        self.ttarg: Any = None\n        self.sum_err: float = 0.0\n        self.sum_var: float = 0.0\n        self.sleep_t_agg: float = 0.0\n        self.n: int = 0\n        self.report: bool = report\n\n    def __repr__(self) -&gt; str:\n        return \"SoftRealtimeLoop\"\n\n    def __del__(self) -&gt; None:\n        if self.report and self.n &gt; 0:  # Only report if we have at least one cycle\n            print(\"In %d cycles at %.2f Hz:\" % (self.n, 1.0 / self.dt))\n            print(\"\\tavg error: %.3f milliseconds\" % (1e3 * self.sum_err / self.n))\n            if self.n &gt; 1:  # Need at least 2 samples for standard deviation\n                print(\n                    \"\\tstddev error: %.3f milliseconds\"\n                    % (1e3 * sqrt(max(0, (self.sum_var - self.sum_err**2 / self.n) / (self.n - 1))))\n                )\n            else:\n                print(\"\\tstddev error: N/A (need at least 2 samples)\")\n\n            total_time = self.time()\n            if total_time &gt; 0:  # Prevent division by zero\n                print(\"\\tpercent of time sleeping: %.1f %%\" % (self.sleep_t_agg / total_time * 100.0))\n            else:\n                print(\"\\tpercent of time sleeping: N/A (total time is zero)\")\n\n    @property\n    def fade(self) -&gt; float:\n        \"\"\"\n        Property to get the fade value.\n\n        Returns:\n            float: The fade value.\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.fade\n        \"\"\"\n        return self.killer.get_fade()\n\n    def run(self, function_in_loop: Callable, dt: Optional[float] = None) -&gt; None:\n        \"\"\"\n        Method to run the function within the time loop.\n\n        Args:\n            function_in_loop (Callable): The function to run within the time loop.\n            dt (Optional[float]): The time delta. Defaults to None.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.run(function_in_loop)\n            TODO: Better example here.\n        \"\"\"\n        if dt is None:\n            dt = self.dt\n        self.t0 = self.t1 = time.monotonic() + dt\n        while not self.killer.kill_now:\n            ret = function_in_loop()\n            if ret == 0:\n                self.stop()\n            while time.monotonic() &lt; self.t1 and not self.killer.kill_now:\n                if signal.sigtimedwait([signal.SIGTERM, signal.SIGINT, signal.SIGHUP], 0):\n                    self.stop()\n            self.t1 += dt\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Method to stop the loop.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.start()\n            ... Running loop ...\n            &gt;&gt;&gt; loop.stop()\n        \"\"\"\n        self.killer.kill_now = True\n\n    def time(self) -&gt; float:\n        \"\"\"\n        Method to get the current time since the start of the time loop.\n\n        Returns:\n            float: The time since the start of the time loop.\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.time()\n        \"\"\"\n        return time.monotonic() - self.t0\n\n    def time_since(self) -&gt; float:\n        \"\"\"\n        Method to get the time since the last loop. TODO: Is this true?\n\n        Returns:\n            float: The time since the last loop.\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.time_since()\n        \"\"\"\n        return time.monotonic() - self.t1\n\n    def __iter__(self) -&gt; \"SoftRealtimeLoop\":\n        self.t0 = self.t1 = time.monotonic() + self.dt\n        return self\n\n    def __next__(self) -&gt; float:\n        if self.killer.kill_now:\n            raise StopIteration\n\n        while time.monotonic() &lt; self.t1 - 2 * PRECISION_OF_SLEEP and not self.killer.kill_now:\n            t_pre_sleep = time.monotonic()\n            time.sleep(max(PRECISION_OF_SLEEP, self.t1 - time.monotonic() - PRECISION_OF_SLEEP))\n            self.sleep_t_agg += time.monotonic() - t_pre_sleep\n\n        while time.monotonic() &lt; self.t1 and not self.killer.kill_now:\n            try:\n                if signal.sigtimedwait([signal.SIGTERM, signal.SIGINT, signal.SIGHUP], 0):\n                    self.stop()\n            except AttributeError:\n                pass\n\n        if self.killer.kill_now:\n            raise StopIteration\n        self.t1 += self.dt\n        if self.ttarg is None:\n            # inits ttarg on first call\n            self.ttarg = time.monotonic() + self.dt\n            # then skips the first loop\n            return self.t1 - self.t0\n        error = time.monotonic() - self.ttarg  # seconds\n        self.sum_err += error\n        self.sum_var += error**2\n        self.n += 1\n        self.ttarg += self.dt\n        return self.t1 - self.t0\n</code></pre>"},{"location":"modules/time/#opensourceleg.time.SoftRealtimeLoop.fade","title":"<code>fade: float</code>  <code>property</code>","text":"<p>Property to get the fade value.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The fade value.</p> Example <p>loop = SoftRealtimeLoop() loop.fade</p>"},{"location":"modules/time/#opensourceleg.time.SoftRealtimeLoop.run","title":"<code>run(function_in_loop, dt=None)</code>","text":"<p>Method to run the function within the time loop.</p> <p>Parameters:</p> Name Type Description Default <code>function_in_loop</code> <code>Callable</code> <p>The function to run within the time loop.</p> required <code>dt</code> <code>Optional[float]</code> <p>The time delta. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>loop = SoftRealtimeLoop() loop.run(function_in_loop) TODO: Better example here.</p> Source code in <code>opensourceleg/time/time.py</code> <pre><code>def run(self, function_in_loop: Callable, dt: Optional[float] = None) -&gt; None:\n    \"\"\"\n    Method to run the function within the time loop.\n\n    Args:\n        function_in_loop (Callable): The function to run within the time loop.\n        dt (Optional[float]): The time delta. Defaults to None.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; loop = SoftRealtimeLoop()\n        &gt;&gt;&gt; loop.run(function_in_loop)\n        TODO: Better example here.\n    \"\"\"\n    if dt is None:\n        dt = self.dt\n    self.t0 = self.t1 = time.monotonic() + dt\n    while not self.killer.kill_now:\n        ret = function_in_loop()\n        if ret == 0:\n            self.stop()\n        while time.monotonic() &lt; self.t1 and not self.killer.kill_now:\n            if signal.sigtimedwait([signal.SIGTERM, signal.SIGINT, signal.SIGHUP], 0):\n                self.stop()\n        self.t1 += dt\n</code></pre>"},{"location":"modules/time/#opensourceleg.time.SoftRealtimeLoop.stop","title":"<code>stop()</code>","text":"<p>Method to stop the loop.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>loop = SoftRealtimeLoop() loop.start() ... Running loop ... loop.stop()</p> Source code in <code>opensourceleg/time/time.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Method to stop the loop.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; loop = SoftRealtimeLoop()\n        &gt;&gt;&gt; loop.start()\n        ... Running loop ...\n        &gt;&gt;&gt; loop.stop()\n    \"\"\"\n    self.killer.kill_now = True\n</code></pre>"},{"location":"modules/time/#opensourceleg.time.SoftRealtimeLoop.time","title":"<code>time()</code>","text":"<p>Method to get the current time since the start of the time loop.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The time since the start of the time loop.</p> Example <p>loop = SoftRealtimeLoop() loop.time()</p> Source code in <code>opensourceleg/time/time.py</code> <pre><code>def time(self) -&gt; float:\n    \"\"\"\n    Method to get the current time since the start of the time loop.\n\n    Returns:\n        float: The time since the start of the time loop.\n\n    Example:\n        &gt;&gt;&gt; loop = SoftRealtimeLoop()\n        &gt;&gt;&gt; loop.time()\n    \"\"\"\n    return time.monotonic() - self.t0\n</code></pre>"},{"location":"modules/time/#opensourceleg.time.SoftRealtimeLoop.time_since","title":"<code>time_since()</code>","text":"<p>Method to get the time since the last loop. TODO: Is this true?</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The time since the last loop.</p> Example <p>loop = SoftRealtimeLoop() loop.time_since()</p> Source code in <code>opensourceleg/time/time.py</code> <pre><code>def time_since(self) -&gt; float:\n    \"\"\"\n    Method to get the time since the last loop. TODO: Is this true?\n\n    Returns:\n        float: The time since the last loop.\n\n    Example:\n        &gt;&gt;&gt; loop = SoftRealtimeLoop()\n        &gt;&gt;&gt; loop.time_since()\n    \"\"\"\n    return time.monotonic() - self.t1\n</code></pre>"},{"location":"modules/actuators/actuators/","title":"Base","text":""},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase","title":"<code>ActuatorBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class defining the structure and interface for an actuator.</p> <p>This abstract class provides common functionality for controlling an actuator, including managing control mode transitions, restricting method calls based on mode, and exposing actuator properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class DummyActuator(ActuatorBase):\n...     @property\n...     def _CONTROL_MODE_CONFIGS(self):\n...         return CONTROL_MODE_CONFIGS()\n...     def start(self):\n...         print(\"Started\")\n...     def stop(self):\n...         print(\"Stopped\")\n...     def update(self):\n...         print(\"Updated\")\n...     def set_motor_voltage(self, value: float) -&gt; None:\n...         print(f\"Motor voltage set to {value}\")\n...     def set_motor_current(self, value: float) -&gt; None:\n...         print(f\"Motor current set to {value}\")\n...     def set_motor_position(self, value: float) -&gt; None:\n...         print(f\"Motor position set to {value}\")\n...     def set_motor_torque(self, value: float) -&gt; None:\n...         print(f\"Motor torque set to {value}\")\n...     def set_joint_torque(self, value: float) -&gt; None:\n...         print(f\"Joint torque set to {value}\")\n...     def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n...         print(\"Current gains set\")\n...     def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n...         print(\"Position gains set\")\n...     def set_impedance_gains(self, kp: float, ki: float, kd: float, k: float, b: float, ff: float) -&gt; None:\n...         print(\"Impedance gains set\")\n...     def home(self) -&gt; None:\n...         print(\"Homed\")\n...     @property\n...     def motor_position(self) -&gt; float:\n...         return 100.0\n...     @property\n...     def motor_velocity(self) -&gt; float:\n...         return 10.0\n...     @property\n...     def motor_voltage(self) -&gt; float:\n...         return 24.0\n...     @property\n...     def motor_current(self) -&gt; float:\n...         return 0.5\n...     @property\n...     def motor_torque(self) -&gt; float:\n...         return 2.0\n...     @property\n...     def case_temperature(self) -&gt; float:\n...         return 70.0\n...     @property\n...     def winding_temperature(self) -&gt; float:\n...         return 90.0\n&gt;&gt;&gt; actuator = DummyActuator(\n...     tag=\"act1\",\n...     gear_ratio=100,\n...     motor_constants=MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n... )\n&gt;&gt;&gt; actuator.start()\nStarted\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>class ActuatorBase(ABC):\n    \"\"\"\n    Base class defining the structure and interface for an actuator.\n\n    This abstract class provides common functionality for controlling an actuator,\n    including managing control mode transitions, restricting method calls based on mode,\n    and exposing actuator properties.\n\n    Examples:\n        &gt;&gt;&gt; class DummyActuator(ActuatorBase):\n        ...     @property\n        ...     def _CONTROL_MODE_CONFIGS(self):\n        ...         return CONTROL_MODE_CONFIGS()\n        ...     def start(self):\n        ...         print(\"Started\")\n        ...     def stop(self):\n        ...         print(\"Stopped\")\n        ...     def update(self):\n        ...         print(\"Updated\")\n        ...     def set_motor_voltage(self, value: float) -&gt; None:\n        ...         print(f\"Motor voltage set to {value}\")\n        ...     def set_motor_current(self, value: float) -&gt; None:\n        ...         print(f\"Motor current set to {value}\")\n        ...     def set_motor_position(self, value: float) -&gt; None:\n        ...         print(f\"Motor position set to {value}\")\n        ...     def set_motor_torque(self, value: float) -&gt; None:\n        ...         print(f\"Motor torque set to {value}\")\n        ...     def set_joint_torque(self, value: float) -&gt; None:\n        ...         print(f\"Joint torque set to {value}\")\n        ...     def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        ...         print(\"Current gains set\")\n        ...     def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        ...         print(\"Position gains set\")\n        ...     def set_impedance_gains(self, kp: float, ki: float, kd: float, k: float, b: float, ff: float) -&gt; None:\n        ...         print(\"Impedance gains set\")\n        ...     def home(self) -&gt; None:\n        ...         print(\"Homed\")\n        ...     @property\n        ...     def motor_position(self) -&gt; float:\n        ...         return 100.0\n        ...     @property\n        ...     def motor_velocity(self) -&gt; float:\n        ...         return 10.0\n        ...     @property\n        ...     def motor_voltage(self) -&gt; float:\n        ...         return 24.0\n        ...     @property\n        ...     def motor_current(self) -&gt; float:\n        ...         return 0.5\n        ...     @property\n        ...     def motor_torque(self) -&gt; float:\n        ...         return 2.0\n        ...     @property\n        ...     def case_temperature(self) -&gt; float:\n        ...         return 70.0\n        ...     @property\n        ...     def winding_temperature(self) -&gt; float:\n        ...         return 90.0\n        &gt;&gt;&gt; actuator = DummyActuator(\n        ...     tag=\"act1\",\n        ...     gear_ratio=100,\n        ...     motor_constants=MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n        ... )\n        &gt;&gt;&gt; actuator.start()\n        Started\n    \"\"\"\n\n    # Class-level mapping of methods to their required control modes\n    _METHOD_REQUIRED_MODES: ClassVar[dict[str, set[CONTROL_MODES]]] = {\n        \"set_motor_voltage\": {CONTROL_MODES.VOLTAGE},\n        \"set_motor_current\": {CONTROL_MODES.CURRENT},\n        \"set_motor_position\": {CONTROL_MODES.POSITION},\n        \"set_motor_torque\": {CONTROL_MODES.TORQUE},\n        \"set_joint_torque\": {CONTROL_MODES.TORQUE},\n        \"set_current_gains\": {CONTROL_MODES.CURRENT},\n        \"set_position_gains\": {CONTROL_MODES.POSITION},\n        \"set_impedance_gains\": {CONTROL_MODES.IMPEDANCE},\n    }\n\n    def __init__(\n        self,\n        tag: str,\n        gear_ratio: float,\n        motor_constants: MOTOR_CONSTANTS,\n        frequency: int = 1000,\n        offline: bool = False,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the actuator.\n\n        Args:\n            tag: A unique identifier for the actuator.\n            gear_ratio: The gear ratio of the actuator.\n            motor_constants: The motor constants for the actuator.\n            frequency: The control frequency in Hz. Defaults to 1000.\n            offline: Whether the actuator is in offline mode. Defaults to False.\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self._tag = tag\n        self._gear_ratio = gear_ratio\n        self._motor_constants = motor_constants\n        self._frequency = frequency\n        self._offline = offline\n        self._mode = CONTROL_MODES.IDLE\n        self._is_homed = False\n        self._is_open = False\n        self._is_streaming = False\n        self._motor_zero_position = 0.0\n        self._motor_position_offset = 0.0\n        self._joint_zero_position = 0.0\n        self._joint_position_offset = 0.0\n        self._joint_direction = 1\n        self._original_methods: dict[str, Callable] = {}\n        self._mutated_methods: dict[str, Callable] = {}\n\n        self._set_original_methods()\n        self._set_mutated_methods()\n\n    def __enter__(self) -&gt; \"ActuatorBase\":\n        \"\"\"\n        Context manager entry.\n\n        Returns:\n            The actuator instance.\n        \"\"\"\n        self.start()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, exc_traceback: Any) -&gt; None:\n        \"\"\"\n        Context manager exit.\n\n        Args:\n            exc_type: The type of the exception, if any.\n            exc_value: The value of the exception, if any.\n            exc_traceback: The traceback of the exception, if any.\n        \"\"\"\n        self.stop()\n\n    def _restricted_method(self, method_name: str, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Check if a method can be called in the current control mode.\n\n        Args:\n            method_name: The name of the method to check.\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Raises:\n            ControlModeException: If the method cannot be called in the current mode.\n        \"\"\"\n        if method_name in self._METHOD_REQUIRED_MODES:\n            required_modes = self._METHOD_REQUIRED_MODES[method_name]\n            if self._mode not in required_modes:\n                raise ControlModeException(\n                    f\"Method {method_name} requires control mode(s) {required_modes}, but current mode is {self._mode}\"\n                )\n        self._mutated_methods[method_name](*args, **kwargs)\n\n    def _set_original_methods(self) -&gt; None:\n        \"\"\"Store original method implementations.\"\"\"\n        for name, method in self.__class__.__dict__.items():\n            if callable(method):\n                self._original_methods[name] = method\n\n    def _set_mutated_methods(self) -&gt; None:\n        \"\"\"Create mutated method implementations with mode restrictions.\"\"\"\n        for name, method in self._original_methods.items():\n            if name in self._METHOD_REQUIRED_MODES:\n                self._mutated_methods[name] = partial(self._restricted_method, name)\n            else:\n                self._mutated_methods[name] = method\n\n    @property\n    @abstractmethod\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        \"\"\"\n        Get the control mode configurations.\n\n        Returns:\n            The control mode configurations.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the actuator.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the actuator.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the actuator state.\n        \"\"\"\n        pass\n\n    def _get_control_mode_config(self, mode: CONTROL_MODES) -&gt; Optional[ControlModeConfig]:\n        \"\"\"\n        Get the configuration for a control mode.\n\n        Args:\n            mode: The control mode to get the configuration for.\n\n        Returns:\n            The control mode configuration, if it exists.\n        \"\"\"\n        configs = self._CONTROL_MODE_CONFIGS\n        return getattr(configs, mode.name, None)\n\n    def set_control_mode(self, mode: CONTROL_MODES) -&gt; None:\n        \"\"\"\n        Set the control mode of the actuator.\n\n        Args:\n            mode: The control mode to set.\n\n        Raises:\n            ControlModeException: If the control mode is not supported.\n        \"\"\"\n        if mode == self._mode:\n            return\n\n        # Exit current mode\n        current_config = self._get_control_mode_config(self._mode)\n        if current_config and current_config.exit_callback:\n            current_config.exit_callback(self)\n\n        # Enter new mode\n        new_config = self._get_control_mode_config(mode)\n        if new_config and new_config.entry_callback:\n            new_config.entry_callback(self)\n\n        self._mode = mode\n\n    @abstractmethod\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor voltage.\n\n        Args:\n            value: The voltage to set.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_motor_current(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor current.\n\n        Args:\n            value: The current to set.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor position.\n\n        Args:\n            value: The position to set.\n        \"\"\"\n        pass\n\n    def set_output_position(self, value: float) -&gt; None:\n        \"\"\"\n        Set the output position.\n\n        Args:\n            value: The position to set.\n        \"\"\"\n        motor_value = value * self._gear_ratio\n        self.set_motor_position(motor_value)\n\n    @abstractmethod\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor torque.\n\n        Args:\n            value: The torque to set.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_joint_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the joint torque.\n\n        Args:\n            value: The torque to set.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        \"\"\"\n        Set the current control gains.\n\n        Args:\n            kp: The proportional gain.\n            ki: The integral gain.\n            kd: The derivative gain.\n            ff: The feedforward gain.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        \"\"\"\n        Set the position control gains.\n\n        Args:\n            kp: The proportional gain.\n            ki: The integral gain.\n            kd: The derivative gain.\n            ff: The feedforward gain.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_impedance_gains(self, kp: float, ki: float, kd: float, k: float, b: float, ff: float) -&gt; None:\n        \"\"\"\n        Set the impedance control gains.\n\n        Args:\n            kp: The proportional gain.\n            ki: The integral gain.\n            kd: The derivative gain.\n            k: The stiffness gain.\n            b: The damping gain.\n            ff: The feedforward gain.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def home(self) -&gt; None:\n        \"\"\"\n        Home the actuator.\n        \"\"\"\n        pass\n\n    def set_motor_zero_position(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor zero position.\n\n        Args:\n            value: The zero position to set.\n        \"\"\"\n        self._motor_zero_position = value\n\n    def set_motor_position_offset(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor position offset.\n\n        Args:\n            value: The position offset to set.\n        \"\"\"\n        self._motor_position_offset = value\n\n    def set_joint_zero_position(self, value: float) -&gt; None:\n        \"\"\"\n        Set the joint zero position.\n\n        Args:\n            value: The zero position to set.\n        \"\"\"\n        self._joint_zero_position = value\n\n    def set_joint_position_offset(self, value: float) -&gt; None:\n        \"\"\"\n        Set the joint position offset.\n\n        Args:\n            value: The position offset to set.\n        \"\"\"\n        self._joint_position_offset = value\n\n    def set_joint_direction(self, value: int) -&gt; None:\n        \"\"\"\n        Set the joint direction.\n\n        Args:\n            value: The direction to set.\n        \"\"\"\n        if value not in [-1, 1]:\n            raise ValueError(\"Joint direction must be either 1 or -1\")\n        self._joint_direction = value\n\n    @property\n    @abstractmethod\n    def motor_position(self) -&gt; float:\n        \"\"\"\n        Get the motor position.\n\n        Returns:\n            The motor position.\n        \"\"\"\n        pass\n\n    @property\n    def output_position(self) -&gt; float:\n        \"\"\"\n        Get the output position.\n\n        Returns:\n            The output position.\n        \"\"\"\n        return self.motor_position / self._gear_ratio\n\n    @property\n    @abstractmethod\n    def motor_velocity(self) -&gt; float:\n        \"\"\"\n        Get the motor velocity.\n\n        Returns:\n            The motor velocity.\n        \"\"\"\n        pass\n\n    @property\n    def output_velocity(self) -&gt; float:\n        \"\"\"\n        Get the output velocity.\n\n        Returns:\n            The output velocity.\n        \"\"\"\n        return self.motor_velocity / self._gear_ratio\n\n    @property\n    @abstractmethod\n    def motor_voltage(self) -&gt; float:\n        \"\"\"\n        Get the motor voltage.\n\n        Returns:\n            The motor voltage.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def motor_current(self) -&gt; float:\n        \"\"\"\n        Get the motor current.\n\n        Returns:\n            The motor current.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def motor_torque(self) -&gt; float:\n        \"\"\"\n        Get the motor torque.\n\n        Returns:\n            The motor torque.\n        \"\"\"\n        pass\n\n    @property\n    def MOTOR_CONSTANTS(self) -&gt; MOTOR_CONSTANTS:\n        \"\"\"\n        Get the motor constants.\n\n        Returns:\n            The motor constants.\n        \"\"\"\n        return self._motor_constants\n\n    @property\n    def mode(self) -&gt; CONTROL_MODES:\n        \"\"\"\n        Get the current control mode.\n\n        Returns:\n            The current control mode.\n        \"\"\"\n        return self._mode\n\n    @property\n    def tag(self) -&gt; str:\n        \"\"\"\n        Get the actuator tag.\n\n        Returns:\n            The actuator tag.\n        \"\"\"\n        return self._tag\n\n    @property\n    def is_homed(self) -&gt; bool:\n        \"\"\"\n        Check if the actuator is homed.\n\n        Returns:\n            True if the actuator is homed, False otherwise.\n        \"\"\"\n        return self._is_homed\n\n    @property\n    def frequency(self) -&gt; int:\n        \"\"\"\n        Get the control frequency.\n\n        Returns:\n            The control frequency in Hz.\n        \"\"\"\n        return self._frequency\n\n    @property\n    def is_offline(self) -&gt; bool:\n        \"\"\"\n        Check if the actuator is offline.\n\n        Returns:\n            True if the actuator is offline, False otherwise.\n        \"\"\"\n        return self._offline\n\n    @property\n    def gear_ratio(self) -&gt; float:\n        \"\"\"\n        Get the gear ratio.\n\n        Returns:\n            The gear ratio.\n        \"\"\"\n        return self._gear_ratio\n\n    @property\n    def max_case_temperature(self) -&gt; float:\n        \"\"\"\n        Get the maximum case temperature.\n\n        Returns:\n            The maximum case temperature.\n        \"\"\"\n        return self._motor_constants.MAX_CASE_TEMPERATURE\n\n    @property\n    @abstractmethod\n    def case_temperature(self) -&gt; float:\n        \"\"\"\n        Get the case temperature.\n\n        Returns:\n            The case temperature.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        Get the winding temperature.\n\n        Returns:\n            The winding temperature.\n        \"\"\"\n        pass\n\n    @property\n    def max_winding_temperature(self) -&gt; float:\n        \"\"\"\n        Get the maximum winding temperature.\n\n        Returns:\n            The maximum winding temperature.\n        \"\"\"\n        return self._motor_constants.MAX_WINDING_TEMPERATURE\n\n    @property\n    def motor_zero_position(self) -&gt; float:\n        \"\"\"\n        Get the motor zero position.\n\n        Returns:\n            The motor zero position.\n        \"\"\"\n        return self._motor_zero_position\n\n    @property\n    def motor_position_offset(self) -&gt; float:\n        \"\"\"\n        Get the motor position offset.\n\n        Returns:\n            The motor position offset.\n        \"\"\"\n        return self._motor_position_offset\n\n    @property\n    def joint_zero_position(self) -&gt; float:\n        \"\"\"\n        Get the joint zero position.\n\n        Returns:\n            The joint zero position.\n        \"\"\"\n        return self._joint_zero_position\n\n    @property\n    def joint_position_offset(self) -&gt; float:\n        \"\"\"\n        Get the joint position offset.\n\n        Returns:\n            The joint position offset.\n        \"\"\"\n        return self._joint_position_offset\n\n    @property\n    def joint_direction(self) -&gt; int:\n        \"\"\"\n        Get the joint direction.\n\n        Returns:\n            The joint direction.\n        \"\"\"\n        return self._joint_direction\n\n    @property\n    def is_open(self) -&gt; bool:\n        \"\"\"\n        Check if the actuator is open.\n\n        Returns:\n            True if the actuator is open, False otherwise.\n        \"\"\"\n        return self._is_open\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the actuator is streaming.\n\n        Returns:\n            True if the actuator is streaming, False otherwise.\n        \"\"\"\n        return self._is_streaming\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.MOTOR_CONSTANTS","title":"<code>MOTOR_CONSTANTS: MOTOR_CONSTANTS</code>  <code>property</code>","text":"<p>Get the motor constants.</p> <p>Returns:</p> Type Description <code>MOTOR_CONSTANTS</code> <p>The motor constants.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.case_temperature","title":"<code>case_temperature: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the case temperature.</p> <p>Returns:</p> Type Description <code>float</code> <p>The case temperature.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.frequency","title":"<code>frequency: int</code>  <code>property</code>","text":"<p>Get the control frequency.</p> <p>Returns:</p> Type Description <code>int</code> <p>The control frequency in Hz.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.gear_ratio","title":"<code>gear_ratio: float</code>  <code>property</code>","text":"<p>Get the gear ratio.</p> <p>Returns:</p> Type Description <code>float</code> <p>The gear ratio.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.is_homed","title":"<code>is_homed: bool</code>  <code>property</code>","text":"<p>Check if the actuator is homed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the actuator is homed, False otherwise.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.is_offline","title":"<code>is_offline: bool</code>  <code>property</code>","text":"<p>Check if the actuator is offline.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the actuator is offline, False otherwise.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.is_open","title":"<code>is_open: bool</code>  <code>property</code>","text":"<p>Check if the actuator is open.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the actuator is open, False otherwise.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.is_streaming","title":"<code>is_streaming: bool</code>  <code>property</code>","text":"<p>Check if the actuator is streaming.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the actuator is streaming, False otherwise.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.joint_direction","title":"<code>joint_direction: int</code>  <code>property</code>","text":"<p>Get the joint direction.</p> <p>Returns:</p> Type Description <code>int</code> <p>The joint direction.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.joint_position_offset","title":"<code>joint_position_offset: float</code>  <code>property</code>","text":"<p>Get the joint position offset.</p> <p>Returns:</p> Type Description <code>float</code> <p>The joint position offset.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.joint_zero_position","title":"<code>joint_zero_position: float</code>  <code>property</code>","text":"<p>Get the joint zero position.</p> <p>Returns:</p> Type Description <code>float</code> <p>The joint zero position.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.max_case_temperature","title":"<code>max_case_temperature: float</code>  <code>property</code>","text":"<p>Get the maximum case temperature.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum case temperature.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.max_winding_temperature","title":"<code>max_winding_temperature: float</code>  <code>property</code>","text":"<p>Get the maximum winding temperature.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum winding temperature.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.mode","title":"<code>mode: CONTROL_MODES</code>  <code>property</code>","text":"<p>Get the current control mode.</p> <p>Returns:</p> Type Description <code>CONTROL_MODES</code> <p>The current control mode.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_current","title":"<code>motor_current: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor current.</p> <p>Returns:</p> Type Description <code>float</code> <p>The motor current.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_position","title":"<code>motor_position: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor position.</p> <p>Returns:</p> Type Description <code>float</code> <p>The motor position.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_position_offset","title":"<code>motor_position_offset: float</code>  <code>property</code>","text":"<p>Get the motor position offset.</p> <p>Returns:</p> Type Description <code>float</code> <p>The motor position offset.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_torque","title":"<code>motor_torque: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor torque.</p> <p>Returns:</p> Type Description <code>float</code> <p>The motor torque.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_velocity","title":"<code>motor_velocity: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor velocity.</p> <p>Returns:</p> Type Description <code>float</code> <p>The motor velocity.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_voltage","title":"<code>motor_voltage: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor voltage.</p> <p>Returns:</p> Type Description <code>float</code> <p>The motor voltage.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_zero_position","title":"<code>motor_zero_position: float</code>  <code>property</code>","text":"<p>Get the motor zero position.</p> <p>Returns:</p> Type Description <code>float</code> <p>The motor zero position.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.output_position","title":"<code>output_position: float</code>  <code>property</code>","text":"<p>Get the output position.</p> <p>Returns:</p> Type Description <code>float</code> <p>The output position.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.output_velocity","title":"<code>output_velocity: float</code>  <code>property</code>","text":"<p>Get the output velocity.</p> <p>Returns:</p> Type Description <code>float</code> <p>The output velocity.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.tag","title":"<code>tag: str</code>  <code>property</code>","text":"<p>Get the actuator tag.</p> <p>Returns:</p> Type Description <code>str</code> <p>The actuator tag.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.winding_temperature","title":"<code>winding_temperature: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the winding temperature.</p> <p>Returns:</p> Type Description <code>float</code> <p>The winding temperature.</p>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> <p>Returns:</p> Type Description <code>ActuatorBase</code> <p>The actuator instance.</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def __enter__(self) -&gt; \"ActuatorBase\":\n    \"\"\"\n    Context manager entry.\n\n    Returns:\n        The actuator instance.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.__exit__","title":"<code>__exit__(exc_type, exc_value, exc_traceback)</code>","text":"<p>Context manager exit.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>The type of the exception, if any.</p> required <code>exc_value</code> <code>Any</code> <p>The value of the exception, if any.</p> required <code>exc_traceback</code> <code>Any</code> <p>The traceback of the exception, if any.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_value: Any, exc_traceback: Any) -&gt; None:\n    \"\"\"\n    Context manager exit.\n\n    Args:\n        exc_type: The type of the exception, if any.\n        exc_value: The value of the exception, if any.\n        exc_traceback: The traceback of the exception, if any.\n    \"\"\"\n    self.stop()\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.__init__","title":"<code>__init__(tag, gear_ratio, motor_constants, frequency=1000, offline=False, *args, **kwargs)</code>","text":"<p>Initialize the actuator.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>A unique identifier for the actuator.</p> required <code>gear_ratio</code> <code>float</code> <p>The gear ratio of the actuator.</p> required <code>motor_constants</code> <code>MOTOR_CONSTANTS</code> <p>The motor constants for the actuator.</p> required <code>frequency</code> <code>int</code> <p>The control frequency in Hz. Defaults to 1000.</p> <code>1000</code> <code>offline</code> <code>bool</code> <p>Whether the actuator is in offline mode. Defaults to False.</p> <code>False</code> <code>*args</code> <code>Any</code> <p>Additional positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def __init__(\n    self,\n    tag: str,\n    gear_ratio: float,\n    motor_constants: MOTOR_CONSTANTS,\n    frequency: int = 1000,\n    offline: bool = False,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the actuator.\n\n    Args:\n        tag: A unique identifier for the actuator.\n        gear_ratio: The gear ratio of the actuator.\n        motor_constants: The motor constants for the actuator.\n        frequency: The control frequency in Hz. Defaults to 1000.\n        offline: Whether the actuator is in offline mode. Defaults to False.\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self._tag = tag\n    self._gear_ratio = gear_ratio\n    self._motor_constants = motor_constants\n    self._frequency = frequency\n    self._offline = offline\n    self._mode = CONTROL_MODES.IDLE\n    self._is_homed = False\n    self._is_open = False\n    self._is_streaming = False\n    self._motor_zero_position = 0.0\n    self._motor_position_offset = 0.0\n    self._joint_zero_position = 0.0\n    self._joint_position_offset = 0.0\n    self._joint_direction = 1\n    self._original_methods: dict[str, Callable] = {}\n    self._mutated_methods: dict[str, Callable] = {}\n\n    self._set_original_methods()\n    self._set_mutated_methods()\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.home","title":"<code>home()</code>  <code>abstractmethod</code>","text":"<p>Home the actuator.</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef home(self) -&gt; None:\n    \"\"\"\n    Home the actuator.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_control_mode","title":"<code>set_control_mode(mode)</code>","text":"<p>Set the control mode of the actuator.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CONTROL_MODES</code> <p>The control mode to set.</p> required <p>Raises:</p> Type Description <code>ControlModeException</code> <p>If the control mode is not supported.</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_control_mode(self, mode: CONTROL_MODES) -&gt; None:\n    \"\"\"\n    Set the control mode of the actuator.\n\n    Args:\n        mode: The control mode to set.\n\n    Raises:\n        ControlModeException: If the control mode is not supported.\n    \"\"\"\n    if mode == self._mode:\n        return\n\n    # Exit current mode\n    current_config = self._get_control_mode_config(self._mode)\n    if current_config and current_config.exit_callback:\n        current_config.exit_callback(self)\n\n    # Enter new mode\n    new_config = self._get_control_mode_config(mode)\n    if new_config and new_config.entry_callback:\n        new_config.entry_callback(self)\n\n    self._mode = mode\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_current_gains","title":"<code>set_current_gains(kp, ki, kd, ff)</code>  <code>abstractmethod</code>","text":"<p>Set the current control gains.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain.</p> required <code>ki</code> <code>float</code> <p>The integral gain.</p> required <code>kd</code> <code>float</code> <p>The derivative gain.</p> required <code>ff</code> <code>float</code> <p>The feedforward gain.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n    \"\"\"\n    Set the current control gains.\n\n    Args:\n        kp: The proportional gain.\n        ki: The integral gain.\n        kd: The derivative gain.\n        ff: The feedforward gain.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_impedance_gains","title":"<code>set_impedance_gains(kp, ki, kd, k, b, ff)</code>  <code>abstractmethod</code>","text":"<p>Set the impedance control gains.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain.</p> required <code>ki</code> <code>float</code> <p>The integral gain.</p> required <code>kd</code> <code>float</code> <p>The derivative gain.</p> required <code>k</code> <code>float</code> <p>The stiffness gain.</p> required <code>b</code> <code>float</code> <p>The damping gain.</p> required <code>ff</code> <code>float</code> <p>The feedforward gain.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_impedance_gains(self, kp: float, ki: float, kd: float, k: float, b: float, ff: float) -&gt; None:\n    \"\"\"\n    Set the impedance control gains.\n\n    Args:\n        kp: The proportional gain.\n        ki: The integral gain.\n        kd: The derivative gain.\n        k: The stiffness gain.\n        b: The damping gain.\n        ff: The feedforward gain.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_joint_direction","title":"<code>set_joint_direction(value)</code>","text":"<p>Set the joint direction.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The direction to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_joint_direction(self, value: int) -&gt; None:\n    \"\"\"\n    Set the joint direction.\n\n    Args:\n        value: The direction to set.\n    \"\"\"\n    if value not in [-1, 1]:\n        raise ValueError(\"Joint direction must be either 1 or -1\")\n    self._joint_direction = value\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_joint_position_offset","title":"<code>set_joint_position_offset(value)</code>","text":"<p>Set the joint position offset.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position offset to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_joint_position_offset(self, value: float) -&gt; None:\n    \"\"\"\n    Set the joint position offset.\n\n    Args:\n        value: The position offset to set.\n    \"\"\"\n    self._joint_position_offset = value\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_joint_torque","title":"<code>set_joint_torque(value)</code>  <code>abstractmethod</code>","text":"<p>Set the joint torque.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The torque to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_joint_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the joint torque.\n\n    Args:\n        value: The torque to set.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_joint_zero_position","title":"<code>set_joint_zero_position(value)</code>","text":"<p>Set the joint zero position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The zero position to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_joint_zero_position(self, value: float) -&gt; None:\n    \"\"\"\n    Set the joint zero position.\n\n    Args:\n        value: The zero position to set.\n    \"\"\"\n    self._joint_zero_position = value\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_current","title":"<code>set_motor_current(value)</code>  <code>abstractmethod</code>","text":"<p>Set the motor current.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The current to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_motor_current(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor current.\n\n    Args:\n        value: The current to set.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_position","title":"<code>set_motor_position(value)</code>  <code>abstractmethod</code>","text":"<p>Set the motor position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor position.\n\n    Args:\n        value: The position to set.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_position_offset","title":"<code>set_motor_position_offset(value)</code>","text":"<p>Set the motor position offset.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position offset to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_motor_position_offset(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor position offset.\n\n    Args:\n        value: The position offset to set.\n    \"\"\"\n    self._motor_position_offset = value\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_torque","title":"<code>set_motor_torque(value)</code>  <code>abstractmethod</code>","text":"<p>Set the motor torque.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The torque to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor torque.\n\n    Args:\n        value: The torque to set.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>  <code>abstractmethod</code>","text":"<p>Set the motor voltage.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor voltage.\n\n    Args:\n        value: The voltage to set.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_zero_position","title":"<code>set_motor_zero_position(value)</code>","text":"<p>Set the motor zero position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The zero position to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_motor_zero_position(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor zero position.\n\n    Args:\n        value: The zero position to set.\n    \"\"\"\n    self._motor_zero_position = value\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_output_position","title":"<code>set_output_position(value)</code>","text":"<p>Set the output position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_output_position(self, value: float) -&gt; None:\n    \"\"\"\n    Set the output position.\n\n    Args:\n        value: The position to set.\n    \"\"\"\n    motor_value = value * self._gear_ratio\n    self.set_motor_position(motor_value)\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_position_gains","title":"<code>set_position_gains(kp, ki, kd, ff)</code>  <code>abstractmethod</code>","text":"<p>Set the position control gains.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain.</p> required <code>ki</code> <code>float</code> <p>The integral gain.</p> required <code>kd</code> <code>float</code> <p>The derivative gain.</p> required <code>ff</code> <code>float</code> <p>The feedforward gain.</p> required Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n    \"\"\"\n    Set the position control gains.\n\n    Args:\n        kp: The proportional gain.\n        ki: The integral gain.\n        kd: The derivative gain.\n        ff: The feedforward gain.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start the actuator.</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"\n    Start the actuator.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop the actuator.</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop the actuator.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.update","title":"<code>update()</code>  <code>abstractmethod</code>","text":"<p>Update the actuator state.</p> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"\n    Update the actuator state.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.CONTROL_MODES","title":"<code>CONTROL_MODES</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum to define various control modes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CONTROL_MODES.POSITION\n&lt;CONTROL_MODES.POSITION: 0&gt;\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>class CONTROL_MODES(Enum):\n    \"\"\"\n    Enum to define various control modes.\n\n    Examples:\n        &gt;&gt;&gt; CONTROL_MODES.POSITION\n        &lt;CONTROL_MODES.POSITION: 0&gt;\n    \"\"\"\n\n    IDLE = -1\n    POSITION = 0\n    VOLTAGE = 1\n    CURRENT = 2\n    IMPEDANCE = 3\n    VELOCITY = 4\n    TORQUE = 5\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.CONTROL_MODE_CONFIGS","title":"<code>CONTROL_MODE_CONFIGS</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Named tuple containing control mode configurations.</p> <p>Attributes:</p> Name Type Description <code>IDLE</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for IDLE mode.</p> <code>POSITION</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for POSITION mode.</p> <code>CURRENT</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for CURRENT mode.</p> <code>VOLTAGE</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for VOLTAGE mode.</p> <code>IMPEDANCE</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for IMPEDANCE mode.</p> <code>VELOCITY</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for VELOCITY mode.</p> <code>TORQUE</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for TORQUE mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; idle_config = ControlModeConfig(\n...     entry_callback=lambda a: print(\"Idle entered\"),\n...     exit_callback=lambda a: print(\"Idle exited\")\n...\n&gt;&gt;&gt; mode_configs = CONTROL_MODE_CONFIGS(IDLE=idle_config)\n&gt;&gt;&gt; mode_configs.IDLE.entry_callback(None)\nIdle entered\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>class CONTROL_MODE_CONFIGS(NamedTuple):\n    \"\"\"\n    Named tuple containing control mode configurations.\n\n    Attributes:\n        IDLE: Configuration for IDLE mode.\n        POSITION: Configuration for POSITION mode.\n        CURRENT: Configuration for CURRENT mode.\n        VOLTAGE: Configuration for VOLTAGE mode.\n        IMPEDANCE: Configuration for IMPEDANCE mode.\n        VELOCITY: Configuration for VELOCITY mode.\n        TORQUE: Configuration for TORQUE mode.\n\n    Examples:\n        &gt;&gt;&gt; idle_config = ControlModeConfig(\n        ...     entry_callback=lambda a: print(\"Idle entered\"),\n        ...     exit_callback=lambda a: print(\"Idle exited\")\n        ...\n        &gt;&gt;&gt; mode_configs = CONTROL_MODE_CONFIGS(IDLE=idle_config)\n        &gt;&gt;&gt; mode_configs.IDLE.entry_callback(None)\n        Idle entered\n    \"\"\"\n\n    IDLE: Optional[ControlModeConfig] = None\n    POSITION: Optional[ControlModeConfig] = None\n    CURRENT: Optional[ControlModeConfig] = None\n    VOLTAGE: Optional[ControlModeConfig] = None\n    IMPEDANCE: Optional[ControlModeConfig] = None\n    VELOCITY: Optional[ControlModeConfig] = None\n    TORQUE: Optional[ControlModeConfig] = None\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ControlGains","title":"<code>ControlGains</code>  <code>dataclass</code>","text":"<p>Class to define the control gains.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gains = ControlGains(kp=1.0, ki=0.1, kd=0.01, k=0.5, b=0.05, ff=0.0)\n&gt;&gt;&gt; gains.kp\n1.0\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@dataclass\nclass ControlGains:\n    \"\"\"\n    Class to define the control gains.\n\n    Examples:\n        &gt;&gt;&gt; gains = ControlGains(kp=1.0, ki=0.1, kd=0.01, k=0.5, b=0.05, ff=0.0)\n        &gt;&gt;&gt; gains.kp\n        1.0\n    \"\"\"\n\n    kp: float = 0\n    ki: float = 0\n    kd: float = 0\n    k: float = 0\n    b: float = 0\n    ff: float = 0\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.ControlModeConfig","title":"<code>ControlModeConfig</code>  <code>dataclass</code>","text":"<p>Configuration for a control mode.</p> <p>Attributes:</p> Name Type Description <code>entry_callback</code> <code>Callable[[Any], None]</code> <p>Callback to execute when entering this mode.</p> <code>exit_callback</code> <code>Callable[[Any], None]</code> <p>Callback to execute when exiting this mode.</p> <code>has_gains</code> <code>bool</code> <p>Indicates if the control mode utilizes control gains.</p> <code>max_gains</code> <code>Union[ControlGains, None]</code> <p>The maximum allowable control gains (if applicable).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def enter(actuator):\n...     print(\"Entering mode\")\n&gt;&gt;&gt; def exit(actuator):\n...     print(\"Exiting mode\")\n&gt;&gt;&gt; config = ControlModeConfig(\n...     entry_callback=enter,\n...     exit_callback=exit,\n...     has_gains=True,\n...     max_gains=ControlGains(1.0, 0.1, 0.01, 0.5, 0.05, 0.0)\n... )\n&gt;&gt;&gt; config.has_gains\nTrue\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@dataclass\nclass ControlModeConfig:\n    \"\"\"\n    Configuration for a control mode.\n\n    Attributes:\n        entry_callback: Callback to execute when entering this mode.\n        exit_callback: Callback to execute when exiting this mode.\n        has_gains: Indicates if the control mode utilizes control gains.\n        max_gains: The maximum allowable control gains (if applicable).\n\n    Examples:\n        &gt;&gt;&gt; def enter(actuator):\n        ...     print(\"Entering mode\")\n        &gt;&gt;&gt; def exit(actuator):\n        ...     print(\"Exiting mode\")\n        &gt;&gt;&gt; config = ControlModeConfig(\n        ...     entry_callback=enter,\n        ...     exit_callback=exit,\n        ...     has_gains=True,\n        ...     max_gains=ControlGains(1.0, 0.1, 0.01, 0.5, 0.05, 0.0)\n        ... )\n        &gt;&gt;&gt; config.has_gains\n        True\n    \"\"\"\n\n    entry_callback: Callable[[Any], None]\n    exit_callback: Callable[[Any], None]\n    has_gains: bool = False\n    max_gains: Union[ControlGains, None] = None\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.MOTOR_CONSTANTS","title":"<code>MOTOR_CONSTANTS</code>  <code>dataclass</code>","text":"<p>Class to define the motor constants.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; constants = MOTOR_CONSTANTS(\n...     MOTOR_COUNT_PER_REV=2048,\n...     NM_PER_AMP=0.02,\n...     NM_PER_RAD_TO_K=0.001,\n...     NM_S_PER_RAD_TO_B=0.0001,\n...     MAX_CASE_TEMPERATURE=80.0,\n...     MAX_WINDING_TEMPERATURE=120.0\n... )\n&gt;&gt;&gt; print(constants.MOTOR_COUNT_PER_REV)\n2048\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@dataclass\nclass MOTOR_CONSTANTS:\n    \"\"\"\n    Class to define the motor constants.\n\n    Examples:\n        &gt;&gt;&gt; constants = MOTOR_CONSTANTS(\n        ...     MOTOR_COUNT_PER_REV=2048,\n        ...     NM_PER_AMP=0.02,\n        ...     NM_PER_RAD_TO_K=0.001,\n        ...     NM_S_PER_RAD_TO_B=0.0001,\n        ...     MAX_CASE_TEMPERATURE=80.0,\n        ...     MAX_WINDING_TEMPERATURE=120.0\n        ... )\n        &gt;&gt;&gt; print(constants.MOTOR_COUNT_PER_REV)\n        2048\n    \"\"\"\n\n    MOTOR_COUNT_PER_REV: float\n    NM_PER_AMP: float\n    NM_PER_RAD_TO_K: float\n    NM_S_PER_RAD_TO_B: float\n    MAX_CASE_TEMPERATURE: float\n    MAX_WINDING_TEMPERATURE: float\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        Function to validate the motor constants.\n\n        Examples:\n            &gt;&gt;&gt; # This will raise a ValueError because a negative value is invalid.\n            &gt;&gt;&gt; MOTOR_CONSTANTS(\n            ...     MOTOR_COUNT_PER_REV=-2048,\n            ...     NM_PER_AMP=0.02,\n            ...     NM_PER_RAD_TO_K=0.001,\n            ...     NM_S_PER_RAD_TO_B=0.0001,\n            ...     MAX_CASE_TEMPERATURE=80.0,\n            ...     MAX_WINDING_TEMPERATURE=120.0\n            ... )\n        \"\"\"\n        if any(x &lt;= 0 for x in self.__dict__.values()):\n            raise ValueError(\"All values in MOTOR_CONSTANTS must be non-zero and positive.\")\n\n    @property\n    def RAD_PER_COUNT(self) -&gt; float:\n        \"\"\"\n        Calculate the radians per count.\n\n        Returns:\n            Radians per count.\n\n        Examples:\n            &gt;&gt;&gt; constants = MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n            &gt;&gt;&gt; constants.RAD_PER_COUNT\n            0.0030679615757712823\n        \"\"\"\n        return 2 * np.pi / self.MOTOR_COUNT_PER_REV\n\n    @property\n    def NM_PER_MILLIAMP(self) -&gt; float:\n        \"\"\"\n        Convert NM per amp to NM per milliamp.\n\n        Returns:\n            NM per milliamp.\n\n        Examples:\n            &gt;&gt;&gt; constants = MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n            &gt;&gt;&gt; constants.NM_PER_MILLIAMP\n            2e-05\n        \"\"\"\n        return self.NM_PER_AMP / 1000\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.MOTOR_CONSTANTS.NM_PER_MILLIAMP","title":"<code>NM_PER_MILLIAMP: float</code>  <code>property</code>","text":"<p>Convert NM per amp to NM per milliamp.</p> <p>Returns:</p> Type Description <code>float</code> <p>NM per milliamp.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; constants = MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n&gt;&gt;&gt; constants.NM_PER_MILLIAMP\n2e-05\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.MOTOR_CONSTANTS.RAD_PER_COUNT","title":"<code>RAD_PER_COUNT: float</code>  <code>property</code>","text":"<p>Calculate the radians per count.</p> <p>Returns:</p> Type Description <code>float</code> <p>Radians per count.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; constants = MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n&gt;&gt;&gt; constants.RAD_PER_COUNT\n0.0030679615757712823\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.MOTOR_CONSTANTS.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Function to validate the motor constants.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # This will raise a ValueError because a negative value is invalid.\n&gt;&gt;&gt; MOTOR_CONSTANTS(\n...     MOTOR_COUNT_PER_REV=-2048,\n...     NM_PER_AMP=0.02,\n...     NM_PER_RAD_TO_K=0.001,\n...     NM_S_PER_RAD_TO_B=0.0001,\n...     MAX_CASE_TEMPERATURE=80.0,\n...     MAX_WINDING_TEMPERATURE=120.0\n... )\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"\n    Function to validate the motor constants.\n\n    Examples:\n        &gt;&gt;&gt; # This will raise a ValueError because a negative value is invalid.\n        &gt;&gt;&gt; MOTOR_CONSTANTS(\n        ...     MOTOR_COUNT_PER_REV=-2048,\n        ...     NM_PER_AMP=0.02,\n        ...     NM_PER_RAD_TO_K=0.001,\n        ...     NM_S_PER_RAD_TO_B=0.0001,\n        ...     MAX_CASE_TEMPERATURE=80.0,\n        ...     MAX_WINDING_TEMPERATURE=120.0\n        ... )\n    \"\"\"\n    if any(x &lt;= 0 for x in self.__dict__.values()):\n        raise ValueError(\"All values in MOTOR_CONSTANTS must be non-zero and positive.\")\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.MethodWithRequiredModes","title":"<code>MethodWithRequiredModes</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for methods that define required control modes.</p> <p>Attributes:</p> Name Type Description <code>_required_modes</code> <code>set[CONTROL_MODES]</code> <p>A set of control modes in which the method is permitted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Dummy:\n...     _required_modes = {CONTROL_MODES.IDLE}\n&gt;&gt;&gt; isinstance(Dummy(), MethodWithRequiredModes)\nTrue\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@runtime_checkable\nclass MethodWithRequiredModes(Protocol):\n    \"\"\"\n    Protocol for methods that define required control modes.\n\n    Attributes:\n        _required_modes: A set of control modes in which the method is permitted.\n\n    Examples:\n        &gt;&gt;&gt; class Dummy:\n        ...     _required_modes = {CONTROL_MODES.IDLE}\n        &gt;&gt;&gt; isinstance(Dummy(), MethodWithRequiredModes)\n        True\n    \"\"\"\n\n    _required_modes: set[CONTROL_MODES]\n</code></pre>"},{"location":"modules/actuators/actuators/#opensourceleg.actuators.base.requires","title":"<code>requires(*modes)</code>","text":"<p>Decorator to specify required control modes for a method.</p> <p>Parameters:</p> Name Type Description Default <code>*modes</code> <code>CONTROL_MODES</code> <p>One or more control modes required for the method.</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable[[T], T]</code> <p>The decorated method.</p> <p>Raises:</p> Type Description <code>ControlModeException</code> <p>If the method is called in an invalid control mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyActuator(ActuatorBase):\n...     @requires(CONTROL_MODES.POSITION)\n...     def some_method(self, value):\n...         print(f\"Value: {value}\")\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def requires(*modes: CONTROL_MODES) -&gt; Callable[[T], T]:\n    \"\"\"\n    Decorator to specify required control modes for a method.\n\n    Args:\n        *modes: One or more control modes required for the method.\n\n    Returns:\n        The decorated method.\n\n    Raises:\n        ControlModeException: If the method is called in an invalid control mode.\n\n    Examples:\n        &gt;&gt;&gt; class MyActuator(ActuatorBase):\n        ...     @requires(CONTROL_MODES.POSITION)\n        ...     def some_method(self, value):\n        ...         print(f\"Value: {value}\")\n    \"\"\"\n\n    def decorator(func: T) -&gt; T:\n        \"\"\"\n        Attach required control modes to the decorated function.\n\n        Args:\n            func (T): The function to be decorated.\n\n        Returns:\n            T: The same function with an updated `_required_modes` attribute.\n        \"\"\"\n        if not all(isinstance(mode, CONTROL_MODES) for mode in modes):\n            raise TypeError(\"All arguments to 'requires' must be of type CONTROL_MODES\")\n\n        if not hasattr(func, \"_required_modes\"):\n            func._required_modes = set(modes)  # type: ignore[attr-defined]\n        else:\n            func._required_modes.update(modes)\n\n        return func\n\n    return decorator\n</code></pre>"},{"location":"modules/actuators/dephy/","title":"Dephy","text":""},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator","title":"<code>DephyActuator</code>","text":"<p>               Bases: <code>Device</code>, <code>ActuatorBase</code></p> <p>Interface to a Dephy actuator device.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0', gear_ratio=2.0)\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_voltage(1500)\n&gt;&gt;&gt; print(f\"Joint position: {actuator.joint_position:.2f} rad\")\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>class DephyActuator(Device, ActuatorBase):  # type: ignore[no-any-unimported]\n    \"\"\"\n    Interface to a Dephy actuator device.\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0', gear_ratio=2.0)\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_voltage(1500)\n        &gt;&gt;&gt; print(f\"Joint position: {actuator.joint_position:.2f} rad\")\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: str = \"DephyActuator\",\n        firmware_version: str = \"7.2.0\",\n        port: str = \"/dev/ttyACM0\",\n        gear_ratio: float = 1.0,\n        baud_rate: int = 230400,\n        frequency: int = 500,\n        debug_level: int = 4,\n        dephy_log: bool = False,\n        offline: bool = False,\n        stop_motor_on_disconnect: bool = False,\n    ) -&gt; None:\n        ActuatorBase.__init__(\n            self,\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=DEPHY_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n\n        self._debug_level: int = debug_level if dephy_log else 6\n        self._dephy_log: bool = dephy_log\n\n        if self.is_offline:\n            self.port = port\n            self._is_streaming: bool = False\n            self._is_open: bool = False\n        else:\n            Device.__init__(\n                self,\n                firmwareVersion=firmware_version,\n                port=port,\n                baudRate=baud_rate,\n                stopMotorOnDisconnect=stop_motor_on_disconnect,\n            )\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            temp_limit_windings=self.max_winding_temperature,\n            soft_border_C_windings=10,\n            temp_limit_case=self.max_case_temperature,\n            soft_border_C_case=10,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._mode = CONTROL_MODES.IDLE\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.tag}[DephyLegacyActuator]\"\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return DEPHY_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    def start(self) -&gt; None:\n        \"\"\"\n        Starts the actuator by opening the port, starting data streaming,\n        reading initial data, and setting the control mode to VOLTAGE.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n        \"\"\"\n        try:\n            self.open()\n            self._is_open = True\n        except OSError:\n            print(\"\\n\")\n            LOGGER.error(\n                msg=f\"[{self.__repr__()}] Need admin previleges to open the port '{self.port}'. \\n\\n \\\n                    Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n            )\n            os._exit(status=1)\n\n        self.start_streaming(self._frequency)\n        time.sleep(0.2)\n        self._is_streaming = True\n\n        self._data = self.read()\n        self.set_control_mode(CONTROL_MODES.VOLTAGE)\n\n    @check_actuator_stream\n    @check_actuator_open\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stops the actuator by stopping the motor, switching to IDLE mode,\n        stopping data streaming, and closing the connection.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; # ... perform control tasks ...\n            &gt;&gt;&gt; actuator.stop()\n        \"\"\"\n        self.stop_motor()\n        self.set_control_mode(mode=CONTROL_MODES.IDLE)\n        self._is_streaming = False\n        self._is_open = False\n        self.close()\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Updates the actuator's data by reading new values and updating the thermal model.\n        It raises exceptions if thermal limits are exceeded.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator()\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.update()\n            &gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n        \"\"\"\n        self._data = self.read()\n\n        self._thermal_model.T_c = self.case_temperature\n        self._thermal_scale = self._thermal_model.update_and_get_scale(\n            dt=1 / self.frequency,\n            motor_current=self.motor_current,\n        )\n        if self.case_temperature &gt;= self.max_case_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Case thermal limit {self.max_case_temperature} reached. \\\n                    Stopping motor.\"\n            )\n            # self.stop()\n            raise ThermalLimitException()\n\n        if self.winding_temperature &gt;= self.max_winding_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Winding thermal limit {self.max_winding_temperature} reached. \\\n                    Stopping motor.\"\n            )\n            raise ThermalLimitException()\n        # Check for thermal fault, bit 2 of the execute status byte\n        if self._data[\"status_ex\"] &amp; 0b00000010 == 0b00000010:\n            self.stop()\n            raise RuntimeError(\"Actpack Thermal Limit Tripped\")\n\n    def home(\n        self,\n        homing_voltage: int = 2000,\n        homing_frequency: Optional[int] = None,\n        homing_direction: int = -1,\n        joint_direction: int = -1,\n        joint_position_offset: float = 0.0,\n        motor_position_offset: float = 0.0,\n        current_threshold: int = 5000,\n        velocity_threshold: float = 0.001,\n    ) -&gt; None:\n        \"\"\"\n\n        This method homes the actuator and the corresponding joint by moving it to the zero position.\n        The zero position is defined as the position where the joint is fully extended. This method will\n        also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts\n        to joint position in radians. This is useful for more accurate joint position estimation.\n        Args:\n            homing_voltage: Voltage in mV to use for homing. Default is 2000 mV.\n            homing_frequency: Frequency in Hz to use for homing. Default is the actuator's frequency.\n            homing_direction: Direction to move the actuator during homing. Default is -1.\n            joint_direction: Direction to move the joint during homing. Default is -1.\n            joint_position_offset: Offset in radians to add to the joint position. Default is 0.0.\n            motor_position_offset: Offset in radians to add to the motor position. Default is 0.0.\n            current_threshold: Current threshold in mA to stop homing the joint or actuator.\n                This is used to detect if the actuator or joint has hit a hard stop. Default is 5000 mA.\n            velocity_threshold: Velocity threshold in rad/s to stop homing the joint or actuator.\n                This is also used to detect if the actuator or joint has hit a hard stop. Default is 0.001 rad/s.\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.home(homing_voltage=2000, homing_direction=-1)\n\n        \"\"\"\n        is_homing = True\n        homing_frequency = homing_frequency if homing_frequency is not None else self.frequency\n\n        LOGGER.info(\n            f\"[{self.__repr__()}] Homing {self.tag} joint.\"\n            \"Please make sure the joint is free to move and press Enter to continue.\"\n        )\n        input()\n\n        self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n\n        self.set_motor_voltage(value=homing_direction * homing_voltage)  # mV, negative for counterclockwise\n\n        _motor_encoder_array = []\n        _joint_encoder_array = []\n\n        time.sleep(0.1)\n\n        try:\n            while is_homing:\n                self.update()\n                time.sleep(1 / homing_frequency)\n\n                _motor_encoder_array.append(self.motor_position)\n                _joint_encoder_array.append(self.joint_position)\n\n                if abs(self.output_velocity) &lt;= velocity_threshold or abs(self.motor_current) &gt;= current_threshold:\n                    self.set_motor_voltage(value=0)\n                    is_homing = False\n\n        except KeyboardInterrupt:\n            self.set_motor_voltage(value=0)\n            LOGGER.info(msg=f\"[{self.__repr__()}] Homing interrupted.\")\n            return\n        except Exception as e:\n            self.set_motor_voltage(value=0)\n            LOGGER.error(msg=f\"[{self.__repr__()}] Homing failed: {e}\")\n            return\n\n        self.set_motor_zero_position(value=self.motor_position)\n        self.set_joint_zero_position(value=self.joint_position)\n\n        time.sleep(0.1)\n        self.set_joint_direction(joint_direction)\n        self.set_motor_position_offset(motor_position_offset)\n        self.set_joint_position_offset(joint_position_offset)\n\n        self._is_homed = True\n        LOGGER.info(f\"[{self.__repr__()}] Homing complete.\")\n\n        if os.path.isfile(path=f\"./{self.tag}_encoder_map.npy\"):\n            coefficients = np.load(file=f\"./{self.tag}_encoder_map.npy\")\n            self.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=coefficients))\n        else:\n            LOGGER.debug(\n                msg=f\"[{self.__repr__()}] No encoder map found. Please call the make_encoder_map method \\\n                    to create one. The encoder map is used to estimate joint position more accurately.\"\n            )\n\n    def make_encoder_map(self, overwrite: bool = False) -&gt; None:\n        \"\"\"\n        This method makes a lookup table to calculate the position measured by the joint encoder.\n        This is necessary because the magnetic output encoders are nonlinear.\n        By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio\n        should be the same as the true joint position. Output from this function is a file containing a_i values\n        parameterizing the map.\n\n        Args:\n            overwrite (bool): Whether to overwrite the existing encoder map. Default is False.\n\n        Returns:\n            None\n\n        Eqn:\n            position = sum from i=0^5 (a_i*counts^i)\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.make_encoder_map(overwrite=True)\n\n        Author: Kevin Best\n                U-M Locolab | Neurobionics Lab\n                Gitub: tkevinbest, https://github.com/tkevinbest\n        \"\"\"\n\n        if not self.is_homed:\n            LOGGER.warning(msg=f\"[{self.__repr__()}] Please home the {self.tag} joint before making the encoder map.\")\n            return None\n\n        if os.path.exists(f\"./{self.tag}_encoder_map.npy\") and not overwrite:\n            LOGGER.info(msg=f\"[{self.__repr__()}] Encoder map exists. Skipping encoder map creation.\")\n            return None\n\n        self.set_control_mode(mode=CONTROL_MODES.CURRENT)\n        self.set_current_gains()\n        time.sleep(0.1)\n        self.set_current_gains()\n\n        self.set_joint_torque(value=0.0)\n        time.sleep(0.1)\n        self.set_joint_torque(value=0.0)\n\n        _joint_encoder_array = []\n        _output_position_array = []\n\n        LOGGER.info(\n            msg=f\"[{self.__repr__()}] Please manually move the {self.tag} joint numerous times through \\\n                its full range of motion for 10 seconds. \\n{input('Press any key when you are ready to start.')}\"\n        )\n\n        _start_time: float = time.time()\n\n        try:\n            while time.time() - _start_time &lt; 10:\n                LOGGER.info(\n                    msg=f\"[{self.__repr__()}] Mapping the {self.tag} \\\n                        joint encoder: {10 - time.time() + _start_time} seconds left.\"\n                )\n                self.update()\n                _joint_encoder_array.append(self.joint_encoder_counts)\n                _output_position_array.append(self.output_position)\n                time.sleep(1 / self.frequency)\n\n        except KeyboardInterrupt:\n            LOGGER.warning(msg=\"Encoder map interrupted.\")\n            return None\n\n        LOGGER.info(msg=f\"[{self.__repr__()}] You may now stop moving the {self.tag} joint.\")\n\n        _power = np.arange(4.0)\n        _a_mat = np.array(_joint_encoder_array).reshape(-1, 1) ** _power\n        _beta = np.linalg.lstsq(_a_mat, _output_position_array, rcond=None)\n        _coeffs = _beta[0]\n\n        self.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=_coeffs))\n\n        np.save(file=f\"./{self.tag}_encoder_map.npy\", arr=_coeffs)\n        LOGGER.info(msg=f\"[{self.__repr__()}] Encoder map saved to './{self.tag}_encoder_map.npy'.\")\n\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output.\n        Args:\n            value: The torque to set in Nm.\n        Returns:\n            None\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_torque(0.1)\n        \"\"\"\n        self.set_motor_current(\n            value / self.MOTOR_CONSTANTS.NM_PER_MILLIAMP,\n        )\n\n    def set_joint_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the joint torque of the joint.\n        This is the torque that is applied to the joint, not the motor.\n\n        Args:\n            value: torque in N_m\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_joint_torque(0.1)\n        \"\"\"\n        self.set_motor_torque(value=value / self.gear_ratio)\n\n    @deprecated_with_routing(alternative_func=set_joint_torque)\n    def set_output_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the output torque of the joint.\n        This is the torque that is applied to the joint, not the motor.\n\n        Args:\n            value: torque in N_m\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_output_torque(0.1)\n        \"\"\"\n        self.set_motor_torque(value=value / self.gear_ratio)\n\n    def set_motor_current(\n        self,\n        value: float,\n    ) -&gt; None:\n        \"\"\"\n        Sets the motor current in mA.\n\n        Args:\n            value: The current to set in mA.\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_current(1000)\n        \"\"\"\n        self.command_motor_current(value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_current)\n    def set_current(self, value: float) -&gt; None:\n        self.command_motor_current(value=int(value))\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor voltage in mV.\n\n        Args:\n            value: The voltage to set in mV.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_voltage(100)\n        \"\"\"\n        self.command_motor_voltage(value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_voltage)\n    def set_voltage(self, value: float) -&gt; None:\n        self.command_motor_voltage(value=int(value))\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor position in radians.\n        If in impedance mode, this sets the equilibrium angle in radians.\n\n        Args:\n            value: The position to set\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_position(0.1)\n        \"\"\"\n        # TODO: New Dephy API splits impedance equilibrium position and position control into separate methods\n        if self.mode == CONTROL_MODES.POSITION:\n            self.command_motor_position(\n                value=int(\n                    (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n                ),\n            )\n        elif self.mode == CONTROL_MODES.IMPEDANCE:\n            self.command_motor_impedance(\n                value=int(\n                    (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n                ),\n            )\n        else:\n            raise ControlModeException(tag=self._tag, attribute=\"set_motor_position\", mode=self._mode.name)\n\n    def set_position_gains(\n        self,\n        kp: float = DEFAULT_POSITION_GAINS.kp,\n        ki: float = DEFAULT_POSITION_GAINS.ki,\n        kd: float = DEFAULT_POSITION_GAINS.kd,\n        ff: float = DEFAULT_POSITION_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Dephy units.\n\n        Args:\n            kp: The proportional gain\n            ki: The integral gain\n            kd: The derivative gain\n            ff: The feedforward gain\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_position_gains(kp=30, ki=0, kd=0, ff=0)\n        \"\"\"\n        self.set_gains(\n            kp=int(kp),\n            ki=int(ki),\n            kd=int(kd),\n            k=0,\n            b=0,\n            ff=int(ff),\n        )\n\n    def set_current_gains(\n        self,\n        kp: float = DEFAULT_CURRENT_GAINS.kp,\n        ki: float = DEFAULT_CURRENT_GAINS.ki,\n        kd: float = DEFAULT_CURRENT_GAINS.kd,\n        ff: float = DEFAULT_CURRENT_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the current gains in arbitrary Dephy units.\n\n        Args:\n            kp: The proportional gain\n            ki: The integral gain\n            kd: The derivative gain\n            ff: The feedforward gain\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_current_gains(kp=40, ki=400, kd=0, ff=128)\n        \"\"\"\n        self.set_gains(\n            kp=int(kp),\n            ki=int(ki),\n            kd=int(kd),\n            k=0,\n            b=0,\n            ff=int(ff),\n        )\n\n    def set_output_impedance(\n        self,\n        kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n        ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n        kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n        k: float = 100.0,\n        b: float = 3.0,\n        ff: float = 128,\n    ) -&gt; None:\n        \"\"\"\n        Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s.\n        This sets the impedance at the output and automatically scales based on gear raitos.\n\n        Conversion:\n            K_motor = K_joint / (gear_ratio ** 2)\n            B_motor = B_joint / (gear_ratio ** 2)\n\n        Args:\n            kp: Proportional gain. Defaults to 40.\n            ki: Integral gain. Defaults to 400.\n            kd: Derivative gain. Defaults to 0.\n            k: Spring constant. Defaults to 100 Nm/rad.\n            b: Damping constant. Defaults to 3.0 Nm/rad/s.\n            ff: Feedforward gain. Defaults to 128.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_output_impedance(kp=40, ki=400, kd=0, k=100, b=3, ff=128)\n        \"\"\"\n        self.set_motor_impedance(\n            kp=kp,\n            ki=ki,\n            kd=kd,\n            k=k / (self.gear_ratio**2),\n            b=b / (self.gear_ratio**2),\n            ff=ff,\n        )\n\n    def set_impedance_gains(\n        self,\n        kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n        ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n        kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n        k: float = DEFAULT_IMPEDANCE_GAINS.k,\n        b: float = DEFAULT_IMPEDANCE_GAINS.b,\n        ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the impedance gains in arbitrary actpack units.\n        See Dephy's webpage for conversions or use other library methods that handle conversion for you.\n\n        Args:\n            kp: The proportional gain\n            ki: The integral gain\n            kd: The derivative gain\n            k: The spring constant\n            b: The damping constant\n            ff: The feedforward gain\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_impedance_gains(kp=40, ki=400, kd=0, k=200, b=400, ff=128)\n        \"\"\"\n        self.set_gains(\n            kp=int(kp),\n            ki=int(ki),\n            kd=int(kd),\n            k=int(k),\n            b=int(b),\n            ff=int(ff),\n        )\n\n    def set_motor_impedance(\n        self,\n        kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n        ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n        kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n        k: float = 0.08922,\n        b: float = 0.0038070,\n        ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.\n\n        Args:\n            kp: Proportional gain. Defaults to 40.\n            ki: Integral gain. Defaults to 400.\n            kd: Derivative gain. Defaults to 0.\n            k: Spring constant. Defaults to 0.08922 Nm/rad.\n            b: Damping constant. Defaults to 0.0038070 Nm/rad/s.\n            ff: Feedforward gain. Defaults to 128.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_impedance(kp=40, ki=400, kd=0, k=0.08922, b=0.0038070, ff=128)\n        \"\"\"\n        self.set_impedance_gains(\n            kp=kp,\n            ki=ki,\n            kd=kd,\n            k=int(k * self.MOTOR_CONSTANTS.NM_PER_RAD_TO_K),\n            b=int(b * self.MOTOR_CONSTANTS.NM_S_PER_RAD_TO_B),\n            ff=ff,\n        )\n\n    def set_encoder_map(self, encoder_map: np.polynomial.polynomial.Polynomial) -&gt; None:\n        \"\"\"\n        Sets the joint encoder map\n\n        Args:\n            encoder_map: The encoder map to set\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=[1, 2, 3, 4, 5]))\n        \"\"\"\n        self._encoder_map: np.polynomial.polynomial.Polynomial = encoder_map\n\n    @property\n    def encoder_map(self) -&gt; Optional[np.polynomial.polynomial.Polynomial]:\n        \"\"\"\n        Polynomial coefficients defining the joint encoder map from counts to radians.\n\n        Returns:\n            Optional[np.polynomial.polynomial.Polynomial]: The encoder map\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(actuator.encoder_map)\n        \"\"\"\n        if getattr(self, \"_encoder_map\", None) is not None:\n            return self._encoder_map\n        else:\n            LOGGER.warning(msg=\"Encoder map is not set. Please call the make_encoder_map method to create one.\")\n            return None\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"\n        Q-axis motor voltage in mV.\n\n        Returns:\n            float: Motor voltage in mV.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor voltage: {actuator.motor_voltage} mV\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"mot_volt\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        \"\"\"\n        Motor current in mA.\n\n        Returns:\n            float: Motor current in mA.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"mot_cur\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the motor output in Nm.\n\n        Returns:\n            float: Motor torque in Nm.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor torque: {actuator.motor_torque} Nm\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"mot_cur\"] * self.MOTOR_CONSTANTS.NM_PER_MILLIAMP)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_position(self) -&gt; float:\n        \"\"\"\n        Motor position in radians.\n\n        Returns:\n            float: Motor position in radians.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor position: {actuator.motor_position} rad\")\n        \"\"\"\n        if self._data is not None:\n            return (\n                float(self._data[\"mot_ang\"] * self.MOTOR_CONSTANTS.RAD_PER_COUNT)\n                - self.motor_zero_position\n                - self.motor_position_offset\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_encoder_counts(self) -&gt; int:\n        \"\"\"\n        Raw reading from motor encoder in counts.\n\n        Returns:\n            int: Motor encoder counts.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor encoder counts: {actuator.motor_encoder_counts}\")\n        \"\"\"\n        if self._data is not None:\n            return int(self._data[\"mot_ang\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def joint_encoder_counts(self) -&gt; int:\n        \"\"\"\n        Raw reading from joint encoder in counts.\n\n        Returns:\n            int: Joint encoder counts.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Joint encoder counts: {actuator.joint_encoder_counts}\")\n        \"\"\"\n        if self._data is not None:\n            return int(self._data[\"ank_ang\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        \"\"\"\n        Motor velocity in rad/s.\n\n        Returns:\n            float: Motor velocity in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor velocity: {actuator.motor_velocity} rad/s\")\n        \"\"\"\n\n        if self._data is not None:\n            return int(self._data[\"mot_vel\"]) * RAD_PER_DEG\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_acceleration(self) -&gt; float:\n        \"\"\"\n        Motor acceleration in rad/s^2.\n\n        Returns:\n            float: Motor acceleration in rad/s^2.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor acceleration: {actuator.motor_acceleration} rad/s^2\")\n        \"\"\"\n\n        if self._data is not None:\n            return float(self._data[\"mot_acc\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_voltage(self) -&gt; float:\n        \"\"\"\n        Battery voltage in mV.\n\n        Returns:\n            float: Battery voltage in mV.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Battery voltage: {actuator.battery_voltage} mV\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"batt_volt\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_current(self) -&gt; float:\n        \"\"\"\n        Battery current in mA.\n\n        Returns:\n            float: Battery current in mA.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Battery current: {actuator.battery_current} mA\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"batt_curr\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_position(self) -&gt; float:\n        \"\"\"\n        Joint position in radians.\n\n        Returns:\n            float: Joint position in radians.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Joint position: {actuator.joint_position} rad\")\n        \"\"\"\n        if self._data is not None:\n            return (\n                float(self._data[\"ank_ang\"] * self.MOTOR_CONSTANTS.RAD_PER_COUNT)\n                - self.joint_zero_position\n                - self.joint_position_offset\n            ) * self.joint_direction\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_velocity(self) -&gt; float:\n        \"\"\"\n        Joint velocity in rad/s.\n\n        Returns:\n            float: Joint velocity in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Joint velocity: {actuator.joint_velocity} rad/s\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"ank_vel\"] * RAD_PER_DEG) * self.joint_direction\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.\n\n        Returns:\n            float: Joint torque in Nm.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Joint torque: {actuator.joint_torque} Nm\")\n        \"\"\"\n        return self.motor_torque * self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        \"\"\"\n        Case temperature in degrees celsius. This is read during actuator update.\n\n        Returns:\n            float: Case temperature in degrees celsius.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Case temperature: {actuator.case_temperature} C\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"temperature\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n\n        Returns:\n            float: Winding temperature in degrees celsius.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Winding temperature: {actuator.winding_temperature} C\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.T_w)\n        else:\n            return 0.0\n\n    @property\n    def genvars(self) -&gt; np.ndarray:\n        \"\"\"Dephy's 'genvars' object.\"\"\"\n        if self._data is not None:\n            return np.array(\n                object=[\n                    self._data[\"genvar_0\"],\n                    self._data[\"genvar_1\"],\n                    self._data[\"genvar_2\"],\n                    self._data[\"genvar_3\"],\n                    self._data[\"genvar_4\"],\n                    self._data[\"genvar_5\"],\n                ]\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning zeros\"\n            )\n            return np.zeros(shape=6)\n\n    @property\n    def accelx(self) -&gt; float:\n        \"\"\"\n        Acceleration in x direction in m/s^2.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Acceleration in x direction in m/s^2.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Acceleration in x direction: {actuator.accelx} m/s^2\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accelx\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accely(self) -&gt; float:\n        \"\"\"\n        Acceleration in y direction in m/s^2.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Acceleration in y direction in m/s^2.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Acceleration in y direction: {actuator.accely} m/s^2\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accely\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accelz(self) -&gt; float:\n        \"\"\"\n        Acceleration in z direction in m/s^2.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Acceleration in z direction in m/s^2.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Acceleration in z direction: {actuator.accelz} m/s^2\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accelz\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyrox(self) -&gt; float:\n        \"\"\"\n        Angular velocity in x direction in rad/s.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Angular velocity in x direction in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Angular velocity in x direction: {actuator.gyrox} rad/s\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyrox\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroy(self) -&gt; float:\n        \"\"\"\n        Angular velocity in y direction in rad/s.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Angular velocity in y direction in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Angular velocity in y direction: {actuator.gyroy} rad/s\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyroy\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroz(self) -&gt; float:\n        \"\"\"\n        Angular velocity in z direction in rad/s.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Angular velocity in z direction in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Angular velocity in z direction: {actuator.gyroz} rad/s\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyroz\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def thermal_scaling_factor(self) -&gt; float:\n        \"\"\"\n        Scale factor to use in torque control, in [0,1].\n        If you scale the torque command by this factor, the motor temperature will never\n        exceed max allowable temperature. For a proof, see paper referenced in thermal model.\n\n        Returns:\n            float: Thermal scaling factor.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Thermal scaling factor: {actuator.thermal_scaling_factor}\")\n            &gt;&gt;&gt; actuator.update()\n            &gt;&gt;&gt; # This will update the thermal model and return the new scaling factor.\n            &gt;&gt;&gt; print(f\"Thermal scaling factor: {actuator.thermal_scaling_factor}\")\n        \"\"\"\n        return self._thermal_scale\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.accelx","title":"<code>accelx: float</code>  <code>property</code>","text":"<p>Acceleration in x direction in m/s^2. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in x direction in m/s^2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Acceleration in x direction: {actuator.accelx} m/s^2\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.accely","title":"<code>accely: float</code>  <code>property</code>","text":"<p>Acceleration in y direction in m/s^2. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in y direction in m/s^2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Acceleration in y direction: {actuator.accely} m/s^2\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.accelz","title":"<code>accelz: float</code>  <code>property</code>","text":"<p>Acceleration in z direction in m/s^2. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in z direction in m/s^2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Acceleration in z direction: {actuator.accelz} m/s^2\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.battery_current","title":"<code>battery_current: float</code>  <code>property</code>","text":"<p>Battery current in mA.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Battery current in mA.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Battery current: {actuator.battery_current} mA\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.battery_voltage","title":"<code>battery_voltage: float</code>  <code>property</code>","text":"<p>Battery voltage in mV.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Battery voltage in mV.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Battery voltage: {actuator.battery_voltage} mV\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.case_temperature","title":"<code>case_temperature: float</code>  <code>property</code>","text":"<p>Case temperature in degrees celsius. This is read during actuator update.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Case temperature in degrees celsius.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Case temperature: {actuator.case_temperature} C\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.encoder_map","title":"<code>encoder_map: Optional[np.polynomial.polynomial.Polynomial]</code>  <code>property</code>","text":"<p>Polynomial coefficients defining the joint encoder map from counts to radians.</p> <p>Returns:</p> Type Description <code>Optional[Polynomial]</code> <p>Optional[np.polynomial.polynomial.Polynomial]: The encoder map</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(actuator.encoder_map)\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.genvars","title":"<code>genvars: np.ndarray</code>  <code>property</code>","text":"<p>Dephy's 'genvars' object.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.gyrox","title":"<code>gyrox: float</code>  <code>property</code>","text":"<p>Angular velocity in x direction in rad/s. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in x direction in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Angular velocity in x direction: {actuator.gyrox} rad/s\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.gyroy","title":"<code>gyroy: float</code>  <code>property</code>","text":"<p>Angular velocity in y direction in rad/s. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in y direction in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Angular velocity in y direction: {actuator.gyroy} rad/s\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.gyroz","title":"<code>gyroz: float</code>  <code>property</code>","text":"<p>Angular velocity in z direction in rad/s. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in z direction in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Angular velocity in z direction: {actuator.gyroz} rad/s\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.joint_encoder_counts","title":"<code>joint_encoder_counts: int</code>  <code>property</code>","text":"<p>Raw reading from joint encoder in counts.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Joint encoder counts.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Joint encoder counts: {actuator.joint_encoder_counts}\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.joint_position","title":"<code>joint_position: float</code>  <code>property</code>","text":"<p>Joint position in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Joint position in radians.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Joint position: {actuator.joint_position} rad\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.joint_torque","title":"<code>joint_torque: float</code>  <code>property</code>","text":"<p>Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Joint torque in Nm.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Joint torque: {actuator.joint_torque} Nm\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.joint_velocity","title":"<code>joint_velocity: float</code>  <code>property</code>","text":"<p>Joint velocity in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Joint velocity in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Joint velocity: {actuator.joint_velocity} rad/s\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_acceleration","title":"<code>motor_acceleration: float</code>  <code>property</code>","text":"<p>Motor acceleration in rad/s^2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor acceleration in rad/s^2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor acceleration: {actuator.motor_acceleration} rad/s^2\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_current","title":"<code>motor_current: float</code>  <code>property</code>","text":"<p>Motor current in mA.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor current in mA.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_encoder_counts","title":"<code>motor_encoder_counts: int</code>  <code>property</code>","text":"<p>Raw reading from motor encoder in counts.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Motor encoder counts.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor encoder counts: {actuator.motor_encoder_counts}\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_position","title":"<code>motor_position: float</code>  <code>property</code>","text":"<p>Motor position in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor position in radians.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor position: {actuator.motor_position} rad\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_torque","title":"<code>motor_torque: float</code>  <code>property</code>","text":"<p>Torque at the motor output in Nm.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor torque in Nm.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor torque: {actuator.motor_torque} Nm\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_velocity","title":"<code>motor_velocity: float</code>  <code>property</code>","text":"<p>Motor velocity in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor velocity in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor velocity: {actuator.motor_velocity} rad/s\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_voltage","title":"<code>motor_voltage: float</code>  <code>property</code>","text":"<p>Q-axis motor voltage in mV.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor voltage in mV.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor voltage: {actuator.motor_voltage} mV\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.thermal_scaling_factor","title":"<code>thermal_scaling_factor: float</code>  <code>property</code>","text":"<p>Scale factor to use in torque control, in [0,1]. If you scale the torque command by this factor, the motor temperature will never exceed max allowable temperature. For a proof, see paper referenced in thermal model.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal scaling factor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Thermal scaling factor: {actuator.thermal_scaling_factor}\")\n&gt;&gt;&gt; actuator.update()\n&gt;&gt;&gt; # This will update the thermal model and return the new scaling factor.\n&gt;&gt;&gt; print(f\"Thermal scaling factor: {actuator.thermal_scaling_factor}\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.winding_temperature","title":"<code>winding_temperature: float</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Winding temperature in degrees celsius.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Winding temperature: {actuator.winding_temperature} C\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.home","title":"<code>home(homing_voltage=2000, homing_frequency=None, homing_direction=-1, joint_direction=-1, joint_position_offset=0.0, motor_position_offset=0.0, current_threshold=5000, velocity_threshold=0.001)</code>","text":"<p>This method homes the actuator and the corresponding joint by moving it to the zero position. The zero position is defined as the position where the joint is fully extended. This method will also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts to joint position in radians. This is useful for more accurate joint position estimation. Args:     homing_voltage: Voltage in mV to use for homing. Default is 2000 mV.     homing_frequency: Frequency in Hz to use for homing. Default is the actuator's frequency.     homing_direction: Direction to move the actuator during homing. Default is -1.     joint_direction: Direction to move the joint during homing. Default is -1.     joint_position_offset: Offset in radians to add to the joint position. Default is 0.0.     motor_position_offset: Offset in radians to add to the motor position. Default is 0.0.     current_threshold: Current threshold in mA to stop homing the joint or actuator.         This is used to detect if the actuator or joint has hit a hard stop. Default is 5000 mA.     velocity_threshold: Velocity threshold in rad/s to stop homing the joint or actuator.         This is also used to detect if the actuator or joint has hit a hard stop. Default is 0.001 rad/s. Examples:     &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')     &gt;&gt;&gt; actuator.start()     &gt;&gt;&gt; actuator.home(homing_voltage=2000, homing_direction=-1)</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def home(\n    self,\n    homing_voltage: int = 2000,\n    homing_frequency: Optional[int] = None,\n    homing_direction: int = -1,\n    joint_direction: int = -1,\n    joint_position_offset: float = 0.0,\n    motor_position_offset: float = 0.0,\n    current_threshold: int = 5000,\n    velocity_threshold: float = 0.001,\n) -&gt; None:\n    \"\"\"\n\n    This method homes the actuator and the corresponding joint by moving it to the zero position.\n    The zero position is defined as the position where the joint is fully extended. This method will\n    also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts\n    to joint position in radians. This is useful for more accurate joint position estimation.\n    Args:\n        homing_voltage: Voltage in mV to use for homing. Default is 2000 mV.\n        homing_frequency: Frequency in Hz to use for homing. Default is the actuator's frequency.\n        homing_direction: Direction to move the actuator during homing. Default is -1.\n        joint_direction: Direction to move the joint during homing. Default is -1.\n        joint_position_offset: Offset in radians to add to the joint position. Default is 0.0.\n        motor_position_offset: Offset in radians to add to the motor position. Default is 0.0.\n        current_threshold: Current threshold in mA to stop homing the joint or actuator.\n            This is used to detect if the actuator or joint has hit a hard stop. Default is 5000 mA.\n        velocity_threshold: Velocity threshold in rad/s to stop homing the joint or actuator.\n            This is also used to detect if the actuator or joint has hit a hard stop. Default is 0.001 rad/s.\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.home(homing_voltage=2000, homing_direction=-1)\n\n    \"\"\"\n    is_homing = True\n    homing_frequency = homing_frequency if homing_frequency is not None else self.frequency\n\n    LOGGER.info(\n        f\"[{self.__repr__()}] Homing {self.tag} joint.\"\n        \"Please make sure the joint is free to move and press Enter to continue.\"\n    )\n    input()\n\n    self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n\n    self.set_motor_voltage(value=homing_direction * homing_voltage)  # mV, negative for counterclockwise\n\n    _motor_encoder_array = []\n    _joint_encoder_array = []\n\n    time.sleep(0.1)\n\n    try:\n        while is_homing:\n            self.update()\n            time.sleep(1 / homing_frequency)\n\n            _motor_encoder_array.append(self.motor_position)\n            _joint_encoder_array.append(self.joint_position)\n\n            if abs(self.output_velocity) &lt;= velocity_threshold or abs(self.motor_current) &gt;= current_threshold:\n                self.set_motor_voltage(value=0)\n                is_homing = False\n\n    except KeyboardInterrupt:\n        self.set_motor_voltage(value=0)\n        LOGGER.info(msg=f\"[{self.__repr__()}] Homing interrupted.\")\n        return\n    except Exception as e:\n        self.set_motor_voltage(value=0)\n        LOGGER.error(msg=f\"[{self.__repr__()}] Homing failed: {e}\")\n        return\n\n    self.set_motor_zero_position(value=self.motor_position)\n    self.set_joint_zero_position(value=self.joint_position)\n\n    time.sleep(0.1)\n    self.set_joint_direction(joint_direction)\n    self.set_motor_position_offset(motor_position_offset)\n    self.set_joint_position_offset(joint_position_offset)\n\n    self._is_homed = True\n    LOGGER.info(f\"[{self.__repr__()}] Homing complete.\")\n\n    if os.path.isfile(path=f\"./{self.tag}_encoder_map.npy\"):\n        coefficients = np.load(file=f\"./{self.tag}_encoder_map.npy\")\n        self.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=coefficients))\n    else:\n        LOGGER.debug(\n            msg=f\"[{self.__repr__()}] No encoder map found. Please call the make_encoder_map method \\\n                to create one. The encoder map is used to estimate joint position more accurately.\"\n        )\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.make_encoder_map","title":"<code>make_encoder_map(overwrite=False)</code>","text":"<p>This method makes a lookup table to calculate the position measured by the joint encoder. This is necessary because the magnetic output encoders are nonlinear. By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio should be the same as the true joint position. Output from this function is a file containing a_i values parameterizing the map.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing encoder map. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Eqn <p>position = sum from i=0^5 (a_i*counts^i)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.make_encoder_map(overwrite=True)\n</code></pre> Kevin Best <p>U-M Locolab | Neurobionics Lab Gitub: tkevinbest, https://github.com/tkevinbest</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def make_encoder_map(self, overwrite: bool = False) -&gt; None:\n    \"\"\"\n    This method makes a lookup table to calculate the position measured by the joint encoder.\n    This is necessary because the magnetic output encoders are nonlinear.\n    By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio\n    should be the same as the true joint position. Output from this function is a file containing a_i values\n    parameterizing the map.\n\n    Args:\n        overwrite (bool): Whether to overwrite the existing encoder map. Default is False.\n\n    Returns:\n        None\n\n    Eqn:\n        position = sum from i=0^5 (a_i*counts^i)\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.make_encoder_map(overwrite=True)\n\n    Author: Kevin Best\n            U-M Locolab | Neurobionics Lab\n            Gitub: tkevinbest, https://github.com/tkevinbest\n    \"\"\"\n\n    if not self.is_homed:\n        LOGGER.warning(msg=f\"[{self.__repr__()}] Please home the {self.tag} joint before making the encoder map.\")\n        return None\n\n    if os.path.exists(f\"./{self.tag}_encoder_map.npy\") and not overwrite:\n        LOGGER.info(msg=f\"[{self.__repr__()}] Encoder map exists. Skipping encoder map creation.\")\n        return None\n\n    self.set_control_mode(mode=CONTROL_MODES.CURRENT)\n    self.set_current_gains()\n    time.sleep(0.1)\n    self.set_current_gains()\n\n    self.set_joint_torque(value=0.0)\n    time.sleep(0.1)\n    self.set_joint_torque(value=0.0)\n\n    _joint_encoder_array = []\n    _output_position_array = []\n\n    LOGGER.info(\n        msg=f\"[{self.__repr__()}] Please manually move the {self.tag} joint numerous times through \\\n            its full range of motion for 10 seconds. \\n{input('Press any key when you are ready to start.')}\"\n    )\n\n    _start_time: float = time.time()\n\n    try:\n        while time.time() - _start_time &lt; 10:\n            LOGGER.info(\n                msg=f\"[{self.__repr__()}] Mapping the {self.tag} \\\n                    joint encoder: {10 - time.time() + _start_time} seconds left.\"\n            )\n            self.update()\n            _joint_encoder_array.append(self.joint_encoder_counts)\n            _output_position_array.append(self.output_position)\n            time.sleep(1 / self.frequency)\n\n    except KeyboardInterrupt:\n        LOGGER.warning(msg=\"Encoder map interrupted.\")\n        return None\n\n    LOGGER.info(msg=f\"[{self.__repr__()}] You may now stop moving the {self.tag} joint.\")\n\n    _power = np.arange(4.0)\n    _a_mat = np.array(_joint_encoder_array).reshape(-1, 1) ** _power\n    _beta = np.linalg.lstsq(_a_mat, _output_position_array, rcond=None)\n    _coeffs = _beta[0]\n\n    self.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=_coeffs))\n\n    np.save(file=f\"./{self.tag}_encoder_map.npy\", arr=_coeffs)\n    LOGGER.info(msg=f\"[{self.__repr__()}] Encoder map saved to './{self.tag}_encoder_map.npy'.\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_current_gains","title":"<code>set_current_gains(kp=DEFAULT_CURRENT_GAINS.kp, ki=DEFAULT_CURRENT_GAINS.ki, kd=DEFAULT_CURRENT_GAINS.kd, ff=DEFAULT_CURRENT_GAINS.ff)</code>","text":"<p>Sets the current gains in arbitrary Dephy units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_current_gains(kp=40, ki=400, kd=0, ff=128)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_current_gains(\n    self,\n    kp: float = DEFAULT_CURRENT_GAINS.kp,\n    ki: float = DEFAULT_CURRENT_GAINS.ki,\n    kd: float = DEFAULT_CURRENT_GAINS.kd,\n    ff: float = DEFAULT_CURRENT_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the current gains in arbitrary Dephy units.\n\n    Args:\n        kp: The proportional gain\n        ki: The integral gain\n        kd: The derivative gain\n        ff: The feedforward gain\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_current_gains(kp=40, ki=400, kd=0, ff=128)\n    \"\"\"\n    self.set_gains(\n        kp=int(kp),\n        ki=int(ki),\n        kd=int(kd),\n        k=0,\n        b=0,\n        ff=int(ff),\n    )\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_encoder_map","title":"<code>set_encoder_map(encoder_map)</code>","text":"<p>Sets the joint encoder map</p> <p>Parameters:</p> Name Type Description Default <code>encoder_map</code> <code>Polynomial</code> <p>The encoder map to set</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=[1, 2, 3, 4, 5]))\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_encoder_map(self, encoder_map: np.polynomial.polynomial.Polynomial) -&gt; None:\n    \"\"\"\n    Sets the joint encoder map\n\n    Args:\n        encoder_map: The encoder map to set\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=[1, 2, 3, 4, 5]))\n    \"\"\"\n    self._encoder_map: np.polynomial.polynomial.Polynomial = encoder_map\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_impedance_gains","title":"<code>set_impedance_gains(kp=DEFAULT_IMPEDANCE_GAINS.kp, ki=DEFAULT_IMPEDANCE_GAINS.ki, kd=DEFAULT_IMPEDANCE_GAINS.kd, k=DEFAULT_IMPEDANCE_GAINS.k, b=DEFAULT_IMPEDANCE_GAINS.b, ff=DEFAULT_IMPEDANCE_GAINS.ff)</code>","text":"<p>Sets the impedance gains in arbitrary actpack units. See Dephy's webpage for conversions or use other library methods that handle conversion for you.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>k</code> <code>float</code> <p>The spring constant</p> <code>k</code> <code>b</code> <code>float</code> <p>The damping constant</p> <code>b</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_impedance_gains(kp=40, ki=400, kd=0, k=200, b=400, ff=128)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_impedance_gains(\n    self,\n    kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n    ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n    kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n    k: float = DEFAULT_IMPEDANCE_GAINS.k,\n    b: float = DEFAULT_IMPEDANCE_GAINS.b,\n    ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the impedance gains in arbitrary actpack units.\n    See Dephy's webpage for conversions or use other library methods that handle conversion for you.\n\n    Args:\n        kp: The proportional gain\n        ki: The integral gain\n        kd: The derivative gain\n        k: The spring constant\n        b: The damping constant\n        ff: The feedforward gain\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_impedance_gains(kp=40, ki=400, kd=0, k=200, b=400, ff=128)\n    \"\"\"\n    self.set_gains(\n        kp=int(kp),\n        ki=int(ki),\n        kd=int(kd),\n        k=int(k),\n        b=int(b),\n        ff=int(ff),\n    )\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_joint_torque","title":"<code>set_joint_torque(value)</code>","text":"<p>Set the joint torque of the joint. This is the torque that is applied to the joint, not the motor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>torque in N_m</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_joint_torque(0.1)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_joint_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the joint torque of the joint.\n    This is the torque that is applied to the joint, not the motor.\n\n    Args:\n        value: torque in N_m\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_joint_torque(0.1)\n    \"\"\"\n    self.set_motor_torque(value=value / self.gear_ratio)\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_current","title":"<code>set_motor_current(value)</code>","text":"<p>Sets the motor current in mA.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The current to set in mA.</p> required <p>Returns:     None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_current(1000)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_current(\n    self,\n    value: float,\n) -&gt; None:\n    \"\"\"\n    Sets the motor current in mA.\n\n    Args:\n        value: The current to set in mA.\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_current(1000)\n    \"\"\"\n    self.command_motor_current(value=int(value))\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_impedance","title":"<code>set_motor_impedance(kp=DEFAULT_IMPEDANCE_GAINS.kp, ki=DEFAULT_IMPEDANCE_GAINS.ki, kd=DEFAULT_IMPEDANCE_GAINS.kd, k=0.08922, b=0.003807, ff=DEFAULT_IMPEDANCE_GAINS.ff)</code>","text":"<p>Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>Proportional gain. Defaults to 40.</p> <code>kp</code> <code>ki</code> <code>float</code> <p>Integral gain. Defaults to 400.</p> <code>ki</code> <code>kd</code> <code>float</code> <p>Derivative gain. Defaults to 0.</p> <code>kd</code> <code>k</code> <code>float</code> <p>Spring constant. Defaults to 0.08922 Nm/rad.</p> <code>0.08922</code> <code>b</code> <code>float</code> <p>Damping constant. Defaults to 0.0038070 Nm/rad/s.</p> <code>0.003807</code> <code>ff</code> <code>float</code> <p>Feedforward gain. Defaults to 128.</p> <code>ff</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_impedance(kp=40, ki=400, kd=0, k=0.08922, b=0.0038070, ff=128)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_impedance(\n    self,\n    kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n    ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n    kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n    k: float = 0.08922,\n    b: float = 0.0038070,\n    ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.\n\n    Args:\n        kp: Proportional gain. Defaults to 40.\n        ki: Integral gain. Defaults to 400.\n        kd: Derivative gain. Defaults to 0.\n        k: Spring constant. Defaults to 0.08922 Nm/rad.\n        b: Damping constant. Defaults to 0.0038070 Nm/rad/s.\n        ff: Feedforward gain. Defaults to 128.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_impedance(kp=40, ki=400, kd=0, k=0.08922, b=0.0038070, ff=128)\n    \"\"\"\n    self.set_impedance_gains(\n        kp=kp,\n        ki=ki,\n        kd=kd,\n        k=int(k * self.MOTOR_CONSTANTS.NM_PER_RAD_TO_K),\n        b=int(b * self.MOTOR_CONSTANTS.NM_S_PER_RAD_TO_B),\n        ff=ff,\n    )\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Sets the motor position in radians. If in impedance mode, this sets the equilibrium angle in radians.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_position(0.1)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor position in radians.\n    If in impedance mode, this sets the equilibrium angle in radians.\n\n    Args:\n        value: The position to set\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_position(0.1)\n    \"\"\"\n    # TODO: New Dephy API splits impedance equilibrium position and position control into separate methods\n    if self.mode == CONTROL_MODES.POSITION:\n        self.command_motor_position(\n            value=int(\n                (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n            ),\n        )\n    elif self.mode == CONTROL_MODES.IMPEDANCE:\n        self.command_motor_impedance(\n            value=int(\n                (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n            ),\n        )\n    else:\n        raise ControlModeException(tag=self._tag, attribute=\"set_motor_position\", mode=self._mode.name)\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_torque","title":"<code>set_motor_torque(value)</code>","text":"<p>Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output. Args:     value: The torque to set in Nm. Returns:     None Examples:     &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')     &gt;&gt;&gt; actuator.start()     &gt;&gt;&gt; actuator.set_motor_torque(0.1)</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output.\n    Args:\n        value: The torque to set in Nm.\n    Returns:\n        None\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_torque(0.1)\n    \"\"\"\n    self.set_motor_current(\n        value / self.MOTOR_CONSTANTS.NM_PER_MILLIAMP,\n    )\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Sets the motor voltage in mV.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set in mV.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_voltage(100)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor voltage in mV.\n\n    Args:\n        value: The voltage to set in mV.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_voltage(100)\n    \"\"\"\n    self.command_motor_voltage(value=int(value))\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_output_impedance","title":"<code>set_output_impedance(kp=DEFAULT_IMPEDANCE_GAINS.kp, ki=DEFAULT_IMPEDANCE_GAINS.ki, kd=DEFAULT_IMPEDANCE_GAINS.kd, k=100.0, b=3.0, ff=128)</code>","text":"<p>Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s. This sets the impedance at the output and automatically scales based on gear raitos.</p> Conversion <p>K_motor = K_joint / (gear_ratio ** 2) B_motor = B_joint / (gear_ratio ** 2)</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>Proportional gain. Defaults to 40.</p> <code>kp</code> <code>ki</code> <code>float</code> <p>Integral gain. Defaults to 400.</p> <code>ki</code> <code>kd</code> <code>float</code> <p>Derivative gain. Defaults to 0.</p> <code>kd</code> <code>k</code> <code>float</code> <p>Spring constant. Defaults to 100 Nm/rad.</p> <code>100.0</code> <code>b</code> <code>float</code> <p>Damping constant. Defaults to 3.0 Nm/rad/s.</p> <code>3.0</code> <code>ff</code> <code>float</code> <p>Feedforward gain. Defaults to 128.</p> <code>128</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_output_impedance(kp=40, ki=400, kd=0, k=100, b=3, ff=128)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_output_impedance(\n    self,\n    kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n    ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n    kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n    k: float = 100.0,\n    b: float = 3.0,\n    ff: float = 128,\n) -&gt; None:\n    \"\"\"\n    Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s.\n    This sets the impedance at the output and automatically scales based on gear raitos.\n\n    Conversion:\n        K_motor = K_joint / (gear_ratio ** 2)\n        B_motor = B_joint / (gear_ratio ** 2)\n\n    Args:\n        kp: Proportional gain. Defaults to 40.\n        ki: Integral gain. Defaults to 400.\n        kd: Derivative gain. Defaults to 0.\n        k: Spring constant. Defaults to 100 Nm/rad.\n        b: Damping constant. Defaults to 3.0 Nm/rad/s.\n        ff: Feedforward gain. Defaults to 128.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_output_impedance(kp=40, ki=400, kd=0, k=100, b=3, ff=128)\n    \"\"\"\n    self.set_motor_impedance(\n        kp=kp,\n        ki=ki,\n        kd=kd,\n        k=k / (self.gear_ratio**2),\n        b=b / (self.gear_ratio**2),\n        ff=ff,\n    )\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_output_torque","title":"<code>set_output_torque(value)</code>","text":"<p>Set the output torque of the joint. This is the torque that is applied to the joint, not the motor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>torque in N_m</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_output_torque(0.1)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>@deprecated_with_routing(alternative_func=set_joint_torque)\ndef set_output_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the output torque of the joint.\n    This is the torque that is applied to the joint, not the motor.\n\n    Args:\n        value: torque in N_m\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_output_torque(0.1)\n    \"\"\"\n    self.set_motor_torque(value=value / self.gear_ratio)\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_position_gains","title":"<code>set_position_gains(kp=DEFAULT_POSITION_GAINS.kp, ki=DEFAULT_POSITION_GAINS.ki, kd=DEFAULT_POSITION_GAINS.kd, ff=DEFAULT_POSITION_GAINS.ff)</code>","text":"<p>Sets the position gains in arbitrary Dephy units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_position_gains(kp=30, ki=0, kd=0, ff=0)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_position_gains(\n    self,\n    kp: float = DEFAULT_POSITION_GAINS.kp,\n    ki: float = DEFAULT_POSITION_GAINS.ki,\n    kd: float = DEFAULT_POSITION_GAINS.kd,\n    ff: float = DEFAULT_POSITION_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Dephy units.\n\n    Args:\n        kp: The proportional gain\n        ki: The integral gain\n        kd: The derivative gain\n        ff: The feedforward gain\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_position_gains(kp=30, ki=0, kd=0, ff=0)\n    \"\"\"\n    self.set_gains(\n        kp=int(kp),\n        ki=int(ki),\n        kd=int(kd),\n        k=0,\n        b=0,\n        ff=int(ff),\n    )\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.start","title":"<code>start()</code>","text":"<p>Starts the actuator by opening the port, starting data streaming, reading initial data, and setting the control mode to VOLTAGE.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>@check_actuator_connection\ndef start(self) -&gt; None:\n    \"\"\"\n    Starts the actuator by opening the port, starting data streaming,\n    reading initial data, and setting the control mode to VOLTAGE.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n    \"\"\"\n    try:\n        self.open()\n        self._is_open = True\n    except OSError:\n        print(\"\\n\")\n        LOGGER.error(\n            msg=f\"[{self.__repr__()}] Need admin previleges to open the port '{self.port}'. \\n\\n \\\n                Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n        )\n        os._exit(status=1)\n\n    self.start_streaming(self._frequency)\n    time.sleep(0.2)\n    self._is_streaming = True\n\n    self._data = self.read()\n    self.set_control_mode(CONTROL_MODES.VOLTAGE)\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.stop","title":"<code>stop()</code>","text":"<p>Stops the actuator by stopping the motor, switching to IDLE mode, stopping data streaming, and closing the connection.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; # ... perform control tasks ...\n&gt;&gt;&gt; actuator.stop()\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>@check_actuator_stream\n@check_actuator_open\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stops the actuator by stopping the motor, switching to IDLE mode,\n    stopping data streaming, and closing the connection.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; # ... perform control tasks ...\n        &gt;&gt;&gt; actuator.stop()\n    \"\"\"\n    self.stop_motor()\n    self.set_control_mode(mode=CONTROL_MODES.IDLE)\n    self._is_streaming = False\n    self._is_open = False\n    self.close()\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.update","title":"<code>update()</code>","text":"<p>Updates the actuator's data by reading new values and updating the thermal model. It raises exceptions if thermal limits are exceeded.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator()\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.update()\n&gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Updates the actuator's data by reading new values and updating the thermal model.\n    It raises exceptions if thermal limits are exceeded.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator()\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.update()\n        &gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n    \"\"\"\n    self._data = self.read()\n\n    self._thermal_model.T_c = self.case_temperature\n    self._thermal_scale = self._thermal_model.update_and_get_scale(\n        dt=1 / self.frequency,\n        motor_current=self.motor_current,\n    )\n    if self.case_temperature &gt;= self.max_case_temperature:\n        LOGGER.error(\n            msg=f\"[{str.upper(self.tag)}] Case thermal limit {self.max_case_temperature} reached. \\\n                Stopping motor.\"\n        )\n        # self.stop()\n        raise ThermalLimitException()\n\n    if self.winding_temperature &gt;= self.max_winding_temperature:\n        LOGGER.error(\n            msg=f\"[{str.upper(self.tag)}] Winding thermal limit {self.max_winding_temperature} reached. \\\n                Stopping motor.\"\n        )\n        raise ThermalLimitException()\n    # Check for thermal fault, bit 2 of the execute status byte\n    if self._data[\"status_ex\"] &amp; 0b00000010 == 0b00000010:\n        self.stop()\n        raise RuntimeError(\"Actpack Thermal Limit Tripped\")\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator","title":"<code>DephyLegacyActuator</code>","text":"<p>               Bases: <code>DephyActuator</code></p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>class DephyLegacyActuator(DephyActuator):\n    def __init__(\n        self,\n        tag: str = \"DephyActuator\",\n        port: str = \"/dev/ttyACM0\",\n        gear_ratio: float = 1.0,\n        baud_rate: int = 230400,\n        frequency: int = 500,\n        debug_level: int = 4,\n        dephy_log: bool = False,\n        offline: bool = False,\n    ) -&gt; None:\n        ActuatorBase.__init__(\n            self,\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=DEPHY_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n\n        self._debug_level: int = debug_level if dephy_log else 6\n        self._dephy_log: bool = dephy_log\n\n        if self.is_offline:\n            self.port = port\n            self._is_streaming: bool = False\n            self._is_open: bool = False\n        else:\n            # def set_is_streaming(self, value):\n            #     self._is_streaming = value\n\n            # def set_is_open(self, value):\n            #     self._is_open = value\n\n            # type(self).is_streaming = property(fset=set_is_streaming)\n            # type(self).is_open = property(fset=set_is_open)\n\n            Device.__init__(self, port=port, baud_rate=baud_rate)\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            temp_limit_windings=self.max_winding_temperature,\n            soft_border_C_windings=10,\n            temp_limit_case=self.max_case_temperature,\n            soft_border_C_case=10,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._mode = CONTROL_MODES.IDLE\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.tag}[DephyActuator]\"\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return DEPHY_LEGACY_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    def start(self) -&gt; None:\n        try:\n            self.open(\n                freq=self._frequency,\n                log_level=self._debug_level,\n                log_enabled=self._dephy_log,\n            )\n        except OSError:\n            print(\"\\n\")\n            LOGGER.error(\n                msg=f\"[{self.__repr__()}] Need admin previleges to open the port '{self.port}'. \\n\\n \\\n                    Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n            )\n            os._exit(status=1)\n\n        self._data = self.read()\n\n        # TODO: Verify if we need this sleep here\n        time.sleep(0.1)\n        self.set_control_mode(CONTROL_MODES.VOLTAGE)\n\n    @check_actuator_stream\n    @check_actuator_open\n    def stop(self) -&gt; None:\n        self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n        self.set_motor_voltage(value=0)\n\n        self.set_control_mode(mode=CONTROL_MODES.IDLE)\n        time.sleep(0.1)\n        self.close()\n\n    def update(self) -&gt; None:\n        self._data = self.read()\n\n        self._thermal_model.T_c = self.case_temperature\n        self._thermal_scale = self._thermal_model.update_and_get_scale(\n            dt=1 / self.frequency,\n            motor_current=self.motor_current,\n        )\n        if self.case_temperature &gt;= self.max_case_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Case thermal limit {self.max_case_temperature} reached. \\\n                    Stopping motor.\"\n            )\n            raise ThermalLimitException()\n\n        if self.winding_temperature &gt;= self.max_winding_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Winding thermal limit {self.max_winding_temperature} reached. \\\n                    Stopping motor.\"\n            )\n            raise ThermalLimitException()\n        # Check for thermal fault, bit 2 of the execute status byte\n\n        if self._data.status_ex &amp; 0b00000010 == 0b00000010:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Thermal Fault: Winding temperature: {self.winding_temperature}; \\\n                    Case temperature: {self.case_temperature}.\"\n            )\n            raise ThermalLimitException(\"Internal thermal limit tripped.\")\n\n    def set_motor_current(\n        self,\n        value: float,\n    ) -&gt; None:\n        \"\"\"\n        Sets the motor current in mA.\n\n        Args:\n            value: The current to set in mA.\n        \"\"\"\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_current)\n    def set_current(self, value: float) -&gt; None:\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor voltage in mV.\n\n        Args:\n            value: The voltage to set in mV.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_voltage(100)\n        \"\"\"\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_voltage)\n    def set_voltage(self, value: float) -&gt; None:\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor position in radians.\n        If in impedance mode, this sets the equilibrium angle in radians.\n\n        Args:\n            value: The position to set\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_position(0.1)\n        \"\"\"\n        self.send_motor_command(\n            ctrl_mode=c_int(self.mode.value),\n            value=int(\n                (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n            ),\n        )\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"Q-axis motor voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data.mot_volt)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data.mot_cur)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the motor output in Nm.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.mot_cur * self.MOTOR_CONSTANTS.NM_PER_MILLIAMP)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_position(self) -&gt; float:\n        \"\"\"\n        Motor position in radians.\n        \"\"\"\n        if self._data is not None:\n            return (\n                float(self._data.mot_ang * self.MOTOR_CONSTANTS.RAD_PER_COUNT)\n                - self.motor_zero_position\n                - self.motor_position_offset\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_encoder_counts(self) -&gt; int:\n        \"\"\"Raw reading from motor encoder in counts.\"\"\"\n        if self._data is not None:\n            return int(self._data.mot_ang)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def joint_encoder_counts(self) -&gt; int:\n        \"\"\"Raw reading from joint encoder in counts.\"\"\"\n        if self._data is not None:\n            return int(self._data.ank_ang)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        \"\"\"\n        Motor velocity in rad/s.\n        \"\"\"\n        if self._data is not None:\n            return int(self._data.mot_vel) * RAD_PER_DEG\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_acceleration(self) -&gt; float:\n        \"\"\"\n        Motor acceleration in rad/s^2.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.mot_acc)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_voltage(self) -&gt; float:\n        \"\"\"Battery voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data.batt_volt)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_current(self) -&gt; float:\n        \"\"\"Battery current in mA.\"\"\"\n        if self._data is not None:\n            return float(self._data.batt_curr)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_position(self) -&gt; float:\n        \"\"\"\n        Joint position in radians.\n        \"\"\"\n        if self._data is not None:\n            return (\n                float(self._data.ank_ang * self.MOTOR_CONSTANTS.RAD_PER_COUNT)\n                - self.joint_zero_position\n                - self.joint_position_offset\n            ) * self.joint_direction\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_velocity(self) -&gt; float:\n        \"\"\"\n        Joint velocity in rad/s.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.ank_vel * RAD_PER_DEG) * self.joint_direction\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the joint output in Nm.\n        This is calculated using motor current, k_t, and the gear ratio.\n        \"\"\"\n        return self.motor_torque * self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        \"\"\"\n        Case temperature of the actuator in celsius.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.temperature)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.T_w)\n        else:\n            return 0.0\n\n    @property\n    def genvars(self) -&gt; np.ndarray:\n        \"\"\"Dephy's 'genvars' object.\"\"\"\n        if self._data is not None:\n            return np.array(\n                object=[\n                    self._data.genvar_0,\n                    self._data.genvar_1,\n                    self._data.genvar_2,\n                    self._data.genvar_3,\n                    self._data.genvar_4,\n                    self._data.genvar_5,\n                ]\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning zeros\"\n            )\n            return np.zeros(shape=6)\n\n    @property\n    def accelx(self) -&gt; float:\n        \"\"\"\n        Acceleration in x direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accelx * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accely(self) -&gt; float:\n        \"\"\"\n        Acceleration in y direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accely * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accelz(self) -&gt; float:\n        \"\"\"\n        Acceleration in z direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accelz * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyrox(self) -&gt; float:\n        \"\"\"\n        Angular velocity in x direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyrox * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroy(self) -&gt; float:\n        \"\"\"\n        Angular velocity in y direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyroy * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        return self._is_streaming\n\n    @is_streaming.setter\n    def is_streaming(self, value: bool) -&gt; None:\n        self._is_streaming = value\n\n    @property\n    def is_open(self) -&gt; bool:\n        return self._is_open\n\n    @is_open.setter\n    def is_open(self, value: bool) -&gt; None:\n        self._is_open = value\n\n    @property\n    def gyroz(self) -&gt; float:\n        \"\"\"\n        Angular velocity in z direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyroz * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.accelx","title":"<code>accelx: float</code>  <code>property</code>","text":"<p>Acceleration in x direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.accely","title":"<code>accely: float</code>  <code>property</code>","text":"<p>Acceleration in y direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.accelz","title":"<code>accelz: float</code>  <code>property</code>","text":"<p>Acceleration in z direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.battery_current","title":"<code>battery_current: float</code>  <code>property</code>","text":"<p>Battery current in mA.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.battery_voltage","title":"<code>battery_voltage: float</code>  <code>property</code>","text":"<p>Battery voltage in mV.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.case_temperature","title":"<code>case_temperature: float</code>  <code>property</code>","text":"<p>Case temperature of the actuator in celsius.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.genvars","title":"<code>genvars: np.ndarray</code>  <code>property</code>","text":"<p>Dephy's 'genvars' object.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.gyrox","title":"<code>gyrox: float</code>  <code>property</code>","text":"<p>Angular velocity in x direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.gyroy","title":"<code>gyroy: float</code>  <code>property</code>","text":"<p>Angular velocity in y direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.gyroz","title":"<code>gyroz: float</code>  <code>property</code>","text":"<p>Angular velocity in z direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.joint_encoder_counts","title":"<code>joint_encoder_counts: int</code>  <code>property</code>","text":"<p>Raw reading from joint encoder in counts.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.joint_position","title":"<code>joint_position: float</code>  <code>property</code>","text":"<p>Joint position in radians.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.joint_torque","title":"<code>joint_torque: float</code>  <code>property</code>","text":"<p>Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.joint_velocity","title":"<code>joint_velocity: float</code>  <code>property</code>","text":"<p>Joint velocity in rad/s.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_acceleration","title":"<code>motor_acceleration: float</code>  <code>property</code>","text":"<p>Motor acceleration in rad/s^2.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_encoder_counts","title":"<code>motor_encoder_counts: int</code>  <code>property</code>","text":"<p>Raw reading from motor encoder in counts.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_position","title":"<code>motor_position: float</code>  <code>property</code>","text":"<p>Motor position in radians.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_torque","title":"<code>motor_torque: float</code>  <code>property</code>","text":"<p>Torque at the motor output in Nm.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_velocity","title":"<code>motor_velocity: float</code>  <code>property</code>","text":"<p>Motor velocity in rad/s.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_voltage","title":"<code>motor_voltage: float</code>  <code>property</code>","text":"<p>Q-axis motor voltage in mV.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.winding_temperature","title":"<code>winding_temperature: float</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.set_motor_current","title":"<code>set_motor_current(value)</code>","text":"<p>Sets the motor current in mA.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The current to set in mA.</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_current(\n    self,\n    value: float,\n) -&gt; None:\n    \"\"\"\n    Sets the motor current in mA.\n\n    Args:\n        value: The current to set in mA.\n    \"\"\"\n    self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Sets the motor position in radians. If in impedance mode, this sets the equilibrium angle in radians.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_position(0.1)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor position in radians.\n    If in impedance mode, this sets the equilibrium angle in radians.\n\n    Args:\n        value: The position to set\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_position(0.1)\n    \"\"\"\n    self.send_motor_command(\n        ctrl_mode=c_int(self.mode.value),\n        value=int(\n            (value + self.motor_zero_position + self.motor_position_offset) / self.MOTOR_CONSTANTS.RAD_PER_COUNT\n        ),\n    )\n</code></pre>"},{"location":"modules/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Sets the motor voltage in mV.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set in mV.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_voltage(100)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor voltage in mV.\n\n    Args:\n        value: The voltage to set in mV.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_voltage(100)\n    \"\"\"\n    self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n</code></pre>"},{"location":"modules/actuators/moteus/","title":"Moteus","text":""},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator","title":"<code>MoteusActuator</code>","text":"<p>               Bases: <code>ActuatorBase</code>, <code>Controller</code></p> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>class MoteusActuator(ActuatorBase, Controller):\n    def __init__(\n        self,\n        tag: str = \"Moteus\",\n        servo_id: int = 0,\n        bus_id: int = 0,\n        gear_ratio: float = 1.0,\n        frequency: int = 500,\n        offline: bool = False,\n        query: Optional[MoteusQueryResolution] = None,\n    ) -&gt; None:\n        if query is None:\n            query = MoteusQueryResolution()\n\n        self._servo_id = servo_id\n        self._bus_id = bus_id\n        super().__init__(\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=MOTEUS_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n\n        self._interface = MoteusInterface()\n        self._interface._add2map(servo_id=servo_id, bus_id=bus_id)\n\n        self._is_streaming: bool = False\n        self._is_open: bool = False\n\n        self._command: Command = None\n        self._data = None\n        self._query = query\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            temp_limit_windings=self.max_winding_temperature,\n            soft_border_C_windings=10,\n            temp_limit_case=self.max_case_temperature,\n            soft_border_C_case=10,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._mode = CONTROL_MODES.IDLE\n\n    def __repr__(self) -&gt; str:\n        return f\"Moteus[{self._tag}]\"\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return MOTEUS_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    async def start(self) -&gt; None:\n        try:\n            self._interface.start()\n            Controller.__init__(\n                self,\n                id=self._servo_id,\n                transport=self._interface.transport,\n                query_resolution=self._query,\n            )\n            self._stream = Stream(controller=self)\n\n            self._is_open = True\n            self._is_streaming = True\n\n        except OSError:\n            print(\"\\n\")\n            LOGGER.error(\n                msg=f\"[{self.__repr__()}] Need admin previleges to open the port. \\n\\n \\\n                    Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n            )\n            os._exit(status=1)\n\n        default_mode_config = self._get_control_mode_config(self._mode)\n        if default_mode_config:\n            default_mode_config.entry_callback(self)\n\n        if (await self._interface.transport.cycle([self.make_stop(query=True)])) == []:\n            LOGGER.error(msg=f\"[{self.__repr__()}] Could not start the actuator. Please check the connection.\")\n            self._is_streaming = False\n            self._is_open = False\n        # Keep the default command as query -- reading sensor data\n        self._command = self.make_query()\n\n    @check_actuator_stream\n    @check_actuator_open\n    async def stop(self) -&gt; None:\n        self.set_control_mode(mode=CONTROL_MODES.IDLE)\n\n        await self._interface.transport.cycle([self.make_stop(query=True)])\n        self._command = self.make_query()\n\n    async def update(self):\n        self._data = await self._interface.transport.cycle([self._command])\n\n        self._thermal_model.T_c = self.case_temperature\n        self._thermal_scale = self._thermal_model.update_and_get_scale(\n            dt=1 / self.frequency,\n            motor_current=self.motor_current,\n        )\n        if self.case_temperature &gt;= self.max_case_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Case thermal limit {self.max_case_temperature} reached. Stopping motor.\"\n            )\n            raise ThermalLimitException()\n\n        if self.winding_temperature &gt;= self.max_winding_temperature:\n            LOGGER.error(\n                msg=f\"[{str.upper(self.tag)}] Winding thermal limit {self.max_winding_temperature} reached. \\\n                Stopping motor.\"\n            )\n            raise ThermalLimitException()\n\n        self._command = self.make_query()\n\n    def home(self) -&gt; None:\n        # TODO: implement homing\n        LOGGER.info(msg=f\"[{self.__repr__()}] Homing not implemented.\")\n\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor torque in Nm.\n\n        Args:\n            value: The torque to set in Nm.\n        \"\"\"\n        self._command = self.make_position(\n            position=math.nan,\n            velocity=math.nan,\n            feedforward_torque=value,\n            kp_scale=0,\n            kd_scale=0,\n            ilimit_scale=0,\n            watchdog_timeout=math.nan,\n            query=True,\n        )\n\n    def set_joint_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the joint torque of the joint.\n        This is the torque that is applied to the joint, not the motor.\n\n        Args:\n            value: torque in N_m\n        \"\"\"\n        self.set_motor_torque(value=value / self.gear_ratio)\n\n    def set_motor_current(\n        self,\n        value: float,\n    ) -&gt; None:\n        LOGGER.info(\"Current Mode Not Implemented\")\n\n    def set_motor_velocity(self, value: float) -&gt; None:\n        self._command = self.make_position(\n            position=math.nan,\n            velocity=value / (np.pi * 2),  # TODO: Verify this conversion, are we converting from rad/s to rev/s?\n            query=True,\n            watchdog_timeout=math.nan,\n        )\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor voltage in mV.\n\n        Args:\n            value: The voltage to set in mV.\n        \"\"\"\n        LOGGER.info(\"Voltage Mode Not Implemented\")\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor position in radians.\n        If in impedance mode, this sets the equilibrium angle in radians.\n\n        Args:\n            value: The position to set\n        \"\"\"\n        self._command = self.make_position(\n            position=float((value) / (2 * np.pi)),  # TODO: Verify this conversion, are we converting from rad to rev?\n            query=True,\n            watchdog_timeout=math.nan,\n        )\n\n    async def set_torque_gains(\n        self,\n        kp: float = DEFAULT_TORQUE_GAINS.kp,\n        ki: float = DEFAULT_TORQUE_GAINS.ki,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Moteus units.\n\n        Args:\n            kp: The proportional gain\n            ki: The integral gain\n        \"\"\"\n        await self._stream.command(f\"conf set servo.pid_dq.kp {kp}\".encode())\n        await self._stream.command(f\"conf set servo.pid_dq.ki {ki}\".encode())\n\n    async def set_position_gains(\n        self,\n        kp: float = DEFAULT_POSITION_GAINS.kp,\n        ki: float = DEFAULT_POSITION_GAINS.ki,\n        kd: float = DEFAULT_POSITION_GAINS.kd,\n        ff: float = DEFAULT_POSITION_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Moteus units.\n\n        Args:\n            kp: The proportional gain\n            ki: The integral gain\n            kd: The derivative gain\n            ff: The feedforward gain\n        \"\"\"\n        await self._stream.command(f\"conf set servo.pid_position.kp {kp}\".encode())\n        await self._stream.command(f\"conf set servo.pid_position.ki {ki}\".encode())\n        await self._stream.command(f\"conf set servo.pid_position.kd {kd}\".encode())\n\n    async def set_velocity_gains(\n        self,\n        kp: float = DEFAULT_VELOCITY_GAINS.kp,\n        ki: float = DEFAULT_VELOCITY_GAINS.ki,\n        kd: float = DEFAULT_VELOCITY_GAINS.kd,\n        ff: float = DEFAULT_VELOCITY_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Moteus units.\n\n        Args:\n            kp: The proportional gain\n            ki: The integral gain\n            kd: The derivative gain\n            ff: The feedforward gain\n        \"\"\"\n        await self._stream.command(f\"conf set servo.pid_position.kp {kp}\".encode())\n        await self._stream.command(f\"conf set servo.pid_position.ki {ki}\".encode())\n        await self._stream.command(f\"conf set servo.pid_position.kd {kd}\".encode())\n\n    def set_current_gains(\n        self,\n        kp: float = DEFAULT_CURRENT_GAINS.kp,\n        ki: float = DEFAULT_CURRENT_GAINS.ki,\n        kd: float = DEFAULT_CURRENT_GAINS.kd,\n        ff: float = DEFAULT_CURRENT_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the current gains in arbitrary Moteus units.\n\n        Args:\n            kp: The proportional gain\n            ki: The integral gain\n            kd: The derivative gain\n            ff: The feedforward gain\n        \"\"\"\n        LOGGER.info(msg=f\"[{self.__repr__()}] Current mode not implemented.\")\n\n    def set_impedance_gains(\n        self,\n        kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n        ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n        kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n        k: float = DEFAULT_IMPEDANCE_GAINS.k,\n        b: float = DEFAULT_IMPEDANCE_GAINS.b,\n        ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the impedance gains in arbitrary Moteus units.\n\n        Args:\n            kp: The proportional gain\n            ki: The integral gain\n            kd: The derivative gain\n            k: The stiffness gain\n            b: The damping gain\n            ff: The feedforward gain\n        \"\"\"\n        LOGGER.info(msg=f\"[{self.__repr__()}] Impedance mode not implemented.\")\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"Q-axis motor voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.VOLTAGE])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.Q_CURRENT])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_torque(self) -&gt; float:\n        if self._data is not None:\n            return float(self.motor_current * self.MOTOR_CONSTANTS.NM_PER_MILLIAMP) / self.gear_ratio\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_position(self) -&gt; float:\n        if self._data is not None:\n            return (\n                float(self._data[0].values[MoteusRegister.POSITION] * 2 * np.pi)\n                - self.motor_zero_position\n                - self.motor_position_offset\n            )\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.VELOCITY] * 2 * np.pi)\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_voltage(self) -&gt; float:\n        \"\"\"Battery voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.VOLTAGE])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_current(self) -&gt; float:\n        \"\"\"Battery current in mA.\"\"\"\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.Q_CURRENT])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the joint output in Nm.\n        This is calculated using motor current, k_t, and the gear ratio.\n        \"\"\"\n        return self.motor_torque * self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.TEMPERATURE])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.T_w)\n        else:\n            return 0.0\n\n    @property\n    def thermal_scaling_factor(self) -&gt; float:\n        \"\"\"\n        Scale factor to use in torque control, in [0,1].\n        If you scale the torque command by this factor, the motor temperature will\n        never exceed max allowable temperature.\n        For a proof, see paper referenced in thermal model.\n        \"\"\"\n        return self._thermal_scale\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.battery_current","title":"<code>battery_current: float</code>  <code>property</code>","text":"<p>Battery current in mA.</p>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.battery_voltage","title":"<code>battery_voltage: float</code>  <code>property</code>","text":"<p>Battery voltage in mV.</p>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.joint_torque","title":"<code>joint_torque: float</code>  <code>property</code>","text":"<p>Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.</p>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.motor_voltage","title":"<code>motor_voltage: float</code>  <code>property</code>","text":"<p>Q-axis motor voltage in mV.</p>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.thermal_scaling_factor","title":"<code>thermal_scaling_factor: float</code>  <code>property</code>","text":"<p>Scale factor to use in torque control, in [0,1]. If you scale the torque command by this factor, the motor temperature will never exceed max allowable temperature. For a proof, see paper referenced in thermal model.</p>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.winding_temperature","title":"<code>winding_temperature: float</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_current_gains","title":"<code>set_current_gains(kp=DEFAULT_CURRENT_GAINS.kp, ki=DEFAULT_CURRENT_GAINS.ki, kd=DEFAULT_CURRENT_GAINS.kd, ff=DEFAULT_CURRENT_GAINS.ff)</code>","text":"<p>Sets the current gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_current_gains(\n    self,\n    kp: float = DEFAULT_CURRENT_GAINS.kp,\n    ki: float = DEFAULT_CURRENT_GAINS.ki,\n    kd: float = DEFAULT_CURRENT_GAINS.kd,\n    ff: float = DEFAULT_CURRENT_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the current gains in arbitrary Moteus units.\n\n    Args:\n        kp: The proportional gain\n        ki: The integral gain\n        kd: The derivative gain\n        ff: The feedforward gain\n    \"\"\"\n    LOGGER.info(msg=f\"[{self.__repr__()}] Current mode not implemented.\")\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_impedance_gains","title":"<code>set_impedance_gains(kp=DEFAULT_IMPEDANCE_GAINS.kp, ki=DEFAULT_IMPEDANCE_GAINS.ki, kd=DEFAULT_IMPEDANCE_GAINS.kd, k=DEFAULT_IMPEDANCE_GAINS.k, b=DEFAULT_IMPEDANCE_GAINS.b, ff=DEFAULT_IMPEDANCE_GAINS.ff)</code>","text":"<p>Sets the impedance gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>k</code> <code>float</code> <p>The stiffness gain</p> <code>k</code> <code>b</code> <code>float</code> <p>The damping gain</p> <code>b</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_impedance_gains(\n    self,\n    kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n    ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n    kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n    k: float = DEFAULT_IMPEDANCE_GAINS.k,\n    b: float = DEFAULT_IMPEDANCE_GAINS.b,\n    ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the impedance gains in arbitrary Moteus units.\n\n    Args:\n        kp: The proportional gain\n        ki: The integral gain\n        kd: The derivative gain\n        k: The stiffness gain\n        b: The damping gain\n        ff: The feedforward gain\n    \"\"\"\n    LOGGER.info(msg=f\"[{self.__repr__()}] Impedance mode not implemented.\")\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_joint_torque","title":"<code>set_joint_torque(value)</code>","text":"<p>Set the joint torque of the joint. This is the torque that is applied to the joint, not the motor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>torque in N_m</p> required Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_joint_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the joint torque of the joint.\n    This is the torque that is applied to the joint, not the motor.\n\n    Args:\n        value: torque in N_m\n    \"\"\"\n    self.set_motor_torque(value=value / self.gear_ratio)\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Sets the motor position in radians. If in impedance mode, this sets the equilibrium angle in radians.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set</p> required Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor position in radians.\n    If in impedance mode, this sets the equilibrium angle in radians.\n\n    Args:\n        value: The position to set\n    \"\"\"\n    self._command = self.make_position(\n        position=float((value) / (2 * np.pi)),  # TODO: Verify this conversion, are we converting from rad to rev?\n        query=True,\n        watchdog_timeout=math.nan,\n    )\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_motor_torque","title":"<code>set_motor_torque(value)</code>","text":"<p>Sets the motor torque in Nm.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The torque to set in Nm.</p> required Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor torque in Nm.\n\n    Args:\n        value: The torque to set in Nm.\n    \"\"\"\n    self._command = self.make_position(\n        position=math.nan,\n        velocity=math.nan,\n        feedforward_torque=value,\n        kp_scale=0,\n        kd_scale=0,\n        ilimit_scale=0,\n        watchdog_timeout=math.nan,\n        query=True,\n    )\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Sets the motor voltage in mV.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set in mV.</p> required Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor voltage in mV.\n\n    Args:\n        value: The voltage to set in mV.\n    \"\"\"\n    LOGGER.info(\"Voltage Mode Not Implemented\")\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_position_gains","title":"<code>set_position_gains(kp=DEFAULT_POSITION_GAINS.kp, ki=DEFAULT_POSITION_GAINS.ki, kd=DEFAULT_POSITION_GAINS.kd, ff=DEFAULT_POSITION_GAINS.ff)</code>  <code>async</code>","text":"<p>Sets the position gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>async def set_position_gains(\n    self,\n    kp: float = DEFAULT_POSITION_GAINS.kp,\n    ki: float = DEFAULT_POSITION_GAINS.ki,\n    kd: float = DEFAULT_POSITION_GAINS.kd,\n    ff: float = DEFAULT_POSITION_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Moteus units.\n\n    Args:\n        kp: The proportional gain\n        ki: The integral gain\n        kd: The derivative gain\n        ff: The feedforward gain\n    \"\"\"\n    await self._stream.command(f\"conf set servo.pid_position.kp {kp}\".encode())\n    await self._stream.command(f\"conf set servo.pid_position.ki {ki}\".encode())\n    await self._stream.command(f\"conf set servo.pid_position.kd {kd}\".encode())\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_torque_gains","title":"<code>set_torque_gains(kp=DEFAULT_TORQUE_GAINS.kp, ki=DEFAULT_TORQUE_GAINS.ki)</code>  <code>async</code>","text":"<p>Sets the position gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>async def set_torque_gains(\n    self,\n    kp: float = DEFAULT_TORQUE_GAINS.kp,\n    ki: float = DEFAULT_TORQUE_GAINS.ki,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Moteus units.\n\n    Args:\n        kp: The proportional gain\n        ki: The integral gain\n    \"\"\"\n    await self._stream.command(f\"conf set servo.pid_dq.kp {kp}\".encode())\n    await self._stream.command(f\"conf set servo.pid_dq.ki {ki}\".encode())\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_velocity_gains","title":"<code>set_velocity_gains(kp=DEFAULT_VELOCITY_GAINS.kp, ki=DEFAULT_VELOCITY_GAINS.ki, kd=DEFAULT_VELOCITY_GAINS.kd, ff=DEFAULT_VELOCITY_GAINS.ff)</code>  <code>async</code>","text":"<p>Sets the position gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>async def set_velocity_gains(\n    self,\n    kp: float = DEFAULT_VELOCITY_GAINS.kp,\n    ki: float = DEFAULT_VELOCITY_GAINS.ki,\n    kd: float = DEFAULT_VELOCITY_GAINS.kd,\n    ff: float = DEFAULT_VELOCITY_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Moteus units.\n\n    Args:\n        kp: The proportional gain\n        ki: The integral gain\n        kd: The derivative gain\n        ff: The feedforward gain\n    \"\"\"\n    await self._stream.command(f\"conf set servo.pid_position.kp {kp}\".encode())\n    await self._stream.command(f\"conf set servo.pid_position.ki {ki}\".encode())\n    await self._stream.command(f\"conf set servo.pid_position.kd {kd}\".encode())\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusInterface","title":"<code>MoteusInterface</code>","text":"<p>Singleton Class as Communication Portal between Moteus Controller and Moteus PiHat</p> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>class MoteusInterface:\n    \"\"\"\n    Singleton Class as Communication Portal between Moteus Controller and Moteus PiHat\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls.bus_map: dict[int, list[int]] = {}\n            cls.bus_map: dict[int, list[int]] = {}\n            cls._commands: list[Command] = []\n            cls.transport = None\n        return cls._instance\n\n    def __init__(self):\n        pass\n\n    def __repr__(self):\n        return \"MoteusInterface\"\n\n    def _add2map(self, servo_id, bus_id) -&gt; None:\n        if bus_id in self.bus_map:\n            self.bus_map[bus_id].append(servo_id)\n        else:\n            self.bus_map[bus_id] = [servo_id]\n\n    def start(self):\n        \"\"\"\n        Initialization of Pi3HatRouter\n        \"\"\"\n        if self.transport is None:\n            self.transport = pihat.Pi3HatRouter(servo_bus_map=self.bus_map)\n\n    async def update(self):\n        # TODO: multiple servo update simultaneously should go here\n        self._commands = []\n\n    async def stop(self):\n        # TODO: multiple servo stop simultaneously should go here\n        self._commands = []\n</code></pre>"},{"location":"modules/actuators/moteus/#opensourceleg.actuators.moteus.MoteusInterface.start","title":"<code>start()</code>","text":"<p>Initialization of Pi3HatRouter</p> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def start(self):\n    \"\"\"\n    Initialization of Pi3HatRouter\n    \"\"\"\n    if self.transport is None:\n        self.transport = pihat.Pi3HatRouter(servo_bus_map=self.bus_map)\n</code></pre>"},{"location":"modules/actuators/tmotor/","title":"TMotor","text":""},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator","title":"<code>TMotorMITCANActuator</code>","text":"<p>               Bases: <code>ActuatorBase</code>, <code>TMotorManager_mit_can</code></p> <p>The user-facing class that manages the motor. This class should be used in the context of a with as block, in order to safely enter/exit control of the motor.</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>class TMotorMITCANActuator(ActuatorBase, TMotorManager_mit_can):\n    \"\"\"\n    The user-facing class that manages the motor. This class should be\n    used in the context of a with as block, in order to safely enter/exit\n    control of the motor.\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: str = \"TMotorActuator\",\n        motor_type: str = \"AK80-9\",\n        motor_ID: int = 41,\n        gear_ratio: float = 1.0,\n        frequency: int = 500,\n        offline: bool = False,\n        max_mosfett_temp: float = 50,\n    ):\n        \"\"\"\n        Sets up the motor manager. Note the device will not be powered on by this method! You must\n        call __enter__, mostly commonly by using a with block, before attempting to control the motor.\n\n        Args:\n            tag: A string tag to identify the motor\n            motor_type: The type of motor to control. Must be a key in MIT_Params.\n            motor_ID: The ID of the motor to control.\n            gear_ratio: The gear ratio of the motor. Default is 1.0.\n            frequency: The frequency at which to send commands to the motor. Default is 500.\n            offline: Whether to run the motor in offline mode. Default is False.\n            max_mosfett_temp: The maximum temperature of the mosfet in degrees C. Default is 50.\n        \"\"\"\n        ActuatorBase.__init__(\n            self,\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=TMOTOR_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n        TMotorManager_mit_can.__init__(\n            self,\n            motor_type=motor_type,\n            motor_ID=motor_ID,\n            max_mosfett_temp=max_mosfett_temp,\n        )\n        self.type = motor_type\n        self.ID = motor_ID\n        # self.csv_file_name = CSV_file\n        print(\"Initializing device: \" + self.device_info_string())\n\n        self._motor_state = motor_state(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n        self._motor_state_async = motor_state(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n        self._command = MIT_command(0.0, 0.0, 0.0, 0.0, 0.0)\n        # self._control_state = _TMotorManState.IDLE\n        self._times_past_position_limit = 0\n        self._times_past_current_limit = 0\n        self._times_past_velocity_limit = 0\n        self._angle_threshold = (\n            MIT_Params[self.type][\"P_max\"] - 2.0\n        )  # radians, only really matters if the motor's going super fast\n        self._current_threshold = (\n            self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"]) - 3.0\n        )  # A, only really matters if the current changes quick\n        self._velocity_threshold = (\n            MIT_Params[self.type][\"V_max\"] - 2.0\n        )  # radians, only really matters if the motor's going super fast\n        self._old_pos = None\n        self._old_curr = 0.0\n        self._old_vel = 0.0\n        self._old_current_zone = 0\n        self.max_temp = max_mosfett_temp  # max temp in deg C, can update later\n\n        self._entered = False\n        self._start_time = time.time()\n        self._last_update_time = self._start_time\n        self._last_command_time = None\n        self._updated = False\n        self.SF = 1.0\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            temp_limit_windings=self.max_winding_temperature,\n            soft_border_C_windings=10,\n            temp_limit_case=self.max_case_temperature,\n            soft_border_C_case=10,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._canman = CAN_Manager()\n        self._canman.add_motor(self)\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return TMOTOR_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    def start(self):\n        \"\"\"\n        Used to safely power the motor on and begin the log file (if specified).\n        \"\"\"\n        print(\"Turning on control for device: \" + self.device_info_string())\n\n        self.power_on()\n        self._send_command()\n        self._entered = True\n        self.is_streaming = True\n        if not self.check_can_connection():\n            raise RuntimeError(\"Device not connected: \" + str(self.device_info_string()))\n        return self\n\n    @check_actuator_stream\n    @check_actuator_open\n    def stop(self):\n        \"\"\"\n        Used to safely power the motor off and close the log file (if specified).\n        \"\"\"\n        print(\"Turning off control for device: \" + self.device_info_string())\n        self.power_off()\n\n    def home(self):\n        pass\n\n    def update(self):  # noqa: C901\n        \"\"\"\n        This method is called by the user to synchronize the current state used by the controller\n        with the most recent message recieved, as well as to send the current command.\n        \"\"\"\n\n        # check that the motor is safely turned on\n        if not self._entered:\n            raise RuntimeError(\n                \"Tried to update motor state before safely powering on for device: \" + self.device_info_string()\n            )\n\n        if self.case_temperature &gt; self.max_temp:\n            raise RuntimeError(f\"Temperature greater than {self.max_temp}C for device: {self.device_info_string()}\")\n\n        # check that the motor data is recent\n        # print(self._command_sent)\n        now = time.time()\n        if (now - self._last_command_time) &lt; 0.25 and ((now - self._last_update_time) &gt; 0.1):\n            warnings.warn(\n                \"State update requested but no data from motor. Delay longer after zeroing, \\\n                decrease frequency, or check connection. \"\n                + self.device_info_string(),\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        else:\n            self._command_sent = False\n\n        # artificially extending the range of the position, current, and velocity that we track\n        P_max = MIT_Params[self.type][\"P_max\"] + 0.01\n        I_max = self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"]) + 1.0\n        V_max = MIT_Params[self.type][\"V_max\"] + 0.01\n\n        if self._old_pos is None:\n            self._old_pos = self._motor_state_async.position\n        old_pos = self._old_pos\n        old_curr = self._old_curr\n        old_vel = self._old_vel\n\n        new_pos = self._motor_state_async.position\n        new_curr = self._motor_state_async.current\n        new_vel = self._motor_state_async.velocity\n\n        thresh_pos = self._angle_threshold\n        thresh_curr = self._current_threshold\n        thresh_vel = self._velocity_threshold\n\n        curr_command = self._command.current\n\n        actual_current = new_curr\n\n        # The TMotor will wrap around to -max at the limits for all values it returns!! Account for this\n        if (thresh_pos &lt;= new_pos and new_pos &lt;= P_max) and (-P_max &lt;= old_pos and old_pos &lt;= -thresh_pos):\n            self._times_past_position_limit -= 1\n        elif (thresh_pos &lt;= old_pos and old_pos &lt;= P_max) and (-P_max &lt;= new_pos and new_pos &lt;= -thresh_pos):\n            self._times_past_position_limit += 1\n\n        # current is basically the same as position, but if you instantly\n        # command a switch it can actually change fast enough\n        # to throw this off, so that is accounted for too. We just put a hard limit on the current\n        # to solve current jitter problems.\n        if (thresh_curr &lt;= new_curr and new_curr &lt;= I_max) and (-I_max &lt;= old_curr and old_curr &lt;= -thresh_curr):\n            # self._old_current_zone = -1\n            # if (thresh_curr &lt;= curr_command and curr_command &lt;= I_max):\n            #     self._times_past_current_limit -= 1\n            if curr_command &gt; 0:\n                actual_current = self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n            elif curr_command &lt; 0:\n                actual_current = -self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n            else:\n                actual_current = -self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n            new_curr = actual_current\n        elif (thresh_curr &lt;= old_curr and old_curr &lt;= I_max) and (-I_max &lt;= new_curr and new_curr &lt;= -thresh_curr):\n            # self._old_current_zone = 1\n            # if not (-I_max &lt;= curr_command and curr_command &lt;= -thresh_curr):\n            #     self._times_past_current_limit += 1\n            if curr_command &gt; 0:\n                actual_current = self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n            elif curr_command &lt; 0:\n                actual_current = -self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n            else:\n                actual_current = self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n            new_curr = actual_current\n\n        # velocity should work the same as position\n        if (thresh_vel &lt;= new_vel and new_vel &lt;= V_max) and (-V_max &lt;= old_vel and old_vel &lt;= -thresh_vel):\n            self._times_past_velocity_limit -= 1\n        elif (thresh_vel &lt;= old_vel and old_vel &lt;= V_max) and (-V_max &lt;= new_vel and new_vel &lt;= -thresh_vel):\n            self._times_past_velocity_limit += 1\n\n        # update expanded state variables\n        self._old_pos = new_pos\n        self._old_curr = new_curr\n        self._old_vel = new_vel\n\n        self._motor_state.set_state_obj(self._motor_state_async)\n        self._motor_state.position += self._times_past_position_limit * 2 * MIT_Params[self.type][\"P_max\"]\n        self._motor_state.current = actual_current\n        self._motor_state.velocity += self._times_past_velocity_limit * 2 * MIT_Params[self.type][\"V_max\"]\n\n        # send current motor command\n        self._send_command()\n        self._updated = False\n\n    # sends a command to the motor depending on whats controlm mode the motor is in\n    def _send_command(self):\n        \"\"\"\n        Sends a command to the motor depending on whats controlm mode the motor is in. This method\n        is called by update(), and should only be called on its own if you don't want to update the motor state info.\n\n        Notably, the current is converted to amps from the reported 'torque' value, which is i*Kt.\n        This allows control based on actual q-axis current, rather than estimated torque, which\n        doesn't account for friction losses.\n        \"\"\"\n        if self.mode == CONTROL_MODES.IMPEDANCE:\n            self._canman.MIT_controller(\n                self.ID,\n                self.type,\n                self._command.position,\n                self._command.velocity,\n                self._command.kp,\n                self._command.kd,\n                0.0,\n            )\n        elif self.mode == CONTROL_MODES.CURRENT:\n            self._canman.MIT_controller(\n                self.ID,\n                self.type,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                self.qaxis_current_to_TMotor_current(self._command.current),\n            )\n        elif self.mode == CONTROL_MODES.IDLE:\n            self._canman.MIT_controller(self.ID, self.type, 0.0, 0.0, 0.0, 0.0, 0.0)\n        elif self.mode == CONTROL_MODES.VELOCITY:\n            self._canman.MIT_controller(\n                self.ID,\n                self.type,\n                0.0,\n                self._command.velocity,\n                0.0,\n                self._command.kd,\n                0.0,\n            )\n        else:\n            raise RuntimeError(\"UNDEFINED STATE for device \" + self.device_info_string())\n        self._last_command_time = time.time()\n\n    # getters for motor state\n    @property\n    def case_temperature(self) -&gt; float:\n        \"\"\"\n        Returns:\n        The most recently updated motor temperature in degrees C.\n        \"\"\"\n        return float(self._motor_state.temperature)\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.T_w)\n        else:\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        \"\"\"\n        Returns:\n        The most recently updated qaxis current in amps\n        \"\"\"\n        return float(self._motor_state.current)\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        # Not implemented\n        return 0.0\n\n    @property\n    def output_position(self) -&gt; float:\n        \"\"\"\n        Returns:\n        The most recently updated output angle in radians\n        \"\"\"\n        return float(self._motor_state.position)\n\n    @property\n    def output_velocity(self) -&gt; float:\n        \"\"\"\n        Returns:\n            The most recently updated output velocity in radians per second\n        \"\"\"\n        return float(self._motor_state.velocity)\n\n    @property\n    def output_acceleration(self) -&gt; float:\n        \"\"\"\n        Returns:\n            The most recently updated output acceleration in radians per second per second\n        \"\"\"\n        return float(self._motor_state.acceleration)\n\n    @property\n    def output_torque(self) -&gt; float:\n        \"\"\"\n        Returns:\n            the most recently updated output torque in Nm\n        \"\"\"\n        return float(self.motor_current * MIT_Params[self.type][\"Kt_actual\"] * MIT_Params[self.type][\"GEAR_RATIO\"])\n\n    # uses plain impedance mode, will send 0.0 for current command.\n    def set_impedance_gains(\n        self,\n        kp: float = 0,\n        ki: float = 0,\n        K: float = 0.08922,\n        B: float = 0.0038070,\n        ff: float = 0,\n    ) -&gt; None:\n        \"\"\"\n        Uses plain impedance mode, will send 0.0 for current command in addition to position request.\n\n        Args:\n            kp: A dummy argument for backward compatibility with the dephy library.\n            ki: A dummy argument for backward compatibility with the dephy library.\n            K: The stiffness in Nm/rad\n            B: The damping in Nm/(rad/s)\n            ff: A dummy argument for backward compatibility with the dephy library.\n        \"\"\"\n        if not (isfinite(K) and MIT_Params[self.type][\"Kp_min\"] &lt;= K and MIT_Params[self.type][\"Kp_max\"] &gt;= K):\n            raise ValueError(\n                f\"K must be finite and between \\\n                {MIT_Params[self.type]['Kp_min']} and {MIT_Params[self.type]['Kp_max']}\"\n            )\n\n        if not (isfinite(B) and MIT_Params[self.type][\"Kd_min\"] &lt;= B and MIT_Params[self.type][\"Kd_max\"] &gt;= B):\n            raise ValueError(\n                f\"B must be finite and between \\\n                {MIT_Params[self.type]['Kd_min']} and {MIT_Params[self.type]['Kd_max']}\"\n            )\n\n        self._command.kp = K\n        self._command.kd = B\n        self._command.velocity = 0.0\n\n    def set_current_gains(\n        self,\n        kp: float = 40,\n        ki: float = 400,\n        ff: float = 128,\n        spoof: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Uses plain current mode, will send 0.0 for position gains in addition to requested current.\n\n        Args:\n            kp: A dummy argument for backward compatibility with the dephy library.\n            ki: A dummy argument for backward compatibility with the dephy library.\n            ff: A dummy argument for backward compatibility with the dephy library.\n            spoof: A dummy argument for backward compatibility with the dephy library.\n        \"\"\"\n        pass\n\n    def set_velocity_gains(\n        self,\n        kd: float = 1.0,\n    ) -&gt; None:\n        \"\"\"\n        Uses plain speed mode, will send 0.0 for position gain and for feed forward current.\n\n        Args:\n            kd: The gain for the speed controller. Control law will be (v_des - v_actual)*kd = iq\n        \"\"\"\n        self._command.kd = kd\n\n    def set_position_gains(self) -&gt; None:\n        # Not implemented\n        pass\n\n    # used for either impedance or MIT mode to set output angle\n    def set_output_position(self, value: float) -&gt; None:\n        \"\"\"\n        Used for either impedance or full state feedback mode to set output angle command.\n        Note, this does not send a command, it updates the TMotorManager's saved command,\n        which will be sent when update() is called.\n\n        Args:\n            value: The desired output position in rads\n\n        Raises:\n            RuntimeError: If the position command is outside the range of the motor.\n        \"\"\"\n        if np.abs(value) &gt;= MIT_Params[self.type][\"P_max\"]:\n            raise RuntimeError(\n                \"Cannot control using impedance mode for angles with magnitude greater than \"\n                + str(MIT_Params[self.type][\"P_max\"])\n                + \"rad!\"\n            )\n\n        self._command.position = value\n\n    def set_output_velocity(self, value: float) -&gt; None:\n        \"\"\"\n        Used for either speed or full state feedback mode to set output velocity command.\n        Note, this does not send a command, it updates the TMotorManager's saved command,\n        which will be sent when update() is called.\n\n        Args:\n            value: The desired output speed in rad/s\n\n        Raises:\n            RuntimeError: If the velocity command is outside the range of the motor.\n        \"\"\"\n        if np.abs(value) &gt;= MIT_Params[self.type][\"V_max\"]:\n            raise RuntimeError(\n                \"Cannot control using speed mode for angles with magnitude greater than \"\n                + str(MIT_Params[self.type][\"V_max\"])\n                + \"rad/s!\"\n            )\n\n        self._command.velocity = value\n\n    # used for either current MIT mode to set current\n\n    def set_motor_current(self, value: float) -&gt; None:\n        \"\"\"\n        Used for either current or full state feedback mode to set current command.\n        Note, this does not send a command, it updates the TMotorManager's saved command,\n        which will be sent when update() is called.\n\n        Args:\n            value: the desired current in amps.\n        \"\"\"\n        self._command.current = value\n\n    # used for either current or MIT Mode to set current, based on desired torque\n    def set_joint_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Used for either current or MIT Mode to set current, based on desired torque.\n        If a more complicated torque model is available for the motor, that will be used.\n        Otherwise it will just use the motor's torque constant.\n\n        Args:\n            value: The desired output torque in Nm.\n        \"\"\"\n        self.set_motor_current(value / MIT_Params[self.type][\"Kt_actual\"] / MIT_Params[self.type][\"GEAR_RATIO\"])\n\n    # motor-side functions to account for the gear ratio\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Version of set_output_torque that accounts for gear ratio to control motor-side torque\n\n        Args:\n            value: The desired motor torque in Nm.\n        \"\"\"\n        self.set_output_torque(value * MIT_Params[self.type][\"Kt_actual\"])\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Wrapper for set_output_angle that accounts for gear ratio to control motor-side angle\n\n        Args:\n            value: The desired motor position in rad.\n        \"\"\"\n        self.set_output_position(value / (MIT_Params[self.type][\"GEAR_RATIO\"]))\n\n    def set_motor_velocity(self, value: float) -&gt; None:\n        \"\"\"\n        Wrapper for set_output_velocity that accounts for gear ratio to control motor-side velocity\n\n        Args:\n            value: The desired motor velocity in rad/s.\n        \"\"\"\n        self.set_output_velocity(value / (MIT_Params[self.type][\"GEAR_RATIO\"]))\n\n    def set_motor_voltage(self, value: float) -&gt; float:\n        # Not implemented\n        pass\n\n    @property\n    def motor_position(self) -&gt; float:\n        \"\"\"\n        Wrapper for get_output_angle that accounts for gear ratio to get motor-side angle\n\n        Returns:\n            The most recently updated motor-side angle in rad.\n        \"\"\"\n        return float(self._motor_state.position * MIT_Params[self.type][\"GEAR_RATIO\"])\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        \"\"\"\n        Wrapper for get_output_velocity that accounts for gear ratio to get motor-side velocity\n\n        Returns:\n            The most recently updated motor-side velocity in rad/s.\n        \"\"\"\n        return float(self._motor_state.velocity * MIT_Params[self.type][\"GEAR_RATIO\"])\n\n    @property\n    def motor_acceleration(self) -&gt; float:\n        \"\"\"\n        Wrapper for get_output_acceleration that accounts for gear ratio to get motor-side acceleration\n\n        Returns:\n            The most recently updated motor-side acceleration in rad/s/s.\n        \"\"\"\n        return float(self._motor_state.acceleration * MIT_Params[self.type][\"GEAR_RATIO\"])\n\n    @property\n    def motor_torque(self) -&gt; float:\n        \"\"\"\n        Wrapper for get_output_torque that accounts for gear ratio to get motor-side torque\n\n        Returns:\n            The most recently updated motor-side torque in Nm.\n        \"\"\"\n        return float(self.output_torque * MIT_Params[self.type][\"GEAR_RATIO\"])\n\n    # Pretty stuff\n    def __str__(self) -&gt; str:\n        \"\"\"Prints the motor's device info and current\"\"\"\n        return (\n            self.device_info_string()\n            + \" | Position: \"\n            + f\"{round(self.output_angle, 3): 1f}\"\n            + \" rad | Velocity: \"\n            + f\"{round(self.output_velocity, 3): 1f}\"\n            + \" rad/s | current: \"\n            + f\"{round(self.motor_current, 3): 1f}\"\n            + \" A | torque: \"\n            + f\"{round(self.output_torque, 3): 1f}\"\n            + \" Nm\"\n        )\n\n    # Checks the motor connection by sending a 10 commands and making sure the motor responds.\n    def check_can_connection(self) -&gt; bool:\n        \"\"\"\n        Checks the motor's connection by attempting to send 10 startup messages.\n        If it gets 10 replies, then the connection is confirmed.\n\n        Returns:\n            True if a connection is established and False otherwise.\n\n        Raises:\n            RuntimeError: If the motor control has not been entered.\n        \"\"\"\n        if not self._entered:\n            raise RuntimeError(\n                \"Tried to check_can_connection before entering motor control! \\\n                Enter control using the __enter__ method, or instantiating the TMotorManager in a with block.\"\n            )\n        Listener = can.BufferedReader()\n        self._canman.notifier.add_listener(Listener)\n        for _i in range(10):\n            self.power_on()\n            time.sleep(0.001)\n        success = True\n        self._is_open = True\n        time.sleep(0.1)\n        for _i in range(10):\n            if Listener.get_message(timeout=0.1) is None:\n                success = False\n                self._is_open = False\n        self._canman.notifier.remove_listener(Listener)\n        return success\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.case_temperature","title":"<code>case_temperature: float</code>  <code>property</code>","text":"<p>Returns: The most recently updated motor temperature in degrees C.</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.motor_acceleration","title":"<code>motor_acceleration: float</code>  <code>property</code>","text":"<p>Wrapper for get_output_acceleration that accounts for gear ratio to get motor-side acceleration</p> <p>Returns:</p> Type Description <code>float</code> <p>The most recently updated motor-side acceleration in rad/s/s.</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.motor_current","title":"<code>motor_current: float</code>  <code>property</code>","text":"<p>Returns: The most recently updated qaxis current in amps</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.motor_position","title":"<code>motor_position: float</code>  <code>property</code>","text":"<p>Wrapper for get_output_angle that accounts for gear ratio to get motor-side angle</p> <p>Returns:</p> Type Description <code>float</code> <p>The most recently updated motor-side angle in rad.</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.motor_torque","title":"<code>motor_torque: float</code>  <code>property</code>","text":"<p>Wrapper for get_output_torque that accounts for gear ratio to get motor-side torque</p> <p>Returns:</p> Type Description <code>float</code> <p>The most recently updated motor-side torque in Nm.</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.motor_velocity","title":"<code>motor_velocity: float</code>  <code>property</code>","text":"<p>Wrapper for get_output_velocity that accounts for gear ratio to get motor-side velocity</p> <p>Returns:</p> Type Description <code>float</code> <p>The most recently updated motor-side velocity in rad/s.</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.output_acceleration","title":"<code>output_acceleration: float</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The most recently updated output acceleration in radians per second per second</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.output_position","title":"<code>output_position: float</code>  <code>property</code>","text":"<p>Returns: The most recently updated output angle in radians</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.output_torque","title":"<code>output_torque: float</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>the most recently updated output torque in Nm</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.output_velocity","title":"<code>output_velocity: float</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The most recently updated output velocity in radians per second</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.winding_temperature","title":"<code>winding_temperature: float</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.__init__","title":"<code>__init__(tag='TMotorActuator', motor_type='AK80-9', motor_ID=41, gear_ratio=1.0, frequency=500, offline=False, max_mosfett_temp=50)</code>","text":"<p>Sets up the motor manager. Note the device will not be powered on by this method! You must call enter, mostly commonly by using a with block, before attempting to control the motor.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>A string tag to identify the motor</p> <code>'TMotorActuator'</code> <code>motor_type</code> <code>str</code> <p>The type of motor to control. Must be a key in MIT_Params.</p> <code>'AK80-9'</code> <code>motor_ID</code> <code>int</code> <p>The ID of the motor to control.</p> <code>41</code> <code>gear_ratio</code> <code>float</code> <p>The gear ratio of the motor. Default is 1.0.</p> <code>1.0</code> <code>frequency</code> <code>int</code> <p>The frequency at which to send commands to the motor. Default is 500.</p> <code>500</code> <code>offline</code> <code>bool</code> <p>Whether to run the motor in offline mode. Default is False.</p> <code>False</code> <code>max_mosfett_temp</code> <code>float</code> <p>The maximum temperature of the mosfet in degrees C. Default is 50.</p> <code>50</code> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"TMotorActuator\",\n    motor_type: str = \"AK80-9\",\n    motor_ID: int = 41,\n    gear_ratio: float = 1.0,\n    frequency: int = 500,\n    offline: bool = False,\n    max_mosfett_temp: float = 50,\n):\n    \"\"\"\n    Sets up the motor manager. Note the device will not be powered on by this method! You must\n    call __enter__, mostly commonly by using a with block, before attempting to control the motor.\n\n    Args:\n        tag: A string tag to identify the motor\n        motor_type: The type of motor to control. Must be a key in MIT_Params.\n        motor_ID: The ID of the motor to control.\n        gear_ratio: The gear ratio of the motor. Default is 1.0.\n        frequency: The frequency at which to send commands to the motor. Default is 500.\n        offline: Whether to run the motor in offline mode. Default is False.\n        max_mosfett_temp: The maximum temperature of the mosfet in degrees C. Default is 50.\n    \"\"\"\n    ActuatorBase.__init__(\n        self,\n        tag=tag,\n        gear_ratio=gear_ratio,\n        motor_constants=TMOTOR_ACTUATOR_CONSTANTS,\n        frequency=frequency,\n        offline=offline,\n    )\n    TMotorManager_mit_can.__init__(\n        self,\n        motor_type=motor_type,\n        motor_ID=motor_ID,\n        max_mosfett_temp=max_mosfett_temp,\n    )\n    self.type = motor_type\n    self.ID = motor_ID\n    # self.csv_file_name = CSV_file\n    print(\"Initializing device: \" + self.device_info_string())\n\n    self._motor_state = motor_state(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n    self._motor_state_async = motor_state(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n    self._command = MIT_command(0.0, 0.0, 0.0, 0.0, 0.0)\n    # self._control_state = _TMotorManState.IDLE\n    self._times_past_position_limit = 0\n    self._times_past_current_limit = 0\n    self._times_past_velocity_limit = 0\n    self._angle_threshold = (\n        MIT_Params[self.type][\"P_max\"] - 2.0\n    )  # radians, only really matters if the motor's going super fast\n    self._current_threshold = (\n        self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"]) - 3.0\n    )  # A, only really matters if the current changes quick\n    self._velocity_threshold = (\n        MIT_Params[self.type][\"V_max\"] - 2.0\n    )  # radians, only really matters if the motor's going super fast\n    self._old_pos = None\n    self._old_curr = 0.0\n    self._old_vel = 0.0\n    self._old_current_zone = 0\n    self.max_temp = max_mosfett_temp  # max temp in deg C, can update later\n\n    self._entered = False\n    self._start_time = time.time()\n    self._last_update_time = self._start_time\n    self._last_command_time = None\n    self._updated = False\n    self.SF = 1.0\n\n    self._thermal_model: ThermalModel = ThermalModel(\n        temp_limit_windings=self.max_winding_temperature,\n        soft_border_C_windings=10,\n        temp_limit_case=self.max_case_temperature,\n        soft_border_C_case=10,\n    )\n    self._thermal_scale: float = 1.0\n\n    self._canman = CAN_Manager()\n    self._canman.add_motor(self)\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.__str__","title":"<code>__str__()</code>","text":"<p>Prints the motor's device info and current</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Prints the motor's device info and current\"\"\"\n    return (\n        self.device_info_string()\n        + \" | Position: \"\n        + f\"{round(self.output_angle, 3): 1f}\"\n        + \" rad | Velocity: \"\n        + f\"{round(self.output_velocity, 3): 1f}\"\n        + \" rad/s | current: \"\n        + f\"{round(self.motor_current, 3): 1f}\"\n        + \" A | torque: \"\n        + f\"{round(self.output_torque, 3): 1f}\"\n        + \" Nm\"\n    )\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.check_can_connection","title":"<code>check_can_connection()</code>","text":"<p>Checks the motor's connection by attempting to send 10 startup messages. If it gets 10 replies, then the connection is confirmed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if a connection is established and False otherwise.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the motor control has not been entered.</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def check_can_connection(self) -&gt; bool:\n    \"\"\"\n    Checks the motor's connection by attempting to send 10 startup messages.\n    If it gets 10 replies, then the connection is confirmed.\n\n    Returns:\n        True if a connection is established and False otherwise.\n\n    Raises:\n        RuntimeError: If the motor control has not been entered.\n    \"\"\"\n    if not self._entered:\n        raise RuntimeError(\n            \"Tried to check_can_connection before entering motor control! \\\n            Enter control using the __enter__ method, or instantiating the TMotorManager in a with block.\"\n        )\n    Listener = can.BufferedReader()\n    self._canman.notifier.add_listener(Listener)\n    for _i in range(10):\n        self.power_on()\n        time.sleep(0.001)\n    success = True\n    self._is_open = True\n    time.sleep(0.1)\n    for _i in range(10):\n        if Listener.get_message(timeout=0.1) is None:\n            success = False\n            self._is_open = False\n    self._canman.notifier.remove_listener(Listener)\n    return success\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_current_gains","title":"<code>set_current_gains(kp=40, ki=400, ff=128, spoof=False)</code>","text":"<p>Uses plain current mode, will send 0.0 for position gains in addition to requested current.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>A dummy argument for backward compatibility with the dephy library.</p> <code>40</code> <code>ki</code> <code>float</code> <p>A dummy argument for backward compatibility with the dephy library.</p> <code>400</code> <code>ff</code> <code>float</code> <p>A dummy argument for backward compatibility with the dephy library.</p> <code>128</code> <code>spoof</code> <code>bool</code> <p>A dummy argument for backward compatibility with the dephy library.</p> <code>False</code> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_current_gains(\n    self,\n    kp: float = 40,\n    ki: float = 400,\n    ff: float = 128,\n    spoof: bool = False,\n) -&gt; None:\n    \"\"\"\n    Uses plain current mode, will send 0.0 for position gains in addition to requested current.\n\n    Args:\n        kp: A dummy argument for backward compatibility with the dephy library.\n        ki: A dummy argument for backward compatibility with the dephy library.\n        ff: A dummy argument for backward compatibility with the dephy library.\n        spoof: A dummy argument for backward compatibility with the dephy library.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_impedance_gains","title":"<code>set_impedance_gains(kp=0, ki=0, K=0.08922, B=0.003807, ff=0)</code>","text":"<p>Uses plain impedance mode, will send 0.0 for current command in addition to position request.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>A dummy argument for backward compatibility with the dephy library.</p> <code>0</code> <code>ki</code> <code>float</code> <p>A dummy argument for backward compatibility with the dephy library.</p> <code>0</code> <code>K</code> <code>float</code> <p>The stiffness in Nm/rad</p> <code>0.08922</code> <code>B</code> <code>float</code> <p>The damping in Nm/(rad/s)</p> <code>0.003807</code> <code>ff</code> <code>float</code> <p>A dummy argument for backward compatibility with the dephy library.</p> <code>0</code> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_impedance_gains(\n    self,\n    kp: float = 0,\n    ki: float = 0,\n    K: float = 0.08922,\n    B: float = 0.0038070,\n    ff: float = 0,\n) -&gt; None:\n    \"\"\"\n    Uses plain impedance mode, will send 0.0 for current command in addition to position request.\n\n    Args:\n        kp: A dummy argument for backward compatibility with the dephy library.\n        ki: A dummy argument for backward compatibility with the dephy library.\n        K: The stiffness in Nm/rad\n        B: The damping in Nm/(rad/s)\n        ff: A dummy argument for backward compatibility with the dephy library.\n    \"\"\"\n    if not (isfinite(K) and MIT_Params[self.type][\"Kp_min\"] &lt;= K and MIT_Params[self.type][\"Kp_max\"] &gt;= K):\n        raise ValueError(\n            f\"K must be finite and between \\\n            {MIT_Params[self.type]['Kp_min']} and {MIT_Params[self.type]['Kp_max']}\"\n        )\n\n    if not (isfinite(B) and MIT_Params[self.type][\"Kd_min\"] &lt;= B and MIT_Params[self.type][\"Kd_max\"] &gt;= B):\n        raise ValueError(\n            f\"B must be finite and between \\\n            {MIT_Params[self.type]['Kd_min']} and {MIT_Params[self.type]['Kd_max']}\"\n        )\n\n    self._command.kp = K\n    self._command.kd = B\n    self._command.velocity = 0.0\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_joint_torque","title":"<code>set_joint_torque(value)</code>","text":"<p>Used for either current or MIT Mode to set current, based on desired torque. If a more complicated torque model is available for the motor, that will be used. Otherwise it will just use the motor's torque constant.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The desired output torque in Nm.</p> required Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_joint_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Used for either current or MIT Mode to set current, based on desired torque.\n    If a more complicated torque model is available for the motor, that will be used.\n    Otherwise it will just use the motor's torque constant.\n\n    Args:\n        value: The desired output torque in Nm.\n    \"\"\"\n    self.set_motor_current(value / MIT_Params[self.type][\"Kt_actual\"] / MIT_Params[self.type][\"GEAR_RATIO\"])\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_motor_current","title":"<code>set_motor_current(value)</code>","text":"<p>Used for either current or full state feedback mode to set current command. Note, this does not send a command, it updates the TMotorManager's saved command, which will be sent when update() is called.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>the desired current in amps.</p> required Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_current(self, value: float) -&gt; None:\n    \"\"\"\n    Used for either current or full state feedback mode to set current command.\n    Note, this does not send a command, it updates the TMotorManager's saved command,\n    which will be sent when update() is called.\n\n    Args:\n        value: the desired current in amps.\n    \"\"\"\n    self._command.current = value\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Wrapper for set_output_angle that accounts for gear ratio to control motor-side angle</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The desired motor position in rad.</p> required Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Wrapper for set_output_angle that accounts for gear ratio to control motor-side angle\n\n    Args:\n        value: The desired motor position in rad.\n    \"\"\"\n    self.set_output_position(value / (MIT_Params[self.type][\"GEAR_RATIO\"]))\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_motor_torque","title":"<code>set_motor_torque(value)</code>","text":"<p>Version of set_output_torque that accounts for gear ratio to control motor-side torque</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The desired motor torque in Nm.</p> required Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Version of set_output_torque that accounts for gear ratio to control motor-side torque\n\n    Args:\n        value: The desired motor torque in Nm.\n    \"\"\"\n    self.set_output_torque(value * MIT_Params[self.type][\"Kt_actual\"])\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_motor_velocity","title":"<code>set_motor_velocity(value)</code>","text":"<p>Wrapper for set_output_velocity that accounts for gear ratio to control motor-side velocity</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The desired motor velocity in rad/s.</p> required Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_velocity(self, value: float) -&gt; None:\n    \"\"\"\n    Wrapper for set_output_velocity that accounts for gear ratio to control motor-side velocity\n\n    Args:\n        value: The desired motor velocity in rad/s.\n    \"\"\"\n    self.set_output_velocity(value / (MIT_Params[self.type][\"GEAR_RATIO\"]))\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_output_position","title":"<code>set_output_position(value)</code>","text":"<p>Used for either impedance or full state feedback mode to set output angle command. Note, this does not send a command, it updates the TMotorManager's saved command, which will be sent when update() is called.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The desired output position in rads</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the position command is outside the range of the motor.</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_output_position(self, value: float) -&gt; None:\n    \"\"\"\n    Used for either impedance or full state feedback mode to set output angle command.\n    Note, this does not send a command, it updates the TMotorManager's saved command,\n    which will be sent when update() is called.\n\n    Args:\n        value: The desired output position in rads\n\n    Raises:\n        RuntimeError: If the position command is outside the range of the motor.\n    \"\"\"\n    if np.abs(value) &gt;= MIT_Params[self.type][\"P_max\"]:\n        raise RuntimeError(\n            \"Cannot control using impedance mode for angles with magnitude greater than \"\n            + str(MIT_Params[self.type][\"P_max\"])\n            + \"rad!\"\n        )\n\n    self._command.position = value\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_output_velocity","title":"<code>set_output_velocity(value)</code>","text":"<p>Used for either speed or full state feedback mode to set output velocity command. Note, this does not send a command, it updates the TMotorManager's saved command, which will be sent when update() is called.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The desired output speed in rad/s</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the velocity command is outside the range of the motor.</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_output_velocity(self, value: float) -&gt; None:\n    \"\"\"\n    Used for either speed or full state feedback mode to set output velocity command.\n    Note, this does not send a command, it updates the TMotorManager's saved command,\n    which will be sent when update() is called.\n\n    Args:\n        value: The desired output speed in rad/s\n\n    Raises:\n        RuntimeError: If the velocity command is outside the range of the motor.\n    \"\"\"\n    if np.abs(value) &gt;= MIT_Params[self.type][\"V_max\"]:\n        raise RuntimeError(\n            \"Cannot control using speed mode for angles with magnitude greater than \"\n            + str(MIT_Params[self.type][\"V_max\"])\n            + \"rad/s!\"\n        )\n\n    self._command.velocity = value\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.set_velocity_gains","title":"<code>set_velocity_gains(kd=1.0)</code>","text":"<p>Uses plain speed mode, will send 0.0 for position gain and for feed forward current.</p> <p>Parameters:</p> Name Type Description Default <code>kd</code> <code>float</code> <p>The gain for the speed controller. Control law will be (v_des - v_actual)*kd = iq</p> <code>1.0</code> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_velocity_gains(\n    self,\n    kd: float = 1.0,\n) -&gt; None:\n    \"\"\"\n    Uses plain speed mode, will send 0.0 for position gain and for feed forward current.\n\n    Args:\n        kd: The gain for the speed controller. Control law will be (v_des - v_actual)*kd = iq\n    \"\"\"\n    self._command.kd = kd\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.start","title":"<code>start()</code>","text":"<p>Used to safely power the motor on and begin the log file (if specified).</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>@check_actuator_connection\ndef start(self):\n    \"\"\"\n    Used to safely power the motor on and begin the log file (if specified).\n    \"\"\"\n    print(\"Turning on control for device: \" + self.device_info_string())\n\n    self.power_on()\n    self._send_command()\n    self._entered = True\n    self.is_streaming = True\n    if not self.check_can_connection():\n        raise RuntimeError(\"Device not connected: \" + str(self.device_info_string()))\n    return self\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.stop","title":"<code>stop()</code>","text":"<p>Used to safely power the motor off and close the log file (if specified).</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>@check_actuator_stream\n@check_actuator_open\ndef stop(self):\n    \"\"\"\n    Used to safely power the motor off and close the log file (if specified).\n    \"\"\"\n    print(\"Turning off control for device: \" + self.device_info_string())\n    self.power_off()\n</code></pre>"},{"location":"modules/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorMITCANActuator.update","title":"<code>update()</code>","text":"<p>This method is called by the user to synchronize the current state used by the controller with the most recent message recieved, as well as to send the current command.</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def update(self):  # noqa: C901\n    \"\"\"\n    This method is called by the user to synchronize the current state used by the controller\n    with the most recent message recieved, as well as to send the current command.\n    \"\"\"\n\n    # check that the motor is safely turned on\n    if not self._entered:\n        raise RuntimeError(\n            \"Tried to update motor state before safely powering on for device: \" + self.device_info_string()\n        )\n\n    if self.case_temperature &gt; self.max_temp:\n        raise RuntimeError(f\"Temperature greater than {self.max_temp}C for device: {self.device_info_string()}\")\n\n    # check that the motor data is recent\n    # print(self._command_sent)\n    now = time.time()\n    if (now - self._last_command_time) &lt; 0.25 and ((now - self._last_update_time) &gt; 0.1):\n        warnings.warn(\n            \"State update requested but no data from motor. Delay longer after zeroing, \\\n            decrease frequency, or check connection. \"\n            + self.device_info_string(),\n            RuntimeWarning,\n            stacklevel=2,\n        )\n    else:\n        self._command_sent = False\n\n    # artificially extending the range of the position, current, and velocity that we track\n    P_max = MIT_Params[self.type][\"P_max\"] + 0.01\n    I_max = self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"]) + 1.0\n    V_max = MIT_Params[self.type][\"V_max\"] + 0.01\n\n    if self._old_pos is None:\n        self._old_pos = self._motor_state_async.position\n    old_pos = self._old_pos\n    old_curr = self._old_curr\n    old_vel = self._old_vel\n\n    new_pos = self._motor_state_async.position\n    new_curr = self._motor_state_async.current\n    new_vel = self._motor_state_async.velocity\n\n    thresh_pos = self._angle_threshold\n    thresh_curr = self._current_threshold\n    thresh_vel = self._velocity_threshold\n\n    curr_command = self._command.current\n\n    actual_current = new_curr\n\n    # The TMotor will wrap around to -max at the limits for all values it returns!! Account for this\n    if (thresh_pos &lt;= new_pos and new_pos &lt;= P_max) and (-P_max &lt;= old_pos and old_pos &lt;= -thresh_pos):\n        self._times_past_position_limit -= 1\n    elif (thresh_pos &lt;= old_pos and old_pos &lt;= P_max) and (-P_max &lt;= new_pos and new_pos &lt;= -thresh_pos):\n        self._times_past_position_limit += 1\n\n    # current is basically the same as position, but if you instantly\n    # command a switch it can actually change fast enough\n    # to throw this off, so that is accounted for too. We just put a hard limit on the current\n    # to solve current jitter problems.\n    if (thresh_curr &lt;= new_curr and new_curr &lt;= I_max) and (-I_max &lt;= old_curr and old_curr &lt;= -thresh_curr):\n        # self._old_current_zone = -1\n        # if (thresh_curr &lt;= curr_command and curr_command &lt;= I_max):\n        #     self._times_past_current_limit -= 1\n        if curr_command &gt; 0:\n            actual_current = self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n        elif curr_command &lt; 0:\n            actual_current = -self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n        else:\n            actual_current = -self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n        new_curr = actual_current\n    elif (thresh_curr &lt;= old_curr and old_curr &lt;= I_max) and (-I_max &lt;= new_curr and new_curr &lt;= -thresh_curr):\n        # self._old_current_zone = 1\n        # if not (-I_max &lt;= curr_command and curr_command &lt;= -thresh_curr):\n        #     self._times_past_current_limit += 1\n        if curr_command &gt; 0:\n            actual_current = self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n        elif curr_command &lt; 0:\n            actual_current = -self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n        else:\n            actual_current = self.TMotor_current_to_qaxis_current(MIT_Params[self.type][\"T_max\"])\n        new_curr = actual_current\n\n    # velocity should work the same as position\n    if (thresh_vel &lt;= new_vel and new_vel &lt;= V_max) and (-V_max &lt;= old_vel and old_vel &lt;= -thresh_vel):\n        self._times_past_velocity_limit -= 1\n    elif (thresh_vel &lt;= old_vel and old_vel &lt;= V_max) and (-V_max &lt;= new_vel and new_vel &lt;= -thresh_vel):\n        self._times_past_velocity_limit += 1\n\n    # update expanded state variables\n    self._old_pos = new_pos\n    self._old_curr = new_curr\n    self._old_vel = new_vel\n\n    self._motor_state.set_state_obj(self._motor_state_async)\n    self._motor_state.position += self._times_past_position_limit * 2 * MIT_Params[self.type][\"P_max\"]\n    self._motor_state.current = actual_current\n    self._motor_state.velocity += self._times_past_velocity_limit * 2 * MIT_Params[self.type][\"V_max\"]\n\n    # send current motor command\n    self._send_command()\n    self._updated = False\n</code></pre>"},{"location":"modules/collections/validators/","title":"Validators","text":"<p>Module for attribute validation using descriptor classes.</p> <p>This module provides an abstract base class <code>Validator</code> for creating attribute validators that can be used as descriptors. It also includes a concrete implementation, <code>Number</code>, which validates that a given value is a number (int or float) and optionally enforces minimum and/or maximum limits.</p>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Gains","title":"<code>Gains</code>","text":"<p>Example class using the Number validator to validate gain values.</p> <p>The attribute 'kp' is validated to ensure it is a number between 0 and 100.</p> Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>class Gains:\n    \"\"\"\n    Example class using the Number validator to validate gain values.\n\n    The attribute 'kp' is validated to ensure it is a number between 0 and 100.\n    \"\"\"\n\n    kp = Number(0, 100)\n\n    def __init__(self, kp_value: int) -&gt; None:\n        \"\"\"\n        Initialize the Gains instance.\n\n        Args:\n            kp_value: The gain value to be validated and assigned to 'kp'.\n        \"\"\"\n        self.kp = kp_value\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Gains.__init__","title":"<code>__init__(kp_value)</code>","text":"<p>Initialize the Gains instance.</p> <p>Parameters:</p> Name Type Description Default <code>kp_value</code> <code>int</code> <p>The gain value to be validated and assigned to 'kp'.</p> required Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>def __init__(self, kp_value: int) -&gt; None:\n    \"\"\"\n    Initialize the Gains instance.\n\n    Args:\n        kp_value: The gain value to be validated and assigned to 'kp'.\n    \"\"\"\n    self.kp = kp_value\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Number","title":"<code>Number</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for numerical values.</p> <p>Ensures that the value is an integer or a float and optionally enforces a minimum and/or maximum limit.</p> Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>class Number(Validator):\n    \"\"\"\n    Validator for numerical values.\n\n    Ensures that the value is an integer or a float and optionally enforces a minimum\n    and/or maximum limit.\n    \"\"\"\n\n    def __init__(\n        self,\n        min_value: Optional[Union[int, float]] = None,\n        max_value: Optional[Union[int, float]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Number validator.\n\n        Args:\n            min_value: The minimum acceptable value (inclusive).\n                Defaults to None, meaning no lower bound.\n            max_value: The maximum acceptable value (inclusive).\n                Defaults to None, meaning no upper bound.\n        \"\"\"\n        self.min_value: Optional[Union[int, float]] = min_value\n        self.max_value: Optional[Union[int, float]] = max_value\n\n    def validate(self, value: Union[int, float]) -&gt; None:\n        \"\"\"\n        Validate that the value is a number and within the specified range.\n\n        Args:\n            value: The number to validate.\n\n        Raises:\n            TypeError: If the value is not an int or float.\n            ValueError: If the value is less than min_value or greater than max_value.\n        \"\"\"\n        if not isinstance(value, (int, float)):\n            raise TypeError(\"Value must be an int or float\")\n\n        if self.min_value is not None and value &lt; self.min_value:\n            raise ValueError(f\"Value must be at least {self.min_value}\")\n\n        if self.max_value is not None and value &gt; self.max_value:\n            raise ValueError(f\"Value must be at most {self.max_value}\")\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Number.__init__","title":"<code>__init__(min_value=None, max_value=None)</code>","text":"<p>Initialize the Number validator.</p> <p>Parameters:</p> Name Type Description Default <code>min_value</code> <code>Optional[Union[int, float]]</code> <p>The minimum acceptable value (inclusive). Defaults to None, meaning no lower bound.</p> <code>None</code> <code>max_value</code> <code>Optional[Union[int, float]]</code> <p>The maximum acceptable value (inclusive). Defaults to None, meaning no upper bound.</p> <code>None</code> Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>def __init__(\n    self,\n    min_value: Optional[Union[int, float]] = None,\n    max_value: Optional[Union[int, float]] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Number validator.\n\n    Args:\n        min_value: The minimum acceptable value (inclusive).\n            Defaults to None, meaning no lower bound.\n        max_value: The maximum acceptable value (inclusive).\n            Defaults to None, meaning no upper bound.\n    \"\"\"\n    self.min_value: Optional[Union[int, float]] = min_value\n    self.max_value: Optional[Union[int, float]] = max_value\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Number.validate","title":"<code>validate(value)</code>","text":"<p>Validate that the value is a number and within the specified range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[int, float]</code> <p>The number to validate.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value is not an int or float.</p> <code>ValueError</code> <p>If the value is less than min_value or greater than max_value.</p> Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>def validate(self, value: Union[int, float]) -&gt; None:\n    \"\"\"\n    Validate that the value is a number and within the specified range.\n\n    Args:\n        value: The number to validate.\n\n    Raises:\n        TypeError: If the value is not an int or float.\n        ValueError: If the value is less than min_value or greater than max_value.\n    \"\"\"\n    if not isinstance(value, (int, float)):\n        raise TypeError(\"Value must be an int or float\")\n\n    if self.min_value is not None and value &lt; self.min_value:\n        raise ValueError(f\"Value must be at least {self.min_value}\")\n\n    if self.max_value is not None and value &gt; self.max_value:\n        raise ValueError(f\"Value must be at most {self.max_value}\")\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Validator","title":"<code>Validator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for attribute validators.</p> <p>This descriptor class implements the set_name, get, and set methods to automatically manage a private attribute name and to perform validation when setting an attribute's value. Subclasses must implement the validate() method.</p> Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>class Validator(ABC):\n    \"\"\"\n    Abstract base class for attribute validators.\n\n    This descriptor class implements the __set_name__, __get__, and __set__ methods to\n    automatically manage a private attribute name and to perform validation when setting\n    an attribute's value. Subclasses must implement the validate() method.\n    \"\"\"\n\n    def __set_name__(self, owner: Any, name: str) -&gt; None:\n        \"\"\"\n        Automatically called to set the name of the attribute.\n\n        This method is invoked at class creation time to assign a private name\n        to the attribute being managed by the validator.\n\n        Args:\n            owner: The owner class where the descriptor is defined.\n            name: The name of the attribute.\n        \"\"\"\n        self.private_name = f\"_{name}\"\n\n    def __get__(self, instance: Any, objtype: Any = None) -&gt; Any:\n        \"\"\"\n        Retrieve the value of the managed attribute.\n\n        Args:\n            instance: The instance from which the attribute is accessed.\n            objtype: The type of the owner class. Defaults to None.\n\n        Returns:\n            The current value of the attribute.\n        \"\"\"\n        return getattr(instance, self.private_name)\n\n    def __set__(self, instance: Any, value: Any) -&gt; None:\n        \"\"\"\n        Set the value of the managed attribute after validating it.\n\n        The method calls the validate() function to ensure that the provided value meets\n        the criteria defined by the validator. If valid, the value is stored under the\n        private attribute name.\n\n        Args:\n            instance: The instance on which the attribute is being set.\n            value: The new value to set.\n\n        Raises:\n            Any: Any exception raised by the validate() method.\n        \"\"\"\n        self.validate(value)\n        setattr(instance, self.private_name, value)\n\n    @abstractmethod\n    def validate(self, value: Any) -&gt; None:\n        \"\"\"\n        Validate the value being assigned to the attribute.\n\n        Subclasses must implement this method to enforce specific validation rules.\n\n        Args:\n            value: The value to validate.\n\n        Raises:\n            Exception: If the value does not meet the validation criteria.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Validator.__get__","title":"<code>__get__(instance, objtype=None)</code>","text":"<p>Retrieve the value of the managed attribute.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>The instance from which the attribute is accessed.</p> required <code>objtype</code> <code>Any</code> <p>The type of the owner class. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The current value of the attribute.</p> Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>def __get__(self, instance: Any, objtype: Any = None) -&gt; Any:\n    \"\"\"\n    Retrieve the value of the managed attribute.\n\n    Args:\n        instance: The instance from which the attribute is accessed.\n        objtype: The type of the owner class. Defaults to None.\n\n    Returns:\n        The current value of the attribute.\n    \"\"\"\n    return getattr(instance, self.private_name)\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Validator.__set__","title":"<code>__set__(instance, value)</code>","text":"<p>Set the value of the managed attribute after validating it.</p> <p>The method calls the validate() function to ensure that the provided value meets the criteria defined by the validator. If valid, the value is stored under the private attribute name.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>The instance on which the attribute is being set.</p> required <code>value</code> <code>Any</code> <p>The new value to set.</p> required <p>Raises:</p> Type Description <code>Any</code> <p>Any exception raised by the validate() method.</p> Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>def __set__(self, instance: Any, value: Any) -&gt; None:\n    \"\"\"\n    Set the value of the managed attribute after validating it.\n\n    The method calls the validate() function to ensure that the provided value meets\n    the criteria defined by the validator. If valid, the value is stored under the\n    private attribute name.\n\n    Args:\n        instance: The instance on which the attribute is being set.\n        value: The new value to set.\n\n    Raises:\n        Any: Any exception raised by the validate() method.\n    \"\"\"\n    self.validate(value)\n    setattr(instance, self.private_name, value)\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Validator.__set_name__","title":"<code>__set_name__(owner, name)</code>","text":"<p>Automatically called to set the name of the attribute.</p> <p>This method is invoked at class creation time to assign a private name to the attribute being managed by the validator.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>Any</code> <p>The owner class where the descriptor is defined.</p> required <code>name</code> <code>str</code> <p>The name of the attribute.</p> required Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>def __set_name__(self, owner: Any, name: str) -&gt; None:\n    \"\"\"\n    Automatically called to set the name of the attribute.\n\n    This method is invoked at class creation time to assign a private name\n    to the attribute being managed by the validator.\n\n    Args:\n        owner: The owner class where the descriptor is defined.\n        name: The name of the attribute.\n    \"\"\"\n    self.private_name = f\"_{name}\"\n</code></pre>"},{"location":"modules/collections/validators/#opensourceleg.collections.validators.Validator.validate","title":"<code>validate(value)</code>  <code>abstractmethod</code>","text":"<p>Validate the value being assigned to the attribute.</p> <p>Subclasses must implement this method to enforce specific validation rules.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to validate.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the value does not meet the validation criteria.</p> Source code in <code>opensourceleg/collections/validators.py</code> <pre><code>@abstractmethod\ndef validate(self, value: Any) -&gt; None:\n    \"\"\"\n    Validate the value being assigned to the attribute.\n\n    Subclasses must implement this method to enforce specific validation rules.\n\n    Args:\n        value: The value to validate.\n\n    Raises:\n        Exception: If the value does not meet the validation criteria.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/control/compiled/","title":"Compiled Controller","text":""},{"location":"modules/control/compiled/#opensourceleg.control.compiled.CompiledController","title":"<code>CompiledController</code>","text":"<p>Controller class to handle using compiled controllers. This class expects that your function has the form: myFunction(inputs, outputs) where inputs is a pointer to an inputs structure and outputs is a pointer to an outputs structure. You can define these input and output structures however you please. See examples folder of repo for examples.</p> <p>Parameters:</p> Name Type Description Default <code>library_name</code> <code>str</code> <p>The name of the compiled library file, without the *.so</p> required <code>library_path</code> <code>str</code> <p>The path to the directory containing the library. See examples for how to get working directory of parent script.</p> required <code>main_function_name</code> <code>str</code> <p>Name of the main function to call within the library. This is the function that will get called via the run() method</p> required <code>initialization_function_name</code> <code>Optional[str]</code> <p>Name of an initialization function for your library. This gets called only once when the library is loaded. If you don't have an initialization function, pass None.</p> <code>None</code> <code>cleanup_function_name</code> <code>Optional[str]</code> <p>Name of a cleanup function for your library. This gets called when the CompiledController class has gone out of scope and is garbage collected. Again, pass None if you don't need this functionality.</p> <code>None</code> Authors <p>Kevin Best, Senthur Raj Ayyappan Neurobionics Lab Robotics Department University of Michigan October 2023</p> Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>class CompiledController:\n    \"\"\"\n    Controller class to handle using compiled controllers.\n    This class expects that your function has the form: myFunction(*inputs, *outputs)\n    where *inputs is a pointer to an inputs structure and\n    *outputs is a pointer to an outputs structure.\n    You can define these input and output structures however you please.\n    See examples folder of repo for examples.\n\n    Args:\n        library_name: The name of the compiled library file, without the *.so\n        library_path: The path to the directory containing the library.\n            See examples for how to get working directory of parent script.\n        main_function_name: Name of the main function to call within the library.\n            This is the function that will get called via the run() method\n        initialization_function_name: Name of an initialization function for your library. This gets called only once when the library is loaded. If\n            you don't have an initialization function, pass None.\n        cleanup_function_name: Name of a cleanup function for your library.\n            This gets called when the CompiledController class has gone out of scope and is garbage collected.\n            Again, pass None if you don't need this functionality.\n\n    Authors:\n        Kevin Best, Senthur Raj Ayyappan\n        Neurobionics Lab\n        Robotics Department\n        University of Michigan\n        October 2023\n    \"\"\"\n\n    def __init__(\n        self,\n        library_name: str,\n        library_path: str,\n        main_function_name: str,\n        initialization_function_name: Optional[str] = None,\n        cleanup_function_name: Optional[str] = None,\n    ) -&gt; None:\n        self.lib: Any = ctl.load_library(library_name, library_path)\n        self.cleanup_func: Callable = self._load_function(cleanup_function_name)\n        self.main_function: Callable = self._load_function(main_function_name)\n        self.init_function: Callable = self._load_function(initialization_function_name)\n        # Note if requested function name is None, returned handle is also none\n\n        if self.init_function is not None:\n            self.init_function()\n\n        # This alias makes defining types from top script easier without second import\n        self.types = ctypes\n\n        self.DEFAULT_SENSOR_LIST = [\n            (\"knee_angle\", self.types.c_double),\n            (\"ankle_angle\", self.types.c_double),\n            (\"knee_velocity\", self.types.c_double),\n            (\"ankle_velocity\", self.types.c_double),\n            (\"Fz\", self.types.c_double),\n        ]\n\n        self._input_type = None\n        self.inputs = None\n        self._output_type = None\n        self.outputs = None\n\n    def __del__(self) -&gt; None:\n        if hasattr(self, \"cleanup_func\") and self.cleanup_func is not None:\n            self.cleanup_func()\n\n    def __repr__(self) -&gt; str:\n        return \"CompiledController\"\n\n    def _load_function(self, function_name: Optional[str]) -&gt; Any:\n        if function_name is None:\n            return None\n        else:\n            try:\n                function_handle = getattr(self.lib, function_name)\n            except AttributeError:\n                LOGGER.warning(f\"Function {function_name} not found in library {self.lib}\")\n            return function_handle\n\n    def define_inputs(self, input_list: list[Any]) -&gt; None:\n        \"\"\"\n        This method defines the input structure to your function.\n        See example folder and tutorials for help on using this method.\n\n        Args:\n            input_list: Input parameters given as a list of [('field_name', field_type)...]\n                field_name is a string you choose as the title of the field.\n                field_type is a type either given by a native c_types value or\n                    a custom type defined via the define_type() method.\n                    All types can be accessed as CompiledController.types.(type_name)\n        \"\"\"\n        self._input_type = self.define_type(\"inputs\", input_list)\n\n        if self._input_type is None:\n            raise ValueError(\"Input type not defined properly. Check define_type() method.\")\n\n        self.inputs = self._input_type()\n\n    def define_outputs(self, output_list: list[Any]) -&gt; None:\n        \"\"\"\n        This method defines the output structure to your function.\n        See example folder and tutorials for help on using this method.\n\n        Args:\n            output_list: Output parameters given as a list of [('field_name', field_type)...]\n                field_name is a string you choose as the title of the field.\n                field_type is a type either given by a native c_types value or\n                    a custom type defined via the define_type() method.\n                    All types can be accessed as CompiledController.types.(type_name)\n        \"\"\"\n        self._output_type = self.define_type(\"outputs\", output_list)\n\n        if self._output_type is None:\n            raise ValueError(\"Output type not defined properly. Check define_type() method.\")\n\n        self.outputs = self._output_type()\n\n    def define_type(self, type_name: str, parameter_list: list[Any]) -&gt; Any:\n        \"\"\"\n        This method defines a new type to be used in the compiled controller.\n        After calling this method, the datatype with name type_name will be\n        available in my_controller.types.type_name for use.\n        See example folder and tutorials for help on using this method.\n\n        Args:\n            type_name: A string defining the name of your new datatype\n            parameter_list: A list of [('field_name', field_type)...]\n                field_name is a string you choose as the title of the field.\n                field_type is a type either given by a native c_types value or\n                    a custom type defined via the define_type() method.\n                    All types can be accessed as CompiledController.types.(type_name)\n\n        Example Usage:\n            my_controller.DefineType('vector3D', [('x', my_controller.types.c_double),\n                                                  ('y', my_controller.types.c_double),\n                                                  ('z', my_controller.types.c_double)])\n        \"\"\"\n        slots = []\n        for param in parameter_list:\n            slots.append(param[0])\n\n        class CustomStructure(ctypes.Structure):\n            _fields_ = parameter_list\n            __slots__ = slots\n\n        setattr(self.types, type_name, CustomStructure)\n        return getattr(self.types, type_name)\n\n    def run(self) -&gt; Any:\n        \"\"\"\n        This method calls the main controller function of the library.\n        Under the hood, it calls library_name.main_function_name(*inputs, *outputs),\n        where library_name and main_function_name were given in the constructor.\n\n        Returns:\n            The output structure as defined by the define_outputs() method.\n\n        Raises:\n            ValueError: If define_inputs() or define_outputs() have not been called.\n        \"\"\"\n        if self.inputs is None:\n            raise ValueError(\"Must define input type before calling controller.run(). Use define_inputs() method.\")\n        if self.outputs is None:\n            raise ValueError(\"Must define output type before calling controller.run(). Use define_outputs() method.\")\n        self.main_function(ctypes.byref(self.inputs), ctypes.byref(self.outputs))\n        return self.outputs\n</code></pre>"},{"location":"modules/control/compiled/#opensourceleg.control.compiled.CompiledController.define_inputs","title":"<code>define_inputs(input_list)</code>","text":"<p>This method defines the input structure to your function. See example folder and tutorials for help on using this method.</p> <p>Parameters:</p> Name Type Description Default <code>input_list</code> <code>list[Any]</code> <p>Input parameters given as a list of [('field_name', field_type)...] field_name is a string you choose as the title of the field. field_type is a type either given by a native c_types value or     a custom type defined via the define_type() method.     All types can be accessed as CompiledController.types.(type_name)</p> required Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>def define_inputs(self, input_list: list[Any]) -&gt; None:\n    \"\"\"\n    This method defines the input structure to your function.\n    See example folder and tutorials for help on using this method.\n\n    Args:\n        input_list: Input parameters given as a list of [('field_name', field_type)...]\n            field_name is a string you choose as the title of the field.\n            field_type is a type either given by a native c_types value or\n                a custom type defined via the define_type() method.\n                All types can be accessed as CompiledController.types.(type_name)\n    \"\"\"\n    self._input_type = self.define_type(\"inputs\", input_list)\n\n    if self._input_type is None:\n        raise ValueError(\"Input type not defined properly. Check define_type() method.\")\n\n    self.inputs = self._input_type()\n</code></pre>"},{"location":"modules/control/compiled/#opensourceleg.control.compiled.CompiledController.define_outputs","title":"<code>define_outputs(output_list)</code>","text":"<p>This method defines the output structure to your function. See example folder and tutorials for help on using this method.</p> <p>Parameters:</p> Name Type Description Default <code>output_list</code> <code>list[Any]</code> <p>Output parameters given as a list of [('field_name', field_type)...] field_name is a string you choose as the title of the field. field_type is a type either given by a native c_types value or     a custom type defined via the define_type() method.     All types can be accessed as CompiledController.types.(type_name)</p> required Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>def define_outputs(self, output_list: list[Any]) -&gt; None:\n    \"\"\"\n    This method defines the output structure to your function.\n    See example folder and tutorials for help on using this method.\n\n    Args:\n        output_list: Output parameters given as a list of [('field_name', field_type)...]\n            field_name is a string you choose as the title of the field.\n            field_type is a type either given by a native c_types value or\n                a custom type defined via the define_type() method.\n                All types can be accessed as CompiledController.types.(type_name)\n    \"\"\"\n    self._output_type = self.define_type(\"outputs\", output_list)\n\n    if self._output_type is None:\n        raise ValueError(\"Output type not defined properly. Check define_type() method.\")\n\n    self.outputs = self._output_type()\n</code></pre>"},{"location":"modules/control/compiled/#opensourceleg.control.compiled.CompiledController.define_type","title":"<code>define_type(type_name, parameter_list)</code>","text":"<p>This method defines a new type to be used in the compiled controller. After calling this method, the datatype with name type_name will be available in my_controller.types.type_name for use. See example folder and tutorials for help on using this method.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>A string defining the name of your new datatype</p> required <code>parameter_list</code> <code>list[Any]</code> <p>A list of [('field_name', field_type)...] field_name is a string you choose as the title of the field. field_type is a type either given by a native c_types value or     a custom type defined via the define_type() method.     All types can be accessed as CompiledController.types.(type_name)</p> required Example Usage <p>my_controller.DefineType('vector3D', [('x', my_controller.types.c_double),                                       ('y', my_controller.types.c_double),                                       ('z', my_controller.types.c_double)])</p> Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>def define_type(self, type_name: str, parameter_list: list[Any]) -&gt; Any:\n    \"\"\"\n    This method defines a new type to be used in the compiled controller.\n    After calling this method, the datatype with name type_name will be\n    available in my_controller.types.type_name for use.\n    See example folder and tutorials for help on using this method.\n\n    Args:\n        type_name: A string defining the name of your new datatype\n        parameter_list: A list of [('field_name', field_type)...]\n            field_name is a string you choose as the title of the field.\n            field_type is a type either given by a native c_types value or\n                a custom type defined via the define_type() method.\n                All types can be accessed as CompiledController.types.(type_name)\n\n    Example Usage:\n        my_controller.DefineType('vector3D', [('x', my_controller.types.c_double),\n                                              ('y', my_controller.types.c_double),\n                                              ('z', my_controller.types.c_double)])\n    \"\"\"\n    slots = []\n    for param in parameter_list:\n        slots.append(param[0])\n\n    class CustomStructure(ctypes.Structure):\n        _fields_ = parameter_list\n        __slots__ = slots\n\n    setattr(self.types, type_name, CustomStructure)\n    return getattr(self.types, type_name)\n</code></pre>"},{"location":"modules/control/compiled/#opensourceleg.control.compiled.CompiledController.run","title":"<code>run()</code>","text":"<p>This method calls the main controller function of the library. Under the hood, it calls library_name.main_function_name(inputs, outputs), where library_name and main_function_name were given in the constructor.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The output structure as defined by the define_outputs() method.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If define_inputs() or define_outputs() have not been called.</p> Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>def run(self) -&gt; Any:\n    \"\"\"\n    This method calls the main controller function of the library.\n    Under the hood, it calls library_name.main_function_name(*inputs, *outputs),\n    where library_name and main_function_name were given in the constructor.\n\n    Returns:\n        The output structure as defined by the define_outputs() method.\n\n    Raises:\n        ValueError: If define_inputs() or define_outputs() have not been called.\n    \"\"\"\n    if self.inputs is None:\n        raise ValueError(\"Must define input type before calling controller.run(). Use define_inputs() method.\")\n    if self.outputs is None:\n        raise ValueError(\"Must define output type before calling controller.run(). Use define_outputs() method.\")\n    self.main_function(ctypes.byref(self.inputs), ctypes.byref(self.outputs))\n    return self.outputs\n</code></pre>"},{"location":"modules/control/fsm/","title":"State Machine","text":"<p>(c) 2025 Open-Source Leg</p> <p>A simple and scalable Finite State Machine module. It includes the State, Event, Transition, and StateMachine classes.</p> <p>Usage: 1. Use the <code>State</code> class to represent a state in the FSM. 2. Utilize the <code>Event</code> class to define events that trigger state transitions. 3. Create transitions between states using the <code>Transition</code> class. Add criteria and actions as needed. 4. Instantiate the <code>StateMachine</code> class, add states, events, and transitions, and start the FSM. 5. Use the \"main\" function as an example to see how to use the FSM.</p> Author <ul> <li>Senthur Ayyappan senthura@umich.edu</li> </ul>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Event","title":"<code>Event</code>","text":"Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>class Event:\n    def __init__(self, name: str) -&gt; None:\n        \"\"\"\n        A class to represent an event in a finite state machine.\n        This is a simple label to identify an event that triggers a transition.\n\n        Args:\n            name: The name of the event.\n\n        Example:\n            &gt;&gt;&gt; event = Event(\"walk\")\n        \"\"\"\n        self._name: str = name\n\n    def __eq__(self, __o: Any) -&gt; bool:\n        return bool(__o.name == self._name)\n\n    def __ne__(self, __o: Any) -&gt; bool:\n        return not self.__eq__(__o)  # TODO: Check this fix\n\n    def __repr__(self) -&gt; str:\n        return f\"Event[{self._name}]\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the event.\n\n        Returns:\n            str: The name of the event\n        \"\"\"\n        return self._name\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Event.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the name of the event.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the event</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Event.__init__","title":"<code>__init__(name)</code>","text":"<p>A class to represent an event in a finite state machine. This is a simple label to identify an event that triggers a transition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the event.</p> required Example <p>event = Event(\"walk\")</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"\n    A class to represent an event in a finite state machine.\n    This is a simple label to identify an event that triggers a transition.\n\n    Args:\n        name: The name of the event.\n\n    Example:\n        &gt;&gt;&gt; event = Event(\"walk\")\n    \"\"\"\n    self._name: str = name\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State","title":"<code>State</code>","text":"Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>class State:\n    def __init__(\n        self,\n        name: str = \"state\",\n        minimum_time_in_state: float = 0.0,\n        entry_callbacks: Optional[list[Callable[[Any], None]]] = None,\n        exit_callbacks: Optional[list[Callable[[Any], None]]] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        A class to represent a state in a finite state machine.\n        Custom attributes can be added to the state using keyword arguments.\n\n        Args:\n            name: Name of the state\n            minimum_time_in_state: Minimum time spent in the state in seconds. \\\n                Transition to the next state will not occur until this time has elapsed.\n                Defaults to 0.0 seconds.\n            entry_callbacks: List of functions to call when entering the state.\n            exit_callbacks: List of functions to call when exiting the state.\n            **kwargs: Additional attributes to set on the state\n\n        Example:\n            &gt;&gt;&gt; state = State(\n            ...     name=\"idle\",\n            ...     minimum_time_in_state=2.0,\n            ...     entry_callbacks=[print(\"Entering idle state\")],\n            ...     exit_callbacks=[print(\"Exiting idle state\")],\n            ... )\n        \"\"\"\n        self._name: str = name\n        self._time_entered: float = 0.0\n        self._time_exited: float = 0.0\n        self._min_time_in_state: float = minimum_time_in_state\n        self._entry_callbacks: list[Callable[[Any], None]] = entry_callbacks or []\n        self._exit_callbacks: list[Callable[[Any], None]] = exit_callbacks or []\n\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n    def __eq__(self, __o: Any) -&gt; bool:\n        return bool(__o.name == self._name)\n\n    def __ne__(self, __o: Any) -&gt; bool:\n        return not self.__eq__(__o)\n\n    def __hash__(self) -&gt; int:\n        return hash(self._name)\n\n    def __repr__(self) -&gt; str:\n        return f\"State[{self._name}]\"\n\n    def set_minimum_time_spent_in_state(self, time: float) -&gt; None:\n        \"\"\"\n        Set the minimum time spent in the state\n\n        Args:\n            time: Minimum time spent in the state in seconds\n\n        Example:\n            &gt;&gt;&gt; state.set_minimum_time_spent_in_state(2.0)\n        \"\"\"\n        self._min_time_in_state = time\n\n    def add_entry_callback(self, callback: Callable[[Any], None]) -&gt; None:\n        \"\"\"\n        Add a callback function to be called when entering the state.\n\n        Args:\n            callback: Function to be called when entering the state\n\n        Example:\n            &gt;&gt;&gt; state.add_entry_callback(lambda: if t &gt; 0: print(\"Entering idle state\"))\n        \"\"\"\n        self._entry_callbacks.append(callback)\n\n    def add_exit_callback(self, callback: Callable[[Any], None]) -&gt; None:\n        \"\"\"\n        Add a callback function to be called when exiting the state.\n\n        Args:\n            callback: Function to be called when exiting the state\n\n        Example:\n            &gt;&gt;&gt; state.add_exit_callback(lambda: if t &gt; 1: print(\"Exiting idle state\"))\n        \"\"\"\n        self._exit_callbacks.append(callback)\n\n    def enter(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Enter the state.\n\n        Args:\n            *args: Arguments to pass to the entry callbacks\n            **kwargs: Keyword arguments to pass to the entry callbacks\n\n        Example:\n            &gt;&gt;&gt; state.enter(x=1)\n        \"\"\"\n        self._time_entered = time.monotonic()\n        for c in self._entry_callbacks:\n            c(*args, **kwargs)\n\n    def exit(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Exit the state.\n\n        Args:\n            *args: Arguments to pass to the exit callbacks\n            **kwargs: Keyword arguments to pass to the exit callbacks\n\n        Example:\n            &gt;&gt;&gt; state.exit(x=1)\n        \"\"\"\n        self._time_exited = time.monotonic()\n        for c in self._exit_callbacks:\n            c(*args, **kwargs)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the state.\n\n        Returns:\n            str: The name of the state\n        \"\"\"\n        return self._name\n\n    @property\n    def minimum_time_spent_in_state(self) -&gt; float:\n        \"\"\"\n        Get the minimum time spent in the state.\n\n        Returns:\n            float: The minimum time spent in the state\n        \"\"\"\n        return self._min_time_in_state\n\n    @property\n    def current_time_in_state(self) -&gt; float:\n        \"\"\"\n        Get the current time spent in the state.\n\n        Returns:\n            float: The current time spent in the state\n        \"\"\"\n        return time.monotonic() - self._time_entered\n\n    @property\n    def time_spent_in_state(self) -&gt; float:\n        \"\"\"\n        Get the time spent in the state.\n\n        Returns:\n            float: The time spent in the state\n        \"\"\"\n        return self._time_exited - self._time_entered\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.current_time_in_state","title":"<code>current_time_in_state: float</code>  <code>property</code>","text":"<p>Get the current time spent in the state.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current time spent in the state</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.minimum_time_spent_in_state","title":"<code>minimum_time_spent_in_state: float</code>  <code>property</code>","text":"<p>Get the minimum time spent in the state.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The minimum time spent in the state</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the name of the state.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the state</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.time_spent_in_state","title":"<code>time_spent_in_state: float</code>  <code>property</code>","text":"<p>Get the time spent in the state.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The time spent in the state</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.__init__","title":"<code>__init__(name='state', minimum_time_in_state=0.0, entry_callbacks=None, exit_callbacks=None, **kwargs)</code>","text":"<p>A class to represent a state in a finite state machine. Custom attributes can be added to the state using keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state</p> <code>'state'</code> <code>minimum_time_in_state</code> <code>float</code> <p>Minimum time spent in the state in seconds.                 Transition to the next state will not occur until this time has elapsed. Defaults to 0.0 seconds.</p> <code>0.0</code> <code>entry_callbacks</code> <code>Optional[list[Callable[[Any], None]]]</code> <p>List of functions to call when entering the state.</p> <code>None</code> <code>exit_callbacks</code> <code>Optional[list[Callable[[Any], None]]]</code> <p>List of functions to call when exiting the state.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional attributes to set on the state</p> <code>{}</code> Example <p>state = State( ...     name=\"idle\", ...     minimum_time_in_state=2.0, ...     entry_callbacks=[print(\"Entering idle state\")], ...     exit_callbacks=[print(\"Exiting idle state\")], ... )</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"state\",\n    minimum_time_in_state: float = 0.0,\n    entry_callbacks: Optional[list[Callable[[Any], None]]] = None,\n    exit_callbacks: Optional[list[Callable[[Any], None]]] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    A class to represent a state in a finite state machine.\n    Custom attributes can be added to the state using keyword arguments.\n\n    Args:\n        name: Name of the state\n        minimum_time_in_state: Minimum time spent in the state in seconds. \\\n            Transition to the next state will not occur until this time has elapsed.\n            Defaults to 0.0 seconds.\n        entry_callbacks: List of functions to call when entering the state.\n        exit_callbacks: List of functions to call when exiting the state.\n        **kwargs: Additional attributes to set on the state\n\n    Example:\n        &gt;&gt;&gt; state = State(\n        ...     name=\"idle\",\n        ...     minimum_time_in_state=2.0,\n        ...     entry_callbacks=[print(\"Entering idle state\")],\n        ...     exit_callbacks=[print(\"Exiting idle state\")],\n        ... )\n    \"\"\"\n    self._name: str = name\n    self._time_entered: float = 0.0\n    self._time_exited: float = 0.0\n    self._min_time_in_state: float = minimum_time_in_state\n    self._entry_callbacks: list[Callable[[Any], None]] = entry_callbacks or []\n    self._exit_callbacks: list[Callable[[Any], None]] = exit_callbacks or []\n\n    for key, value in kwargs.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.add_entry_callback","title":"<code>add_entry_callback(callback)</code>","text":"<p>Add a callback function to be called when entering the state.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], None]</code> <p>Function to be called when entering the state</p> required Example <p>state.add_entry_callback(lambda: if t &gt; 0: print(\"Entering idle state\"))</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_entry_callback(self, callback: Callable[[Any], None]) -&gt; None:\n    \"\"\"\n    Add a callback function to be called when entering the state.\n\n    Args:\n        callback: Function to be called when entering the state\n\n    Example:\n        &gt;&gt;&gt; state.add_entry_callback(lambda: if t &gt; 0: print(\"Entering idle state\"))\n    \"\"\"\n    self._entry_callbacks.append(callback)\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.add_exit_callback","title":"<code>add_exit_callback(callback)</code>","text":"<p>Add a callback function to be called when exiting the state.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], None]</code> <p>Function to be called when exiting the state</p> required Example <p>state.add_exit_callback(lambda: if t &gt; 1: print(\"Exiting idle state\"))</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_exit_callback(self, callback: Callable[[Any], None]) -&gt; None:\n    \"\"\"\n    Add a callback function to be called when exiting the state.\n\n    Args:\n        callback: Function to be called when exiting the state\n\n    Example:\n        &gt;&gt;&gt; state.add_exit_callback(lambda: if t &gt; 1: print(\"Exiting idle state\"))\n    \"\"\"\n    self._exit_callbacks.append(callback)\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.enter","title":"<code>enter(*args, **kwargs)</code>","text":"<p>Enter the state.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the entry callbacks</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the entry callbacks</p> <code>{}</code> Example <p>state.enter(x=1)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def enter(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Enter the state.\n\n    Args:\n        *args: Arguments to pass to the entry callbacks\n        **kwargs: Keyword arguments to pass to the entry callbacks\n\n    Example:\n        &gt;&gt;&gt; state.enter(x=1)\n    \"\"\"\n    self._time_entered = time.monotonic()\n    for c in self._entry_callbacks:\n        c(*args, **kwargs)\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.exit","title":"<code>exit(*args, **kwargs)</code>","text":"<p>Exit the state.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the exit callbacks</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the exit callbacks</p> <code>{}</code> Example <p>state.exit(x=1)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def exit(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Exit the state.\n\n    Args:\n        *args: Arguments to pass to the exit callbacks\n        **kwargs: Keyword arguments to pass to the exit callbacks\n\n    Example:\n        &gt;&gt;&gt; state.exit(x=1)\n    \"\"\"\n    self._time_exited = time.monotonic()\n    for c in self._exit_callbacks:\n        c(*args, **kwargs)\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.State.set_minimum_time_spent_in_state","title":"<code>set_minimum_time_spent_in_state(time)</code>","text":"<p>Set the minimum time spent in the state</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Minimum time spent in the state in seconds</p> required Example <p>state.set_minimum_time_spent_in_state(2.0)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def set_minimum_time_spent_in_state(self, time: float) -&gt; None:\n    \"\"\"\n    Set the minimum time spent in the state\n\n    Args:\n        time: Minimum time spent in the state in seconds\n\n    Example:\n        &gt;&gt;&gt; state.set_minimum_time_spent_in_state(2.0)\n    \"\"\"\n    self._min_time_in_state = time\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine","title":"<code>StateMachine</code>","text":"Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>class StateMachine:\n    def __init__(\n        self,\n        states: Optional[list[State]] = None,\n        initial_state_name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        A flexible finite state machine class that supports:\n        - Multiple states with transitions between them\n        - Events that trigger transitions\n        - Entry and exit actions for states\n        - Minimum time constraints for states\n\n        Args:\n            states: List of states to add to the state machine\n            initial_state_name: Name of the initial state to set\n\n        Example:\n            &gt;&gt;&gt; sm = StateMachine(states=[State(\"idle\"), State(\"walking\"), State(\"running\")],\n            ...     initial_state_name=\"idle\")\n        \"\"\"\n        self._states: list[State] = []\n        self._events: list[Event] = []\n        self._transitions: list[Transition] = []\n        self._transition_map: dict[State, list[Transition]] = {}\n\n        self._initial_state: Optional[State] = None\n        self._current_state: Optional[State] = None\n\n        if states:\n            self.add_states(states, initial_state_name)\n\n    def __repr__(self) -&gt; str:\n        return \"StateMachine\"\n\n    def add_states(self, states: list[State], initial_state_name: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Add multiple states to the state machine at once.\n\n        Args:\n            states: List of states to add\n            initial_state_name: Name of the state to set as initial state\n\n        Example:\n            &gt;&gt;&gt; sm.add_states([State(\"idle\"), State(\"walking\"), State(\"running\")], initial_state_name=\"idle\")\n        \"\"\"\n        for state in states:\n            if state not in self._states:\n                self._states.append(state)\n                # Set up transition map entry\n                if state not in self._transition_map:\n                    self._transition_map[state] = []\n            else:\n                LOGGER.warning(f\"State {state.name} already exists in state machine\")\n\n        # Set initial state if specified and warn if overwriting\n        if initial_state_name:\n            user_defined_initial_state = self.get_state_by_name(initial_state_name)\n            if user_defined_initial_state:\n                if self.initial_state is not None:\n                    LOGGER.warning(f\"Overwriting initial state from {self.initial_state.name} to {initial_state_name}\")\n                self._initial_state = user_defined_initial_state\n            else:\n                LOGGER.warning(f\"Initial state {initial_state_name} not found in added states\")\n\n    def add_events(self, events: list[Event]) -&gt; None:\n        \"\"\"\n        Add multiple events to the state machine at once.\n\n        Args:\n            events: List of events to add\n\n        Example:\n            &gt;&gt;&gt; sm.add_events([Event(\"walk\"), Event(\"run\"), Event(\"stop\")])\n        \"\"\"\n        for event in events:\n            if event not in self._events:\n                self._events.append(event)\n            else:\n                LOGGER.warning(f\"Event {event.name} already exists in state machine\")\n\n    def create_state(self, name: str, **kwargs: Any) -&gt; State:\n        \"\"\"\n        Create a new state and add it to the state machine.\n\n        Args:\n            name: Name of the state\n            **kwargs: Additional arguments to pass to the State constructor\n\n        Returns:\n            State: The created state\n\n        Example:\n            &gt;&gt;&gt; sm.create_state(\n            ...     name=\"idle\",\n            ...     minimum_time_spent_in_state=2.0,\n            ...     entry_callbacks=[print(\"Entering idle state\")],\n            ...     exit_callbacks=[print(\"Exiting idle state\")],\n            ... )\n        \"\"\"\n        state = State(name=name, **kwargs)\n        self.add_states([state])\n        return state\n\n    def create_event(self, name: str) -&gt; Event:\n        \"\"\"\n        Create a new event and add it to the state machine.\n\n        Args:\n            name: Name of the event\n\n        Returns:\n            Event: The created event\n\n        Example:\n            &gt;&gt;&gt; sm.create_event(\"walk\")\n        \"\"\"\n        event = Event(name=name)\n        self.add_events([event])\n        return event\n\n    def add_transition(\n        self,\n        source: State,\n        destination: State,\n        event_name: str,\n        criteria: Optional[Callable[[Any], bool]] = None,\n        action: Optional[Callable[[Any], None]] = None,\n    ) -&gt; Optional[Transition]:\n        \"\"\"\n        Add a transition to the state machine. If multiple transitions exist from the same source state,\n        precedence is given to the first added transition.\n\n        Args:\n            source: The source state\n            destination: The destination state\n            event_name: The name of the event that triggers the transition\n            criteria: A callback function that returns a boolean value, which determines whether the transition is valid\n            action: A callback function to execute during the transition\n\n        Returns:\n            Optional[Transition]: The created transition, or None if the transition couldn't be created\n\n        Example:\n            &gt;&gt;&gt; sm.add_transition(\n            ...     source=State(\"idle\"),\n            ...     destination=State(\"walking\"),\n            ...     event_name=\"walk\",\n            ...     criteria=lambda: True,\n            ...     action=lambda: print(\"Walking\"),\n            ... )\n        \"\"\"\n        transition = None\n        event = self.create_event(event_name)\n\n        if source in self._states and destination in self._states and event in self._events:\n            transition = Transition(\n                event=event,\n                source=source,\n                destination=destination,\n                criteria=criteria,\n                action=action,\n            )\n            self._transitions.append(transition)\n\n            # Add to transition map for faster lookup\n            if source not in self._transition_map:\n                self._transition_map[source] = []\n            self._transition_map[source].append(transition)\n\n        return transition\n\n    def update(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Update the state machine, checking all possible transitions from the current state.\n        If any transition's criteria are met, the state machine will transition automatically. If multiple\n        transitions exist from the same source state, precedence is given to the first added transition.\n\n        Args:\n            **kwargs: Named arguments to pass to transition criteria and actions\n\n        Example:\n            &gt;&gt;&gt; sm.update(t=t)\n        \"\"\"\n        if not self._current_state:\n            raise ValueError(\"State machine isn't active.\")\n\n        # Check if minimum time in state has elapsed\n        if self._current_state.current_time_in_state &lt; self._current_state.minimum_time_spent_in_state:\n            return\n\n        transitions = self._transition_map.get(self._current_state, [])\n\n        if not transitions:\n            LOGGER.debug(f\"No transitions defined for state {self._current_state.name}\")\n            return\n\n        for transition in transitions:\n            next_state = transition(**kwargs)\n\n            # If state changed, update current state and exit\n            if next_state != self._current_state:\n                self._current_state = next_state\n\n                return\n\n        LOGGER.debug(f\"No valid transitions from state {self._current_state.name}\")\n\n    def start(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Start the state machine.\n\n        Args:\n            *args: Arguments to pass to the initial state\n            **kwargs: Keyword arguments to pass to the initial state\n\n        Example:\n            &gt;&gt;&gt; sm.start(x=1)\n        \"\"\"\n        if not self._initial_state:\n            raise ValueError(\n                \"No initial state set. Add at least one state with initial_state=True or add a non-exit state.\"\n            )\n\n        self._current_state = self._initial_state\n        self._current_state.enter(*args, **kwargs)\n\n    def stop(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Stop the state machine.\n\n        Args:\n            *args: Arguments to pass to the exit state\n            **kwargs: Keyword arguments to pass to the exit state\n\n        Example:\n            &gt;&gt;&gt; sm.stop(x=1)\n        \"\"\"\n        if not self._current_state:\n            raise ValueError(\"State machine isn't active.\")\n\n        self._current_state.exit(*args, **kwargs)\n\n    def __enter__(self) -&gt; \"StateMachine\":\n        \"\"\"\n        Enter the context manager for the state machine.\n\n        Returns:\n            StateMachine: The state machine\n\n        Example:\n            &gt;&gt;&gt; with sm:\n            ...     # Use the state machine\n            ...     pass\n        \"\"\"\n        self.start()\n        return self\n\n    def __exit__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Exit the context manager for the state machine.\n\n        Args:\n            *args: Arguments to pass to the exit state\n            **kwargs: Keyword arguments to pass to the exit state\n\n        Example:\n            &gt;&gt;&gt; with sm:\n            ...     # Use the state machine\n            ...     pass\n        \"\"\"\n        self.stop()\n\n    def __del__(self) -&gt; None:\n        self.stop()\n\n    def __iter__(self) -&gt; Iterator[State]:\n        return iter(self._states)\n\n    def __next__(self) -&gt; State:\n        try:\n            return next(iter(self._states))\n        except StopIteration as e:\n            raise StopIteration(\"No states in state machine\") from e\n\n    @property\n    def current_state(self) -&gt; Optional[State]:\n        \"\"\"\n        Get the current state of the state machine.\n\n        Returns:\n            State: The current state of the state machine\n        \"\"\"\n        return self._current_state\n\n    @property\n    def initial_state(self) -&gt; Optional[State]:\n        \"\"\"\n        Get the initial state of the state machine.\n\n        Returns:\n            State: The initial state of the state machine\n        \"\"\"\n        return self._initial_state\n\n    @property\n    def states(self) -&gt; list[str]:\n        \"\"\"\n        Get the names of all states in the state machine.\n\n        Returns:\n            list[str]: The names of all states in the state machine\n        \"\"\"\n        return [state.name for state in self._states]\n\n    def get_state_by_name(self, name: str) -&gt; Optional[State]:\n        \"\"\"\n        Get a state by its name.\n\n        Args:\n            name: The name of the state to find\n\n        Returns:\n            Optional[State]: The state with the given name, or None if not found\n        \"\"\"\n        for state in self._states:\n            if state.name == name:\n                return state\n        return None\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.current_state","title":"<code>current_state: Optional[State]</code>  <code>property</code>","text":"<p>Get the current state of the state machine.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>Optional[State]</code> <p>The current state of the state machine</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.initial_state","title":"<code>initial_state: Optional[State]</code>  <code>property</code>","text":"<p>Get the initial state of the state machine.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>Optional[State]</code> <p>The initial state of the state machine</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.states","title":"<code>states: list[str]</code>  <code>property</code>","text":"<p>Get the names of all states in the state machine.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The names of all states in the state machine</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager for the state machine.</p> <p>Returns:</p> Name Type Description <code>StateMachine</code> <code>StateMachine</code> <p>The state machine</p> Example <p>with sm: ...     # Use the state machine ...     pass</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __enter__(self) -&gt; \"StateMachine\":\n    \"\"\"\n    Enter the context manager for the state machine.\n\n    Returns:\n        StateMachine: The state machine\n\n    Example:\n        &gt;&gt;&gt; with sm:\n        ...     # Use the state machine\n        ...     pass\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.__exit__","title":"<code>__exit__(*args, **kwargs)</code>","text":"<p>Exit the context manager for the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the exit state</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the exit state</p> <code>{}</code> Example <p>with sm: ...     # Use the state machine ...     pass</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __exit__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Exit the context manager for the state machine.\n\n    Args:\n        *args: Arguments to pass to the exit state\n        **kwargs: Keyword arguments to pass to the exit state\n\n    Example:\n        &gt;&gt;&gt; with sm:\n        ...     # Use the state machine\n        ...     pass\n    \"\"\"\n    self.stop()\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.__init__","title":"<code>__init__(states=None, initial_state_name=None)</code>","text":"<p>A flexible finite state machine class that supports: - Multiple states with transitions between them - Events that trigger transitions - Entry and exit actions for states - Minimum time constraints for states</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>Optional[list[State]]</code> <p>List of states to add to the state machine</p> <code>None</code> <code>initial_state_name</code> <code>Optional[str]</code> <p>Name of the initial state to set</p> <code>None</code> Example <p>sm = StateMachine(states=[State(\"idle\"), State(\"walking\"), State(\"running\")], ...     initial_state_name=\"idle\")</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __init__(\n    self,\n    states: Optional[list[State]] = None,\n    initial_state_name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    A flexible finite state machine class that supports:\n    - Multiple states with transitions between them\n    - Events that trigger transitions\n    - Entry and exit actions for states\n    - Minimum time constraints for states\n\n    Args:\n        states: List of states to add to the state machine\n        initial_state_name: Name of the initial state to set\n\n    Example:\n        &gt;&gt;&gt; sm = StateMachine(states=[State(\"idle\"), State(\"walking\"), State(\"running\")],\n        ...     initial_state_name=\"idle\")\n    \"\"\"\n    self._states: list[State] = []\n    self._events: list[Event] = []\n    self._transitions: list[Transition] = []\n    self._transition_map: dict[State, list[Transition]] = {}\n\n    self._initial_state: Optional[State] = None\n    self._current_state: Optional[State] = None\n\n    if states:\n        self.add_states(states, initial_state_name)\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.add_events","title":"<code>add_events(events)</code>","text":"<p>Add multiple events to the state machine at once.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>list[Event]</code> <p>List of events to add</p> required Example <p>sm.add_events([Event(\"walk\"), Event(\"run\"), Event(\"stop\")])</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_events(self, events: list[Event]) -&gt; None:\n    \"\"\"\n    Add multiple events to the state machine at once.\n\n    Args:\n        events: List of events to add\n\n    Example:\n        &gt;&gt;&gt; sm.add_events([Event(\"walk\"), Event(\"run\"), Event(\"stop\")])\n    \"\"\"\n    for event in events:\n        if event not in self._events:\n            self._events.append(event)\n        else:\n            LOGGER.warning(f\"Event {event.name} already exists in state machine\")\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.add_states","title":"<code>add_states(states, initial_state_name=None)</code>","text":"<p>Add multiple states to the state machine at once.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>list[State]</code> <p>List of states to add</p> required <code>initial_state_name</code> <code>Optional[str]</code> <p>Name of the state to set as initial state</p> <code>None</code> Example <p>sm.add_states([State(\"idle\"), State(\"walking\"), State(\"running\")], initial_state_name=\"idle\")</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_states(self, states: list[State], initial_state_name: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Add multiple states to the state machine at once.\n\n    Args:\n        states: List of states to add\n        initial_state_name: Name of the state to set as initial state\n\n    Example:\n        &gt;&gt;&gt; sm.add_states([State(\"idle\"), State(\"walking\"), State(\"running\")], initial_state_name=\"idle\")\n    \"\"\"\n    for state in states:\n        if state not in self._states:\n            self._states.append(state)\n            # Set up transition map entry\n            if state not in self._transition_map:\n                self._transition_map[state] = []\n        else:\n            LOGGER.warning(f\"State {state.name} already exists in state machine\")\n\n    # Set initial state if specified and warn if overwriting\n    if initial_state_name:\n        user_defined_initial_state = self.get_state_by_name(initial_state_name)\n        if user_defined_initial_state:\n            if self.initial_state is not None:\n                LOGGER.warning(f\"Overwriting initial state from {self.initial_state.name} to {initial_state_name}\")\n            self._initial_state = user_defined_initial_state\n        else:\n            LOGGER.warning(f\"Initial state {initial_state_name} not found in added states\")\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.add_transition","title":"<code>add_transition(source, destination, event_name, criteria=None, action=None)</code>","text":"<p>Add a transition to the state machine. If multiple transitions exist from the same source state, precedence is given to the first added transition.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>State</code> <p>The source state</p> required <code>destination</code> <code>State</code> <p>The destination state</p> required <code>event_name</code> <code>str</code> <p>The name of the event that triggers the transition</p> required <code>criteria</code> <code>Optional[Callable[[Any], bool]]</code> <p>A callback function that returns a boolean value, which determines whether the transition is valid</p> <code>None</code> <code>action</code> <code>Optional[Callable[[Any], None]]</code> <p>A callback function to execute during the transition</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Transition]</code> <p>Optional[Transition]: The created transition, or None if the transition couldn't be created</p> Example <p>sm.add_transition( ...     source=State(\"idle\"), ...     destination=State(\"walking\"), ...     event_name=\"walk\", ...     criteria=lambda: True, ...     action=lambda: print(\"Walking\"), ... )</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_transition(\n    self,\n    source: State,\n    destination: State,\n    event_name: str,\n    criteria: Optional[Callable[[Any], bool]] = None,\n    action: Optional[Callable[[Any], None]] = None,\n) -&gt; Optional[Transition]:\n    \"\"\"\n    Add a transition to the state machine. If multiple transitions exist from the same source state,\n    precedence is given to the first added transition.\n\n    Args:\n        source: The source state\n        destination: The destination state\n        event_name: The name of the event that triggers the transition\n        criteria: A callback function that returns a boolean value, which determines whether the transition is valid\n        action: A callback function to execute during the transition\n\n    Returns:\n        Optional[Transition]: The created transition, or None if the transition couldn't be created\n\n    Example:\n        &gt;&gt;&gt; sm.add_transition(\n        ...     source=State(\"idle\"),\n        ...     destination=State(\"walking\"),\n        ...     event_name=\"walk\",\n        ...     criteria=lambda: True,\n        ...     action=lambda: print(\"Walking\"),\n        ... )\n    \"\"\"\n    transition = None\n    event = self.create_event(event_name)\n\n    if source in self._states and destination in self._states and event in self._events:\n        transition = Transition(\n            event=event,\n            source=source,\n            destination=destination,\n            criteria=criteria,\n            action=action,\n        )\n        self._transitions.append(transition)\n\n        # Add to transition map for faster lookup\n        if source not in self._transition_map:\n            self._transition_map[source] = []\n        self._transition_map[source].append(transition)\n\n    return transition\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.create_event","title":"<code>create_event(name)</code>","text":"<p>Create a new event and add it to the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the event</p> required <p>Returns:</p> Name Type Description <code>Event</code> <code>Event</code> <p>The created event</p> Example <p>sm.create_event(\"walk\")</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def create_event(self, name: str) -&gt; Event:\n    \"\"\"\n    Create a new event and add it to the state machine.\n\n    Args:\n        name: Name of the event\n\n    Returns:\n        Event: The created event\n\n    Example:\n        &gt;&gt;&gt; sm.create_event(\"walk\")\n    \"\"\"\n    event = Event(name=name)\n    self.add_events([event])\n    return event\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.create_state","title":"<code>create_state(name, **kwargs)</code>","text":"<p>Create a new state and add it to the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the State constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>The created state</p> Example <p>sm.create_state( ...     name=\"idle\", ...     minimum_time_spent_in_state=2.0, ...     entry_callbacks=[print(\"Entering idle state\")], ...     exit_callbacks=[print(\"Exiting idle state\")], ... )</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def create_state(self, name: str, **kwargs: Any) -&gt; State:\n    \"\"\"\n    Create a new state and add it to the state machine.\n\n    Args:\n        name: Name of the state\n        **kwargs: Additional arguments to pass to the State constructor\n\n    Returns:\n        State: The created state\n\n    Example:\n        &gt;&gt;&gt; sm.create_state(\n        ...     name=\"idle\",\n        ...     minimum_time_spent_in_state=2.0,\n        ...     entry_callbacks=[print(\"Entering idle state\")],\n        ...     exit_callbacks=[print(\"Exiting idle state\")],\n        ... )\n    \"\"\"\n    state = State(name=name, **kwargs)\n    self.add_states([state])\n    return state\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.get_state_by_name","title":"<code>get_state_by_name(name)</code>","text":"<p>Get a state by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the state to find</p> required <p>Returns:</p> Type Description <code>Optional[State]</code> <p>Optional[State]: The state with the given name, or None if not found</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def get_state_by_name(self, name: str) -&gt; Optional[State]:\n    \"\"\"\n    Get a state by its name.\n\n    Args:\n        name: The name of the state to find\n\n    Returns:\n        Optional[State]: The state with the given name, or None if not found\n    \"\"\"\n    for state in self._states:\n        if state.name == name:\n            return state\n    return None\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.start","title":"<code>start(*args, **kwargs)</code>","text":"<p>Start the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the initial state</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the initial state</p> <code>{}</code> Example <p>sm.start(x=1)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def start(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Start the state machine.\n\n    Args:\n        *args: Arguments to pass to the initial state\n        **kwargs: Keyword arguments to pass to the initial state\n\n    Example:\n        &gt;&gt;&gt; sm.start(x=1)\n    \"\"\"\n    if not self._initial_state:\n        raise ValueError(\n            \"No initial state set. Add at least one state with initial_state=True or add a non-exit state.\"\n        )\n\n    self._current_state = self._initial_state\n    self._current_state.enter(*args, **kwargs)\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.stop","title":"<code>stop(*args, **kwargs)</code>","text":"<p>Stop the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the exit state</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the exit state</p> <code>{}</code> Example <p>sm.stop(x=1)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def stop(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Stop the state machine.\n\n    Args:\n        *args: Arguments to pass to the exit state\n        **kwargs: Keyword arguments to pass to the exit state\n\n    Example:\n        &gt;&gt;&gt; sm.stop(x=1)\n    \"\"\"\n    if not self._current_state:\n        raise ValueError(\"State machine isn't active.\")\n\n    self._current_state.exit(*args, **kwargs)\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.StateMachine.update","title":"<code>update(**kwargs)</code>","text":"<p>Update the state machine, checking all possible transitions from the current state. If any transition's criteria are met, the state machine will transition automatically. If multiple transitions exist from the same source state, precedence is given to the first added transition.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Named arguments to pass to transition criteria and actions</p> <code>{}</code> Example <p>sm.update(t=t)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def update(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Update the state machine, checking all possible transitions from the current state.\n    If any transition's criteria are met, the state machine will transition automatically. If multiple\n    transitions exist from the same source state, precedence is given to the first added transition.\n\n    Args:\n        **kwargs: Named arguments to pass to transition criteria and actions\n\n    Example:\n        &gt;&gt;&gt; sm.update(t=t)\n    \"\"\"\n    if not self._current_state:\n        raise ValueError(\"State machine isn't active.\")\n\n    # Check if minimum time in state has elapsed\n    if self._current_state.current_time_in_state &lt; self._current_state.minimum_time_spent_in_state:\n        return\n\n    transitions = self._transition_map.get(self._current_state, [])\n\n    if not transitions:\n        LOGGER.debug(f\"No transitions defined for state {self._current_state.name}\")\n        return\n\n    for transition in transitions:\n        next_state = transition(**kwargs)\n\n        # If state changed, update current state and exit\n        if next_state != self._current_state:\n            self._current_state = next_state\n\n            return\n\n    LOGGER.debug(f\"No valid transitions from state {self._current_state.name}\")\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Transition","title":"<code>Transition</code>","text":"Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>class Transition:\n    def __init__(\n        self,\n        event: Event,\n        source: State,\n        destination: State,\n        criteria: Optional[Callable[..., bool]] = None,\n        action: Optional[Callable[..., None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Transition class that handles state transitions in a finite state machine.\n        A transition connects a source state to a destination state and is triggered by an event.\n        It should include criteria that must be met for the transition to occur and actions to execute\n        during the transition.\n\n        Args:\n            event: The event that triggers this transition\n            source: The source state\n            destination: The destination state\n            criteria: Optional function that returns True if transition should occur\n            action: Optional function to execute during transition\n\n        Example:\n            &gt;&gt;&gt; transition = Transition(\n            ...     event=Event(\"walk\"),\n            ...     source=State(\"idle\"),\n            ...     destination=State(\"walking\"),\n            ...     criteria=lambda: True,\n            ...     action=lambda: print(\"Walking\")\n            ... )\n        \"\"\"\n        self._event: Event = event\n        self._source_state: State = source\n        self._destination_state: State = destination\n\n        self._criteria: Optional[Callable[..., bool]] = criteria\n        self._action: Optional[Callable[..., None]] = action\n\n    def __call__(self, **kwargs: Any) -&gt; State:\n        if not self._criteria:\n            criteria_met = True\n        else:\n            try:\n                import inspect\n\n                # Filter kwargs to only include parameters the function expects\n                criteria_params = inspect.signature(self._criteria).parameters\n                filtered_kwargs = {k: v for k, v in kwargs.items() if k in criteria_params}\n\n                criteria_met = self._criteria(**filtered_kwargs)\n            except Exception as e:\n                LOGGER.warning(f\"Failed to call criteria function for transition {self}: {e}\")\n                return self._source_state\n\n        if criteria_met:\n            if self._action:\n                try:\n                    import inspect\n\n                    # Filter kwargs to only include parameters the function expects\n                    action_params = inspect.signature(self._action).parameters\n                    filtered_kwargs = {k: v for k, v in kwargs.items() if k in action_params}\n\n                    self._action(**filtered_kwargs)\n                except Exception as e:\n                    LOGGER.warning(f\"Failed to call action function for transition {self}: {e}\")\n\n            self._source_state.exit(**kwargs)\n            self._destination_state.enter(**kwargs)\n\n            return self._destination_state\n        else:\n            return self._source_state\n\n    def __repr__(self) -&gt; str:\n        return f\"Transition[{self._source_state.name} -&gt; {self._destination_state.name}]\"\n\n    def add_criteria(self, callback: Callable[[Any], bool]) -&gt; None:\n        \"\"\"\n        Add a criteria function to the transition.\n\n        Args:\n            callback: Function that returns True if transition should occur\n\n        Example:\n            &gt;&gt;&gt; transition.add_criteria(lambda: if t &gt; 0: True)\n        \"\"\"\n        self._criteria = callback\n\n    def add_action(self, callback: Callable[[Any], Any]) -&gt; None:\n        \"\"\"\n        Add an action function to the transition.\n\n        Args:\n            callback: Function to execute during transition\n\n        Example:\n            &gt;&gt;&gt; transition.add_action(lambda: print(\"Walking\"))\n        \"\"\"\n        self._action = callback\n\n    @property\n    def event(self) -&gt; Event:\n        \"\"\"\n        Get the event that triggers this transition.\n\n        Returns:\n            Event: The event that triggers this transition\n        \"\"\"\n        return self._event\n\n    @property\n    def source_state(self) -&gt; State:\n        \"\"\"\n        Get the source state of this transition.\n\n        Returns:\n            State: The source state of this transition\n        \"\"\"\n        return self._source_state\n\n    @property\n    def destination_state(self) -&gt; State:\n        \"\"\"\n        Get the destination state of this transition.\n\n        Returns:\n            State: The destination state of this transition\n        \"\"\"\n        return self._destination_state\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Transition.destination_state","title":"<code>destination_state: State</code>  <code>property</code>","text":"<p>Get the destination state of this transition.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>The destination state of this transition</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Transition.event","title":"<code>event: Event</code>  <code>property</code>","text":"<p>Get the event that triggers this transition.</p> <p>Returns:</p> Name Type Description <code>Event</code> <code>Event</code> <p>The event that triggers this transition</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Transition.source_state","title":"<code>source_state: State</code>  <code>property</code>","text":"<p>Get the source state of this transition.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>The source state of this transition</p>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Transition.__init__","title":"<code>__init__(event, source, destination, criteria=None, action=None)</code>","text":"<p>Transition class that handles state transitions in a finite state machine. A transition connects a source state to a destination state and is triggered by an event. It should include criteria that must be met for the transition to occur and actions to execute during the transition.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event that triggers this transition</p> required <code>source</code> <code>State</code> <p>The source state</p> required <code>destination</code> <code>State</code> <p>The destination state</p> required <code>criteria</code> <code>Optional[Callable[..., bool]]</code> <p>Optional function that returns True if transition should occur</p> <code>None</code> <code>action</code> <code>Optional[Callable[..., None]]</code> <p>Optional function to execute during transition</p> <code>None</code> Example <p>transition = Transition( ...     event=Event(\"walk\"), ...     source=State(\"idle\"), ...     destination=State(\"walking\"), ...     criteria=lambda: True, ...     action=lambda: print(\"Walking\") ... )</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __init__(\n    self,\n    event: Event,\n    source: State,\n    destination: State,\n    criteria: Optional[Callable[..., bool]] = None,\n    action: Optional[Callable[..., None]] = None,\n) -&gt; None:\n    \"\"\"\n    Transition class that handles state transitions in a finite state machine.\n    A transition connects a source state to a destination state and is triggered by an event.\n    It should include criteria that must be met for the transition to occur and actions to execute\n    during the transition.\n\n    Args:\n        event: The event that triggers this transition\n        source: The source state\n        destination: The destination state\n        criteria: Optional function that returns True if transition should occur\n        action: Optional function to execute during transition\n\n    Example:\n        &gt;&gt;&gt; transition = Transition(\n        ...     event=Event(\"walk\"),\n        ...     source=State(\"idle\"),\n        ...     destination=State(\"walking\"),\n        ...     criteria=lambda: True,\n        ...     action=lambda: print(\"Walking\")\n        ... )\n    \"\"\"\n    self._event: Event = event\n    self._source_state: State = source\n    self._destination_state: State = destination\n\n    self._criteria: Optional[Callable[..., bool]] = criteria\n    self._action: Optional[Callable[..., None]] = action\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Transition.add_action","title":"<code>add_action(callback)</code>","text":"<p>Add an action function to the transition.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], Any]</code> <p>Function to execute during transition</p> required Example <p>transition.add_action(lambda: print(\"Walking\"))</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_action(self, callback: Callable[[Any], Any]) -&gt; None:\n    \"\"\"\n    Add an action function to the transition.\n\n    Args:\n        callback: Function to execute during transition\n\n    Example:\n        &gt;&gt;&gt; transition.add_action(lambda: print(\"Walking\"))\n    \"\"\"\n    self._action = callback\n</code></pre>"},{"location":"modules/control/fsm/#opensourceleg.control.fsm.Transition.add_criteria","title":"<code>add_criteria(callback)</code>","text":"<p>Add a criteria function to the transition.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], bool]</code> <p>Function that returns True if transition should occur</p> required Example <p>transition.add_criteria(lambda: if t &gt; 0: True)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_criteria(self, callback: Callable[[Any], bool]) -&gt; None:\n    \"\"\"\n    Add a criteria function to the transition.\n\n    Args:\n        callback: Function that returns True if transition should occur\n\n    Example:\n        &gt;&gt;&gt; transition.add_criteria(lambda: if t &gt; 0: True)\n    \"\"\"\n    self._criteria = callback\n</code></pre>"},{"location":"modules/robots/osl/","title":"OSL","text":""},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg","title":"<code>OpenSourceLeg</code>","text":"<p>               Bases: <code>RobotBase[TActuator, TSensor]</code></p> <p>Open Source Leg (OSL) class derived from RobotBase.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>class OpenSourceLeg(RobotBase[TActuator, TSensor]):\n    \"\"\"\n    Open Source Leg (OSL) class derived from RobotBase.\n    \"\"\"\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the OSL.\n        \"\"\"\n        super().start()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the OSL.\n        \"\"\"\n        super().stop()\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the robot.\n        \"\"\"\n        super().update()\n\n    def home(self) -&gt; None:\n        \"\"\"\n        Call the home method for all actuators.\n        \"\"\"\n        for actuator in self.actuators.values():\n            actuator.home()\n\n    def make_encoder_maps(self) -&gt; None:\n        \"\"\"\n        Make encoder maps for all actuators.\n        \"\"\"\n        for actuator in self.actuators.values():\n            if hasattr(actuator, \"make_encoder_map\"):\n                actuator.make_encoder_map()\n            else:\n                LOGGER.warning(f\"[{actuator.__repr__()}] No encoder map method found. Skipping.\")\n\n    @property\n    def knee(self) -&gt; Union[TActuator, ActuatorBase]:\n        \"\"\"\n        Get the knee actuator.\n\n        Returns:\n            Union[TActuator, ActuatorBase]: The knee actuator.\n        \"\"\"\n        try:\n            return self.actuators[\"knee\"]\n        except KeyError:\n            LOGGER.error(\"Knee actuator not found. Please check for `knee` key in the actuators dictionary.\")\n            exit(1)\n\n    @property\n    def ankle(self) -&gt; Union[TActuator, ActuatorBase]:\n        \"\"\"\n        Get the ankle actuator.\n\n        Returns:\n            Union[TActuator, ActuatorBase]: The ankle actuator.\n        \"\"\"\n        try:\n            return self.actuators[\"ankle\"]\n        except KeyError:\n            LOGGER.error(\"Ankle actuator not found. Please check for `ankle` key in the actuators dictionary.\")\n            exit(1)\n\n    @property\n    def loadcell(self) -&gt; Union[TSensor, LoadcellBase]:\n        \"\"\"\n        Get the loadcell sensor.\n\n        Returns:\n            Union[TSensor, LoadcellBase]: The loadcell sensor.\n        \"\"\"\n        try:\n            return self.sensors[\"loadcell\"]\n        except KeyError:\n            LOGGER.error(\"Loadcell sensor not found. Please check for `loadcell` key in the sensors dictionary.\")\n            exit(1)\n\n    @property\n    def joint_encoder_knee(self) -&gt; Union[TSensor, SensorBase]:\n        \"\"\"\n        Get the knee joint encoder sensor.\n\n        Returns:\n            Union[TSensor, SensorBase]: The knee joint encoder sensor.\n        \"\"\"\n        try:\n            return self.sensors[\"joint_encoder_knee\"]\n        except KeyError:\n            LOGGER.error(\n                \"Knee joint encoder sensor not found.\"\n                \"Please check for `joint_encoder_knee` key in the sensors dictionary.\"\n            )\n            exit(1)\n\n    @property\n    def joint_encoder_ankle(self) -&gt; Union[TSensor, SensorBase]:\n        \"\"\"\n        Get the ankle joint encoder sensor.\n\n        Returns:\n            Union[TSensor, SensorBase]: The ankle joint encoder sensor.\n        \"\"\"\n        try:\n            return self.sensors[\"joint_encoder_ankle\"]\n        except KeyError:\n            LOGGER.error(\n                \"Ankle joint encoder sensor not found.\"\n                \"Please check for `joint_encoder_ankle` key in the sensors dictionary.\"\n            )\n            exit(1)\n</code></pre>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.ankle","title":"<code>ankle: Union[TActuator, ActuatorBase]</code>  <code>property</code>","text":"<p>Get the ankle actuator.</p> <p>Returns:</p> Type Description <code>Union[TActuator, ActuatorBase]</code> <p>Union[TActuator, ActuatorBase]: The ankle actuator.</p>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.joint_encoder_ankle","title":"<code>joint_encoder_ankle: Union[TSensor, SensorBase]</code>  <code>property</code>","text":"<p>Get the ankle joint encoder sensor.</p> <p>Returns:</p> Type Description <code>Union[TSensor, SensorBase]</code> <p>Union[TSensor, SensorBase]: The ankle joint encoder sensor.</p>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.joint_encoder_knee","title":"<code>joint_encoder_knee: Union[TSensor, SensorBase]</code>  <code>property</code>","text":"<p>Get the knee joint encoder sensor.</p> <p>Returns:</p> Type Description <code>Union[TSensor, SensorBase]</code> <p>Union[TSensor, SensorBase]: The knee joint encoder sensor.</p>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.knee","title":"<code>knee: Union[TActuator, ActuatorBase]</code>  <code>property</code>","text":"<p>Get the knee actuator.</p> <p>Returns:</p> Type Description <code>Union[TActuator, ActuatorBase]</code> <p>Union[TActuator, ActuatorBase]: The knee actuator.</p>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.loadcell","title":"<code>loadcell: Union[TSensor, LoadcellBase]</code>  <code>property</code>","text":"<p>Get the loadcell sensor.</p> <p>Returns:</p> Type Description <code>Union[TSensor, LoadcellBase]</code> <p>Union[TSensor, LoadcellBase]: The loadcell sensor.</p>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.home","title":"<code>home()</code>","text":"<p>Call the home method for all actuators.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def home(self) -&gt; None:\n    \"\"\"\n    Call the home method for all actuators.\n    \"\"\"\n    for actuator in self.actuators.values():\n        actuator.home()\n</code></pre>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.make_encoder_maps","title":"<code>make_encoder_maps()</code>","text":"<p>Make encoder maps for all actuators.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def make_encoder_maps(self) -&gt; None:\n    \"\"\"\n    Make encoder maps for all actuators.\n    \"\"\"\n    for actuator in self.actuators.values():\n        if hasattr(actuator, \"make_encoder_map\"):\n            actuator.make_encoder_map()\n        else:\n            LOGGER.warning(f\"[{actuator.__repr__()}] No encoder map method found. Skipping.\")\n</code></pre>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.start","title":"<code>start()</code>","text":"<p>Start the OSL.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the OSL.\n    \"\"\"\n    super().start()\n</code></pre>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.stop","title":"<code>stop()</code>","text":"<p>Stop the OSL.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the OSL.\n    \"\"\"\n    super().stop()\n</code></pre>"},{"location":"modules/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.update","title":"<code>update()</code>","text":"<p>Update the robot.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Update the robot.\n    \"\"\"\n    super().update()\n</code></pre>"},{"location":"modules/robots/robots/","title":"Base","text":"<p>Module for the RobotBase abstract class.</p> <p>This module defines an abstract base class, <code>RobotBase</code>, that provides a template for a robot system integrating actuators and sensors. The class supports context management and defines abstract methods for starting, stopping, and updating the robot's components.</p> Type Parameters <p>TActuator: A type that must be a subclass of ActuatorBase. TSensor: A type that must be a subclass of SensorBase.</p>"},{"location":"modules/robots/robots/#opensourceleg.robots.base.RobotBase","title":"<code>RobotBase</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[TActuator, TSensor]</code></p> <p>Abstract base class representing a robot composed of actuators and sensors.</p> <p>This class provides the basic structure for a robot, including methods to start, stop, and update its components. It also supports context management so that the robot can be used within a with-statement to automatically start and stop its components.</p> <p>Attributes:</p> Name Type Description <code>actuators</code> <code>dict[str, TActuator]</code> <p>A dictionary mapping actuator names to actuator instances.</p> <code>sensors</code> <code>dict[str, TSensor]</code> <p>A dictionary mapping sensor names to sensor instances.</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>class RobotBase(ABC, Generic[TActuator, TSensor]):\n    \"\"\"\n    Abstract base class representing a robot composed of actuators and sensors.\n\n    This class provides the basic structure for a robot, including methods to start, stop,\n    and update its components. It also supports context management so that the robot\n    can be used within a with-statement to automatically start and stop its components.\n\n    Attributes:\n        actuators: A dictionary mapping actuator names to actuator instances.\n        sensors: A dictionary mapping sensor names to sensor instances.\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: str,\n        actuators: dict[str, TActuator],\n        sensors: dict[str, TSensor],\n    ) -&gt; None:\n        \"\"\"\n        Initialize the RobotBase instance.\n\n        Args:\n            tag: A unique identifier for the robot.\n            actuators: A dictionary of actuators keyed by their names.\n            sensors: A dictionary of sensors keyed by their names.\n        \"\"\"\n        self._tag = tag\n        self.actuators: dict[str, TActuator] = actuators\n        self.sensors: dict[str, TSensor] = sensors\n\n    def __enter__(self) -&gt; \"RobotBase\":\n        \"\"\"\n        Enter the runtime context for the robot.\n\n        This method starts all actuators and sensors and returns the robot instance.\n\n        Returns:\n            The current robot instance.\n\n        Example:\n            &gt;&gt;&gt; with MyRobot() as robot:\n            ...     robot.update()\n        \"\"\"\n        self.start()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"\n        Exit the runtime context for the robot.\n\n        This method stops all actuators and sensors.\n\n        Args:\n            exc_type: The exception type, if an exception occurred.\n            exc_val: The exception value, if an exception occurred.\n            exc_tb: The traceback, if an exception occurred.\n        \"\"\"\n        self.stop()\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"\n        Start all actuators and sensors.\n\n        For each actuator in the actuators dictionary, a debug message is logged and its start method is called.\n        Similarly, for each sensor in the sensors dictionary, a debug message is logged and its start method is called.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; robot = MyRobot()\n            &gt;&gt;&gt; robot.start()\n        \"\"\"\n        for actuator in self.actuators.values():\n            LOGGER.debug(f\"Calling start method of {actuator.tag}\")\n            actuator.start()\n\n        for sensor in self.sensors.values():\n            LOGGER.debug(f\"Calling start method of {sensor}\")\n            sensor.start()\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop all actuators and sensors.\n\n        For each actuator in the actuators dictionary, a debug message is logged and its stop method is called.\n        Similarly, for each sensor in the sensors dictionary, a debug message is logged and its stop method is called.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; robot = MyRobot()\n            &gt;&gt;&gt; robot.start()\n            ... # Do something with the robot\n            &gt;&gt;&gt; robot.stop()\n        \"\"\"\n        for actuator in self.actuators.values():\n            LOGGER.debug(f\"Calling stop method of {actuator.tag}\")\n            actuator.stop()\n\n        for sensor in self.sensors.values():\n            LOGGER.debug(f\"Calling stop method of {sensor}\")\n            sensor.stop()\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        \"\"\"\n        Update all actuators and sensors.\n\n        This method calls the update method for each actuator and sensor to refresh their state.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; robot = MyRobot()\n            &gt;&gt;&gt; robot.start()\n            &gt;&gt;&gt; robot.update()\n        \"\"\"\n        for actuator in self.actuators.values():\n            actuator.update()\n\n        for sensor in self.sensors.values():\n            sensor.update()\n\n    @property\n    def tag(self) -&gt; str:\n        \"\"\"\n        Get the unique identifier (tag) of the robot.\n\n        Returns:\n            The robot's tag.\n\n        Example:\n            &gt;&gt;&gt; robot = MyRobot()\n            &gt;&gt;&gt; robot.tag\n            \"my_robot\"\n        \"\"\"\n        return self._tag\n</code></pre>"},{"location":"modules/robots/robots/#opensourceleg.robots.base.RobotBase.tag","title":"<code>tag: str</code>  <code>property</code>","text":"<p>Get the unique identifier (tag) of the robot.</p> <p>Returns:</p> Type Description <code>str</code> <p>The robot's tag.</p> Example <p>robot = MyRobot() robot.tag \"my_robot\"</p>"},{"location":"modules/robots/robots/#opensourceleg.robots.base.RobotBase.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context for the robot.</p> <p>This method starts all actuators and sensors and returns the robot instance.</p> <p>Returns:</p> Type Description <code>RobotBase</code> <p>The current robot instance.</p> Example <p>with MyRobot() as robot: ...     robot.update()</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>def __enter__(self) -&gt; \"RobotBase\":\n    \"\"\"\n    Enter the runtime context for the robot.\n\n    This method starts all actuators and sensors and returns the robot instance.\n\n    Returns:\n        The current robot instance.\n\n    Example:\n        &gt;&gt;&gt; with MyRobot() as robot:\n        ...     robot.update()\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"modules/robots/robots/#opensourceleg.robots.base.RobotBase.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the runtime context for the robot.</p> <p>This method stops all actuators and sensors.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>The exception type, if an exception occurred.</p> required <code>exc_val</code> <code>Any</code> <p>The exception value, if an exception occurred.</p> required <code>exc_tb</code> <code>Any</code> <p>The traceback, if an exception occurred.</p> required Source code in <code>opensourceleg/robots/base.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"\n    Exit the runtime context for the robot.\n\n    This method stops all actuators and sensors.\n\n    Args:\n        exc_type: The exception type, if an exception occurred.\n        exc_val: The exception value, if an exception occurred.\n        exc_tb: The traceback, if an exception occurred.\n    \"\"\"\n    self.stop()\n</code></pre>"},{"location":"modules/robots/robots/#opensourceleg.robots.base.RobotBase.__init__","title":"<code>__init__(tag, actuators, sensors)</code>","text":"<p>Initialize the RobotBase instance.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>A unique identifier for the robot.</p> required <code>actuators</code> <code>dict[str, TActuator]</code> <p>A dictionary of actuators keyed by their names.</p> required <code>sensors</code> <code>dict[str, TSensor]</code> <p>A dictionary of sensors keyed by their names.</p> required Source code in <code>opensourceleg/robots/base.py</code> <pre><code>def __init__(\n    self,\n    tag: str,\n    actuators: dict[str, TActuator],\n    sensors: dict[str, TSensor],\n) -&gt; None:\n    \"\"\"\n    Initialize the RobotBase instance.\n\n    Args:\n        tag: A unique identifier for the robot.\n        actuators: A dictionary of actuators keyed by their names.\n        sensors: A dictionary of sensors keyed by their names.\n    \"\"\"\n    self._tag = tag\n    self.actuators: dict[str, TActuator] = actuators\n    self.sensors: dict[str, TSensor] = sensors\n</code></pre>"},{"location":"modules/robots/robots/#opensourceleg.robots.base.RobotBase.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start all actuators and sensors.</p> <p>For each actuator in the actuators dictionary, a debug message is logged and its start method is called. Similarly, for each sensor in the sensors dictionary, a debug message is logged and its start method is called.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>robot = MyRobot() robot.start()</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"\n    Start all actuators and sensors.\n\n    For each actuator in the actuators dictionary, a debug message is logged and its start method is called.\n    Similarly, for each sensor in the sensors dictionary, a debug message is logged and its start method is called.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; robot = MyRobot()\n        &gt;&gt;&gt; robot.start()\n    \"\"\"\n    for actuator in self.actuators.values():\n        LOGGER.debug(f\"Calling start method of {actuator.tag}\")\n        actuator.start()\n\n    for sensor in self.sensors.values():\n        LOGGER.debug(f\"Calling start method of {sensor}\")\n        sensor.start()\n</code></pre>"},{"location":"modules/robots/robots/#opensourceleg.robots.base.RobotBase.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop all actuators and sensors.</p> <p>For each actuator in the actuators dictionary, a debug message is logged and its stop method is called. Similarly, for each sensor in the sensors dictionary, a debug message is logged and its stop method is called.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>robot = MyRobot() robot.start() ... # Do something with the robot robot.stop()</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop all actuators and sensors.\n\n    For each actuator in the actuators dictionary, a debug message is logged and its stop method is called.\n    Similarly, for each sensor in the sensors dictionary, a debug message is logged and its stop method is called.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; robot = MyRobot()\n        &gt;&gt;&gt; robot.start()\n        ... # Do something with the robot\n        &gt;&gt;&gt; robot.stop()\n    \"\"\"\n    for actuator in self.actuators.values():\n        LOGGER.debug(f\"Calling stop method of {actuator.tag}\")\n        actuator.stop()\n\n    for sensor in self.sensors.values():\n        LOGGER.debug(f\"Calling stop method of {sensor}\")\n        sensor.stop()\n</code></pre>"},{"location":"modules/robots/robots/#opensourceleg.robots.base.RobotBase.update","title":"<code>update()</code>  <code>abstractmethod</code>","text":"<p>Update all actuators and sensors.</p> <p>This method calls the update method for each actuator and sensor to refresh their state.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>robot = MyRobot() robot.start() robot.update()</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"\n    Update all actuators and sensors.\n\n    This method calls the update method for each actuator and sensor to refresh their state.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; robot = MyRobot()\n        &gt;&gt;&gt; robot.start()\n        &gt;&gt;&gt; robot.update()\n    \"\"\"\n    for actuator in self.actuators.values():\n        actuator.update()\n\n    for sensor in self.sensors.values():\n        sensor.update()\n</code></pre>"},{"location":"modules/sensors/adc/","title":"ADC","text":"<p>Module for interfacing with the ADS131M0x family of ADC chips.</p> <p>This module provides a class for communicating with and configuring the ADS131M0x ADC chips. It supports SPI communication to reset, configure, calibrate, and read data from the ADC in units of millivolts.</p>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x","title":"<code>ADS131M0x</code>","text":"<p>               Bases: <code>ADCBase</code></p> <p>Class used for communication with the ADS131M0x family of ADC chips.</p> <p>This class allows you to configure the ADS131M0x family of chips as well as read out the ADC values in units of millivolts.</p> Class Attributes <p>_MAX_CHANNELS: Maximum number of channels supported. _BYTES_PER_WORD: Number of bytes per word in SPI communication. _RESOLUTION: ADC resolution in bits. _SPI_MODE: SPI mode used for communication. _BLANK_WORD: Blank word for SPI messages. _RESET_WORD: SPI command for resetting the ADC. _STANDBY_WORD: SPI command for putting the ADC in standby. _WAKEUP_WORD: SPI command for waking up the ADC. _RREG_PREFIX: Prefix for read register commands. _WREG_PREFIX: Prefix for write register commands. _ID_REG: Address of the ID register. _STATUS_REG: Address of the status register. _MODE_REG: Address of the mode register. _CLOCK_REG: Address of the clock register. _GAIN1_REG: Address of the first gain register. _GAIN2_REG: Address of the second gain register. _CFG_REG: Address of the configuration register. _DISABLE_CHANNELS_CLOCK: Value to disable channel clocks. _ENABLE_CHANNELS_CLOCK: Value to enable channel clocks. _MODE_CFG: Mode configuration value. _OCAL_MSB_ADDRS: List of MSB addresses for offset calibration. _OCAL_LSB_ADDRS: List of LSB addresses for offset calibration. _GCAL_MSB_ADDRS: List of MSB addresses for gain calibration. _GCAL_LSB_ADDRS: List of LSB addresses for gain calibration. _CHANNEL_CFG_ADDRS: List of addresses for channel configuration. _GCAL_STEP_SIZE: Step size used in gain calibration.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>class ADS131M0x(ADCBase):\n    \"\"\"\n    Class used for communication with the ADS131M0x family of ADC chips.\n\n    This class allows you to configure the ADS131M0x family of chips as well as\n    read out the ADC values in units of millivolts.\n\n    Class Attributes:\n        _MAX_CHANNELS: Maximum number of channels supported.\n        _BYTES_PER_WORD: Number of bytes per word in SPI communication.\n        _RESOLUTION: ADC resolution in bits.\n        _SPI_MODE: SPI mode used for communication.\n        _BLANK_WORD: Blank word for SPI messages.\n        _RESET_WORD: SPI command for resetting the ADC.\n        _STANDBY_WORD: SPI command for putting the ADC in standby.\n        _WAKEUP_WORD: SPI command for waking up the ADC.\n        _RREG_PREFIX: Prefix for read register commands.\n        _WREG_PREFIX: Prefix for write register commands.\n        _ID_REG: Address of the ID register.\n        _STATUS_REG: Address of the status register.\n        _MODE_REG: Address of the mode register.\n        _CLOCK_REG: Address of the clock register.\n        _GAIN1_REG: Address of the first gain register.\n        _GAIN2_REG: Address of the second gain register.\n        _CFG_REG: Address of the configuration register.\n        _DISABLE_CHANNELS_CLOCK: Value to disable channel clocks.\n        _ENABLE_CHANNELS_CLOCK: Value to enable channel clocks.\n        _MODE_CFG: Mode configuration value.\n        _OCAL_MSB_ADDRS: List of MSB addresses for offset calibration.\n        _OCAL_LSB_ADDRS: List of LSB addresses for offset calibration.\n        _GCAL_MSB_ADDRS: List of MSB addresses for gain calibration.\n        _GCAL_LSB_ADDRS: List of LSB addresses for gain calibration.\n        _CHANNEL_CFG_ADDRS: List of addresses for channel configuration.\n        _GCAL_STEP_SIZE: Step size used in gain calibration.\n    \"\"\"\n\n    _MAX_CHANNELS = 8\n    _BYTES_PER_WORD = 3\n    _RESOLUTION = 24\n    _SPI_MODE = 1\n\n    _BLANK_WORD: ClassVar = [0x00, 0x00, 0x00]\n    # SPI Commands\n    _RESET_WORD: ClassVar = [0x00, 0x11, 0x00]\n    _STANDBY_WORD: ClassVar = [0x00, 0x22, 0x00]\n    _WAKEUP_WORD: ClassVar = [0x00, 0x33, 0x00]\n    _RREG_PREFIX = 0b101\n    _WREG_PREFIX = 0b011\n\n    # Multi-channel setting register addresses\n    _ID_REG = 0x00\n    _STATUS_REG = 0x01\n    _MODE_REG = 0x02\n    _CLOCK_REG = 0x03\n    _GAIN1_REG = 0x04\n    _GAIN2_REG = 0x05\n    _CFG_REG = 0x06\n\n    # Specific values to be written to registers\n    _DISABLE_CHANNELS_CLOCK = 0x000E\n    _ENABLE_CHANNELS_CLOCK = 0xFF0E\n    _MODE_CFG = 0x0110\n\n    # Channel specific setting register addresses\n    _OCAL_MSB_ADDRS: ClassVar = [0x0A, 0x0F, 0x14, 0x19, 0x1E, 0x23, 0x28, 0x2D]\n    _OCAL_LSB_ADDRS: ClassVar = [0x0B, 0x10, 0x15, 0x1A, 0x1F, 0x24, 0x29, 0x2E]\n    _GCAL_MSB_ADDRS: ClassVar = [0x0C, 0x11, 0x16, 0x1B, 0x20, 0x25, 0x2A, 0x2F]\n    _GCAL_LSB_ADDRS: ClassVar = [0x0D, 0x12, 0x17, 0x1C, 0x21, 0x26, 0x2B, 0x30]\n    _CHANNEL_CFG_ADDRS: ClassVar = [0x09, 0x0E, 0x13, 0x18, 0x1D, 0x22, 0x27, 0x2C]\n\n    _GCAL_STEP_SIZE = 1.19e-7\n\n    def __init__(\n        self,\n        spi_bus: int = 0,\n        spi_chip: int = 0,\n        num_channels: int = 6,\n        max_speed_hz: int = 8192000,\n        channel_gains: list[int] = [32, 128] * 3,\n        voltage_reference: float = 1.2,\n        gain_error: Optional[list[int]] = None,\n    ):\n        \"\"\"\n        Initializes the ADS131M0x instance.\n\n        Validates the provided configuration and sets up internal parameters for SPI communication,\n        channel gains, and calibration.\n\n        Args:\n            spi_bus: SPI bus number where the ADC is connected. Default is 0.\n            spi_chip: Chip select (CS) signal number for the ADC. Default is 0.\n            num_channels: Number of active channels on the ADC. Default is 6.\n            max_speed_hz: Maximum SPI clock speed in hertz. Default is 8192000.\n            channel_gains: List of gains for each channel's programmable gain amplifier.\n                Default is [32, 128] repeated 3 times (for 6 channels).\n            voltage_reference: Reference voltage used by the ADC. Default is 1.2 V.\n            gain_error: Optional user-calculated gain error corrections per channel.\n                Default is an empty list.\n\n        Raises:\n            ValueError: If the length of channel_gains does not equal num_channels,\n                        or if gain_error is provided and its length does not equal num_channels,\n                        or if any gain is not a power of 2 between 1 and 128.\n        \"\"\"\n        if gain_error is None:\n            gain_error = []\n        if len(channel_gains) != num_channels:\n            raise ValueError(\"Length of channel_gains does not equal number of channels\")\n        if gain_error != [] and len(gain_error) != num_channels:\n            raise ValueError(\"Length of channel_gains does not equal number of channels\")\n\n        self._spi_bus = spi_bus\n        self._spi_chip = spi_chip\n        self._num_channels = num_channels\n        self._max_speed_hz = max_speed_hz\n        self._gains = [0] * num_channels\n        for i in range(num_channels):\n            gain = int(math.log2(channel_gains[i]))\n            if gain != math.log2(channel_gains[i]):\n                raise ValueError(\"Gain must be a power of 2 between 1 and 128\")\n            self._gains[i] = gain\n\n        self._voltage_reference = voltage_reference\n        self._gain_error = gain_error\n        self._spi = spidev.SpiDev()\n        self._streaming = False\n        self._words_per_frame = 2 + num_channels\n\n        self._ready_status = 0x05 &lt;&lt; 8\n        for i in range(self._num_channels):\n            self._ready_status |= 1 &lt;&lt; i\n\n        self._data = [0.0] * num_channels\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the ADS131M0x instance.\n\n        Returns:\n            The string \"ADS131M0x\".\n        \"\"\"\n        return \"ADS131M0x\"\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Open the SPI port, reset the ADC, configure gain settings, and begin streaming ADC data.\n\n        This method initializes the SPI communication, resets the device, sets the channel gains,\n        transitions the device to continuous conversion mode, and clears any stale data.\n        \"\"\"\n        self._spi.open(self._spi_bus, self._spi_chip)\n        self._spi.max_speed_hz = self._max_speed_hz\n        self._spi.mode = self._SPI_MODE\n\n        self.reset()\n        self._set_gain()\n        self._set_device_state(1)\n        self._clear_stale_data()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop streaming ADC data and close the SPI port.\n\n        This method transitions the ADC to standby mode and closes the SPI connection.\n        \"\"\"\n        self._set_device_state(0)\n        self._spi.close()\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset all ADC register values.\n\n        Sends a reset command followed by blank words to initialize the device registers.\n        \"\"\"\n        self._spi.xfer2(self._RESET_WORD + self._BLANK_WORD * (self._words_per_frame - 1))\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Read ADC data from the device.\n\n        Waits until the ADC channels are ready to be read and then updates the internal data\n        with the latest voltage values in millivolts.\n        \"\"\"\n        while not self._ready_to_read():\n            sleep(0.001)\n        self._data = self._read_data_millivolts()\n\n    def calibrate(self) -&gt; None:\n        \"\"\"\n        Perform offset and gain calibration on the ADC.\n\n        This method performs an offset calibration (zeroing) and, if gain error corrections\n        are provided, performs a gain calibration.\n        \"\"\"\n        self._offset_calibration()\n        if self._gain_error is not None:\n            self._gain_calibration()\n\n    def read_register(self, address: int) -&gt; int:\n        \"\"\"\n        Read a register value from the ADC.\n\n        Args:\n            address: The address of the register to read.\n\n        Returns:\n            The value read from the register.\n        \"\"\"\n        msg = (address &lt;&lt; 7) | (self._RREG_PREFIX &lt;&lt; 13)\n        word = self._message_to_word(msg)\n        rsp = self._spi_message(word)\n        return int(rsp[0] &lt;&lt; 8 | rsp[1])\n\n    def write_register(self, address: int, reg_val: int) -&gt; None:\n        \"\"\"\n        Write a value to an ADC register.\n\n        Args:\n            address: The address of the register to write.\n            reg_val: The value to be written to the register.\n        \"\"\"\n        addr_msg = (address &lt;&lt; 7) | (self._WREG_PREFIX &lt;&lt; 13)\n        addr_bytes = self._message_to_word(addr_msg)\n        reg_bytes = self._message_to_word(reg_val)\n        self._spi_message(addr_bytes + reg_bytes)\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the ADC is currently streaming data.\n\n        Returns:\n            True if the ADC is streaming, False otherwise.\n        \"\"\"\n        return self._streaming\n\n    @property\n    def gains(self) -&gt; list[int]:\n        \"\"\"\n        Get the current gain settings for each channel.\n\n        Returns:\n            List of gain values for each channel.\n        \"\"\"\n        return self._gains\n\n    @property\n    def data(self) -&gt; Any:\n        \"\"\"\n        Get the current ADC data.\n\n        Returns:\n            List of voltage values in millivolts for each channel.\n        \"\"\"\n        return self._data\n\n    def _spi_message(self, message: list[int]) -&gt; list[int]:\n        \"\"\"\n        Send a message to the ADC via SPI.\n\n        Args:\n            message: The message to be sent, split into individual bytes.\n\n        Returns:\n            The response from the ADC.\n        \"\"\"\n        self._spi.xfer2(message)\n        return list(self._spi.readbytes(self._BYTES_PER_WORD * self._words_per_frame))\n\n    def _channel_enable(self, state: bool) -&gt; None:\n        \"\"\"\n        Enable or disable ADC channels.\n\n        Args:\n            state: If True, enables the channel clocks; if False, disables them.\n        \"\"\"\n        if state:\n            self.write_register(self._CLOCK_REG, self._ENABLE_CHANNELS_CLOCK)\n        else:\n            self.write_register(self._CLOCK_REG, self._DISABLE_CHANNELS_CLOCK)\n\n    def _set_device_state(self, state: int) -&gt; None:\n        \"\"\"\n        Set the device state (standby or active).\n\n        Args:\n            state: The desired state:\n                0: Standby mode\n                1: Active mode\n        \"\"\"\n        if state == 0:\n            self._spi.xfer2(self._STANDBY_WORD + self._BLANK_WORD * (self._words_per_frame - 1))\n            self._streaming = False\n        elif state == 1:\n            self._spi.xfer2(self._WAKEUP_WORD + self._BLANK_WORD * (self._words_per_frame - 1))\n            self._streaming = True\n\n    def _set_voltage_source(self, source: int) -&gt; None:\n        \"\"\"\n        Set the voltage source for the ADC.\n\n        Args:\n            source: The voltage source selection:\n                0: Internal reference\n                1: External reference\n        \"\"\"\n        for i in range(self._num_channels):\n            self.write_register(self._CHANNEL_CFG_ADDRS[i], source)\n\n    def _clear_stale_data(self) -&gt; None:\n        \"\"\"\n        Clear any stale data from the ADC.\n\n        This method reads and discards any data that may have been buffered\n        in the ADC's internal registers.\n        \"\"\"\n        for _ in range(2):\n            self._read_data_millivolts()\n\n    def _set_gain(self) -&gt; None:\n        \"\"\"\n        Set the gain for each channel.\n\n        This method configures the programmable gain amplifier for each channel\n        based on the values stored in self._gains.\n        \"\"\"\n        gains = self._gains + [0] * (self._MAX_CHANNELS - len(self._gains))\n        self._channel_enable(False)\n        gains_msg = gains[3] &lt;&lt; 12 | gains[2] &lt;&lt; 8 | gains[1] &lt;&lt; 4 | gains[0]\n        self.write_register(self._GAIN1_REG, gains_msg)\n        gains_msg = gains[7] &lt;&lt; 12 | gains[6] &lt;&lt; 8 | gains[5] &lt;&lt; 4 | gains[4]\n        self.write_register(self._GAIN2_REG, gains_msg)\n        self._channel_enable(True)\n\n    def _offset_calibration(self) -&gt; None:\n        \"\"\"\n        Perform offset calibration for all channels.\n\n        This method performs a calibration sequence to determine and store\n        the offset values for each channel.\n        \"\"\"\n        self._set_voltage_source(1)\n        self._clear_stale_data()\n        num_data_points = 1000\n        offsets = [[0] * self._num_channels for _ in range(num_data_points)]\n        for i in range(num_data_points):\n            offsets[i] = self._read_data_counts()\n        offset_avg = [int(sum(values) / len(values)) for values in zip(*offsets)]\n        for i in range(self._num_channels):\n            self.write_register(self._OCAL_MSB_ADDRS[i], offset_avg[i] &gt;&gt; 8)\n            self.write_register(self._OCAL_LSB_ADDRS[i], (offset_avg[i] &lt;&lt; 8) &amp; 0xFF00)\n        self._set_voltage_source(0)\n\n    def _gain_calibration(self) -&gt; None:\n        \"\"\"\n        Perform gain calibration for all channels.\n\n        This method performs a calibration sequence to determine and store\n        the gain values for each channel.\n        \"\"\"\n        for i in range(self._num_channels):\n            gain_correction = (1 + self._gain_error[i]) / self._GCAL_STEP_SIZE\n            self.write_register(self._GCAL_MSB_ADDRS[i], int(gain_correction) &gt;&gt; 8)\n\n    def _message_to_word(self, msg: int) -&gt; list[int]:\n        \"\"\"\n        Convert a message to a word format for SPI communication.\n\n        Args:\n            msg: The integer message to convert.\n\n        Returns:\n            List of bytes representing the message.\n        \"\"\"\n        word = [0] * 3\n        word[0] = (msg &gt;&gt; 8) &amp; 0xFF\n        word[1] = msg &amp; 0xFF\n        return word\n\n    def _ready_to_read(self) -&gt; bool:\n        \"\"\"\n        Check if the ADC is ready to be read.\n\n        Returns:\n            True if the ADC is ready to be read, False otherwise.\n        \"\"\"\n        reply = self.read_register(self._STATUS_REG)\n        return reply == self._ready_status\n\n    def _read_data_millivolts(self) -&gt; list[float]:\n        \"\"\"\n        Read ADC data in millivolts.\n\n        Returns:\n            List of voltage values in millivolts for each channel.\n        \"\"\"\n        mV = [\n            1000 * ((dat) / (2 ** (self._RESOLUTION - 1)) * self._voltage_reference) for dat in self._read_data_counts()\n        ]\n        return mV\n\n    def _read_data_counts(self) -&gt; list[int]:\n        \"\"\"\n        Read raw ADC data in counts.\n\n        Returns:\n            List of raw ADC counts for each channel.\n        \"\"\"\n        reply = self._spi.readbytes(self._BYTES_PER_WORD * self._words_per_frame)\n        val = [0] * self._num_channels\n        for byte in range(3, self._num_channels * 3 + 1, 3):\n            index = int(byte / 3) - 1\n            val[index] = self._twos_complement(\n                (reply[byte] &lt;&lt; 16) | (reply[byte + 1] &lt;&lt; 8) | reply[byte + 2],\n                self._RESOLUTION,\n            )\n        return val\n\n    def _twos_complement(self, num: int, bits: int) -&gt; int:\n        \"\"\"\n        Convert a number to its two's complement representation.\n\n        Args:\n            num: The unsigned integer.\n            bits: The number of bits used to represent the number.\n\n        Returns:\n            The two's complement representation of the number.\n        \"\"\"\n        val = num\n        if (num &gt;&gt; (bits - 1)) != 0:  # if sign bit is set\n            val = num - (1 &lt;&lt; bits)  # compute negative value\n        return val\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.data","title":"<code>data: Any</code>  <code>property</code>","text":"<p>Get the current ADC data.</p> <p>Returns:</p> Type Description <code>Any</code> <p>List of voltage values in millivolts for each channel.</p>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.gains","title":"<code>gains: list[int]</code>  <code>property</code>","text":"<p>Get the current gain settings for each channel.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of gain values for each channel.</p>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.is_streaming","title":"<code>is_streaming: bool</code>  <code>property</code>","text":"<p>Check if the ADC is currently streaming data.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the ADC is streaming, False otherwise.</p>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.__init__","title":"<code>__init__(spi_bus=0, spi_chip=0, num_channels=6, max_speed_hz=8192000, channel_gains=[32, 128] * 3, voltage_reference=1.2, gain_error=None)</code>","text":"<p>Initializes the ADS131M0x instance.</p> <p>Validates the provided configuration and sets up internal parameters for SPI communication, channel gains, and calibration.</p> <p>Parameters:</p> Name Type Description Default <code>spi_bus</code> <code>int</code> <p>SPI bus number where the ADC is connected. Default is 0.</p> <code>0</code> <code>spi_chip</code> <code>int</code> <p>Chip select (CS) signal number for the ADC. Default is 0.</p> <code>0</code> <code>num_channels</code> <code>int</code> <p>Number of active channels on the ADC. Default is 6.</p> <code>6</code> <code>max_speed_hz</code> <code>int</code> <p>Maximum SPI clock speed in hertz. Default is 8192000.</p> <code>8192000</code> <code>channel_gains</code> <code>list[int]</code> <p>List of gains for each channel's programmable gain amplifier. Default is [32, 128] repeated 3 times (for 6 channels).</p> <code>[32, 128] * 3</code> <code>voltage_reference</code> <code>float</code> <p>Reference voltage used by the ADC. Default is 1.2 V.</p> <code>1.2</code> <code>gain_error</code> <code>Optional[list[int]]</code> <p>Optional user-calculated gain error corrections per channel. Default is an empty list.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of channel_gains does not equal num_channels,         or if gain_error is provided and its length does not equal num_channels,         or if any gain is not a power of 2 between 1 and 128.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def __init__(\n    self,\n    spi_bus: int = 0,\n    spi_chip: int = 0,\n    num_channels: int = 6,\n    max_speed_hz: int = 8192000,\n    channel_gains: list[int] = [32, 128] * 3,\n    voltage_reference: float = 1.2,\n    gain_error: Optional[list[int]] = None,\n):\n    \"\"\"\n    Initializes the ADS131M0x instance.\n\n    Validates the provided configuration and sets up internal parameters for SPI communication,\n    channel gains, and calibration.\n\n    Args:\n        spi_bus: SPI bus number where the ADC is connected. Default is 0.\n        spi_chip: Chip select (CS) signal number for the ADC. Default is 0.\n        num_channels: Number of active channels on the ADC. Default is 6.\n        max_speed_hz: Maximum SPI clock speed in hertz. Default is 8192000.\n        channel_gains: List of gains for each channel's programmable gain amplifier.\n            Default is [32, 128] repeated 3 times (for 6 channels).\n        voltage_reference: Reference voltage used by the ADC. Default is 1.2 V.\n        gain_error: Optional user-calculated gain error corrections per channel.\n            Default is an empty list.\n\n    Raises:\n        ValueError: If the length of channel_gains does not equal num_channels,\n                    or if gain_error is provided and its length does not equal num_channels,\n                    or if any gain is not a power of 2 between 1 and 128.\n    \"\"\"\n    if gain_error is None:\n        gain_error = []\n    if len(channel_gains) != num_channels:\n        raise ValueError(\"Length of channel_gains does not equal number of channels\")\n    if gain_error != [] and len(gain_error) != num_channels:\n        raise ValueError(\"Length of channel_gains does not equal number of channels\")\n\n    self._spi_bus = spi_bus\n    self._spi_chip = spi_chip\n    self._num_channels = num_channels\n    self._max_speed_hz = max_speed_hz\n    self._gains = [0] * num_channels\n    for i in range(num_channels):\n        gain = int(math.log2(channel_gains[i]))\n        if gain != math.log2(channel_gains[i]):\n            raise ValueError(\"Gain must be a power of 2 between 1 and 128\")\n        self._gains[i] = gain\n\n    self._voltage_reference = voltage_reference\n    self._gain_error = gain_error\n    self._spi = spidev.SpiDev()\n    self._streaming = False\n    self._words_per_frame = 2 + num_channels\n\n    self._ready_status = 0x05 &lt;&lt; 8\n    for i in range(self._num_channels):\n        self._ready_status |= 1 &lt;&lt; i\n\n    self._data = [0.0] * num_channels\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the ADS131M0x instance.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string \"ADS131M0x\".</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the ADS131M0x instance.\n\n    Returns:\n        The string \"ADS131M0x\".\n    \"\"\"\n    return \"ADS131M0x\"\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.calibrate","title":"<code>calibrate()</code>","text":"<p>Perform offset and gain calibration on the ADC.</p> <p>This method performs an offset calibration (zeroing) and, if gain error corrections are provided, performs a gain calibration.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def calibrate(self) -&gt; None:\n    \"\"\"\n    Perform offset and gain calibration on the ADC.\n\n    This method performs an offset calibration (zeroing) and, if gain error corrections\n    are provided, performs a gain calibration.\n    \"\"\"\n    self._offset_calibration()\n    if self._gain_error is not None:\n        self._gain_calibration()\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.read_register","title":"<code>read_register(address)</code>","text":"<p>Read a register value from the ADC.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address of the register to read.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value read from the register.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def read_register(self, address: int) -&gt; int:\n    \"\"\"\n    Read a register value from the ADC.\n\n    Args:\n        address: The address of the register to read.\n\n    Returns:\n        The value read from the register.\n    \"\"\"\n    msg = (address &lt;&lt; 7) | (self._RREG_PREFIX &lt;&lt; 13)\n    word = self._message_to_word(msg)\n    rsp = self._spi_message(word)\n    return int(rsp[0] &lt;&lt; 8 | rsp[1])\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.reset","title":"<code>reset()</code>","text":"<p>Reset all ADC register values.</p> <p>Sends a reset command followed by blank words to initialize the device registers.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset all ADC register values.\n\n    Sends a reset command followed by blank words to initialize the device registers.\n    \"\"\"\n    self._spi.xfer2(self._RESET_WORD + self._BLANK_WORD * (self._words_per_frame - 1))\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.start","title":"<code>start()</code>","text":"<p>Open the SPI port, reset the ADC, configure gain settings, and begin streaming ADC data.</p> <p>This method initializes the SPI communication, resets the device, sets the channel gains, transitions the device to continuous conversion mode, and clears any stale data.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Open the SPI port, reset the ADC, configure gain settings, and begin streaming ADC data.\n\n    This method initializes the SPI communication, resets the device, sets the channel gains,\n    transitions the device to continuous conversion mode, and clears any stale data.\n    \"\"\"\n    self._spi.open(self._spi_bus, self._spi_chip)\n    self._spi.max_speed_hz = self._max_speed_hz\n    self._spi.mode = self._SPI_MODE\n\n    self.reset()\n    self._set_gain()\n    self._set_device_state(1)\n    self._clear_stale_data()\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.stop","title":"<code>stop()</code>","text":"<p>Stop streaming ADC data and close the SPI port.</p> <p>This method transitions the ADC to standby mode and closes the SPI connection.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop streaming ADC data and close the SPI port.\n\n    This method transitions the ADC to standby mode and closes the SPI connection.\n    \"\"\"\n    self._set_device_state(0)\n    self._spi.close()\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.update","title":"<code>update()</code>","text":"<p>Read ADC data from the device.</p> <p>Waits until the ADC channels are ready to be read and then updates the internal data with the latest voltage values in millivolts.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Read ADC data from the device.\n\n    Waits until the ADC channels are ready to be read and then updates the internal data\n    with the latest voltage values in millivolts.\n    \"\"\"\n    while not self._ready_to_read():\n        sleep(0.001)\n    self._data = self._read_data_millivolts()\n</code></pre>"},{"location":"modules/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.write_register","title":"<code>write_register(address, reg_val)</code>","text":"<p>Write a value to an ADC register.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address of the register to write.</p> required <code>reg_val</code> <code>int</code> <p>The value to be written to the register.</p> required Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def write_register(self, address: int, reg_val: int) -&gt; None:\n    \"\"\"\n    Write a value to an ADC register.\n\n    Args:\n        address: The address of the register to write.\n        reg_val: The value to be written to the register.\n    \"\"\"\n    addr_msg = (address &lt;&lt; 7) | (self._WREG_PREFIX &lt;&lt; 13)\n    addr_bytes = self._message_to_word(addr_msg)\n    reg_bytes = self._message_to_word(reg_val)\n    self._spi_message(addr_bytes + reg_bytes)\n</code></pre>"},{"location":"modules/sensors/encoder/","title":"Encoder","text":""},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B","title":"<code>AS5048B</code>","text":"<p>               Bases: <code>EncoderBase</code></p> Source code in <code>opensourceleg/sensors/encoder.py</code> <pre><code>class AS5048B(EncoderBase):  # ToDo: We use AS5048B -- need to look into name change A-- uses SPI, B uses I2C\n    ENC_RESOLUTION = 2**14  # 14 bit resolution\n    I2C_BASE_ADR_7BIT = 0b1000000  # The adress base on the format &lt;base[6:2]&gt; &lt;A1[1]&gt; &lt;A2[0]&gt;\n\n    ## Register adresses I2C\n    OTP_ZERO_POSITION_HIGH = 0x16  # bit 13 through 6\n    OTP_ZERO_POSITION_LOW = 0x17  # bit 5 through 0 (2 msbs of this aren't used)\n    AUTOMATIC_GAIN_CONTROL = 0xFA  # 0 = high mag field, 255 = low mag field, 8 bit\n    DIAGNOSTICS = 0xFB  # flags: 3 = comp high, 2 = comp low, 1 = COF, 0 = OCF\n    MAGNITUDE_HIGH = 0xFC  # bit 13 through 6\n    MAGNITUDE_LOW = 0xFD  # bit 5 through 0 (2 msbs of this aren't used)\n    ANGLE_HIGH = 0xFE  # bit 13 through 6\n    ANGLE_LOW = 0xFF  # bit 5 through 0 (2 msbs of this aren't used)\n\n    ## Status flags Diagnostics registers\n    FLAG_COMP_H = 0x1 &lt;&lt; 3\n    FLAG_COMP_L = 0x1 &lt;&lt; 2\n    FLAG_COF = 0x1 &lt;&lt; 1\n    FLAG_OCF = 0x1 &lt;&lt; 0\n\n    def __init__(\n        self,\n        bus: str = \"/dev/i2c\",\n        A1_adr_pin: bool = False,\n        A2_adr_pin: bool = False,\n        name: str = \"AS5048B\",\n        zero_position: int = 0,\n        enable_diagnostics: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Class for the AS5048B encoder, implements the Encoder interface\n\n        https://www.mouser.com/datasheet/2/588/AS5048_DS000298_4_00-2324531.pdf\n\n\n        Args:\n            bus: Path to the i2c bus ex. '/dev/i2c-1'\n            A1_adr_pin: State of the adress pin A1 on the AS5048A module\n            A2_adr_pin: State of the adress pin A1 on the AS5048A module\n            name: Tag name for the encoder\n            zero_position: The zero position of the encoder\n\n        Author: Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se),\n                Senthur Ayyappan (senthura@umich.edu)\n        \"\"\"\n        self.name = name\n        self.bus = bus\n        self.enable_diagnostics = enable_diagnostics\n\n        super().__init__()\n\n        self.addr = AS5048B.I2C_BASE_ADR_7BIT | ((bool(A2_adr_pin)) &lt;&lt; 1) | ((bool(A1_adr_pin)) &lt;&lt; 0)\n        self._reset_data()\n\n        self._zero_to_set = zero_position\n        self._is_streaming = False\n        self._data: Union[bytes, None] = None\n        self.rotations = 0\n        self._SMBus: Union[SMBus, None] = None\n\n        # Cache for frequently used values\n        self._two_pi = 2 * np.pi\n        self._scale_factor = self._two_pi / AS5048B.ENC_RESOLUTION\n\n    def start(self) -&gt; None:\n        LOGGER.info(f\"Opening encoder communication: {self.__class__.__name__} - {self.name}\")\n        self._SMBus = SMBus(self.bus)\n        self.update()  # Use public method instead of _update\n        if self.zero_position != self._zero_to_set:\n            self.zero_position = self._zero_to_set\n            LOGGER.info(f\"Set zero position to {self.zero_position}\")\n\n        self._is_streaming = True\n\n    def stop(self) -&gt; None:\n        if self._SMBus:\n            self._SMBus.close()\n            self._SMBus = None\n        self._reset_data()\n        self._is_streaming = False\n\n    def update(self) -&gt; None:\n        self._read_data_registers()\n\n        if self.enable_diagnostics:\n            self._check_diagnostics()\n\n    # def apply_state(self, state: Encoder.State) -&gt; None:\n    # raise NotImplementedError(f\"apply_state not implemented for {self.__class__}\")\n\n    @staticmethod\n    def _get_14bit(bytesToParse: bytes) -&gt; int:\n        return (bytesToParse[0] &lt;&lt; 6) | bytesToParse[1]  # int() is unnecessary\n\n    @staticmethod\n    def _set_14bit(intToParse: int) -&gt; bytes:\n        \"\"\"\n        Convert a 14bit integer to bytes &lt;msb[13:6]&gt;&lt;lsb[5:0]&gt;\n\n        Args:\n            intToParse: The integer to convert to bytes\n\n        Raises:\n            OverflowError: If intToParse &gt;= 2^14\n        \"\"\"\n        if intToParse &gt;= AS5048B.ENC_RESOLUTION:\n            raise OverflowError(f\"Argument intToParse={intToParse} &gt;= 2^14 bit encoder resolution\")\n        return bytes([(intToParse &gt;&gt; 6), intToParse &amp; 0x3F])\n\n    def _reset_data(self) -&gt; None:\n        # Use bytearray for better performance when we need to modify\n        self._encdata_old = bytearray(6)\n        self._encdata_old_timestamp = 0\n        self._encdata_new = bytearray(6)\n        self._encdata_new_timestamp = 0\n\n    def _write_registers(self, register: int, data: bytes) -&gt; None:\n        if self._SMBus is None:\n            raise RuntimeError(\"SMBus not initialized. Call start() first.\")\n        self._SMBus.write_i2c_block_data(self.addr, register, data)\n\n    def _read_registers(self, register: int, length: int) -&gt; bytes:\n        if self._SMBus is None:\n            raise RuntimeError(\"SMBus not initialized. Call start() first.\")\n        return bytes(self._SMBus.read_i2c_block_data(self.addr, register, length))\n\n    def _read_data_registers(self) -&gt; None:\n        \"\"\"\n        Read data output registers\n            [0]\n            [1]\n            [2] 0xFC MAG H\n            [3] 0xFD MAG L\n            [4] 0xFE ANG H\n            [5] 0xFF ANG L\n        \"\"\"\n        # Swap references instead of copying data\n        self._encdata_old, self._encdata_new = self._encdata_new, self._encdata_old\n        self._encdata_old_timestamp, self._encdata_new_timestamp = self._encdata_new_timestamp, time.monotonic_ns()\n\n        # Read directly into the bytearray\n        data = self._read_registers(AS5048B.AUTOMATIC_GAIN_CONTROL, 6)\n        self._encdata_new[:] = data\n        self._data = data\n\n    def _check_diagnostics(self) -&gt; None:\n        if not self.diag_OCF:\n            raise OSError(\"Invalid data returned on read, DIAG_OCF != 1\")\n\n        if self.diag_COF:\n            LOGGER.info(\"CORDIC Overflow, sample invalid\")\n\n        if self.diag_compH:\n            LOGGER.info(\"Low magnetic field comp triggered\")\n\n        if self.diag_compL:\n            LOGGER.info(\"High magnetic field comp triggered\")\n\n    @property\n    def position(self) -&gt; float:\n        \"\"\"\n        Get the current angular position in radians.\n\n        Returns:\n            The current angular position in radians.\n        \"\"\"\n        signed_output = from_twos_complement(self.encoder_output, 14)\n        return signed_output * self._scale_factor\n\n    @property\n    def encoder_output(self) -&gt; int:\n        \"\"\"\n        Get the raw encoder output as counts of full scale output.\n\n        Returns:\n            Encoder output in counts [0, FS].\n        \"\"\"\n        return AS5048B._get_14bit(self._encdata_new[4:6])\n\n    @property\n    def velocity(self) -&gt; float:\n        \"\"\"\n        Calculate angular velocity in radians per second.\n\n        Returns:\n            The angular velocity in radians per second.\n        \"\"\"\n        try:\n            encAngleDataOld = AS5048B._get_14bit(self._encdata_old[4:6])\n            encAngleDataNew = AS5048B._get_14bit(self._encdata_new[4:6])\n            # Timediff is converted from ns to s\n            timediff = (self._encdata_new_timestamp - self._encdata_old_timestamp) * 1e-9\n\n            if timediff &lt;= 0:\n                return 0.0\n\n            return (encAngleDataNew - encAngleDataOld) * self._scale_factor / timediff\n\n        except (TypeError, ZeroDivisionError):\n            return 0.0\n\n    @property\n    def abs_ang(self) -&gt; float:\n        \"\"\"\n        Get the absolute angle in radians.\n\n        Returns:\n            The absolute angle in radians.\n        \"\"\"\n        try:\n            encAngleDataOld = AS5048B._get_14bit(self._encdata_old[4:6])\n            encAngleDataNew = AS5048B._get_14bit(self._encdata_new[4:6])\n        except TypeError:\n            return self.position\n\n        encAngRadOld = from_twos_complement(encAngleDataOld, 14) * self._scale_factor\n        encAngRadNew = from_twos_complement(encAngleDataNew, 14) * self._scale_factor\n\n        # Detect rotation crossings\n        diff = encAngRadNew - encAngRadOld\n        if diff &gt; 0.9 * self._two_pi:\n            self.rotations -= 1\n        elif diff &lt; -0.9 * self._two_pi:\n            self.rotations += 1\n\n        return encAngRadNew + self._two_pi * self.rotations\n\n    @property\n    def zero_position(self) -&gt; int:\n        \"\"\"\n        Get the zero position of the encoder.\n\n        Returns:\n            The zero position in encoder counts.\n        \"\"\"\n        registers = self._read_registers(AS5048B.OTP_ZERO_POSITION_HIGH, 2)\n        return AS5048B._get_14bit(registers)\n\n    @zero_position.setter\n    def zero_position(self, value: int) -&gt; None:\n        \"\"\"\n        Set the zero position of the encoder.\n\n        Args:\n            value: The new zero position in encoder counts.\n\n        Raises:\n            ValueError: If the value is not within the valid range.\n        \"\"\"\n        if not (0 &lt;= value &lt; (AS5048B.ENC_RESOLUTION - 1)):\n            raise ValueError(f\"Zero position must be between 0 and {AS5048B.ENC_RESOLUTION - 2}\")\n        try:\n            payload = AS5048B._set_14bit(value)\n        except OverflowError as err:\n            raise OverflowError(f\"Argument value={value} &gt;= 2^14 bit encoder resolution\") from err\n        else:\n            self._write_registers(AS5048B.OTP_ZERO_POSITION_HIGH, payload)\n\n    def set_zero_position(self) -&gt; None:\n        \"\"\"\n        Set the current position as the zero position.\n\n        This method reads the current encoder position and sets it as the new zero position.\n        \"\"\"\n        input(\"Set joint in lower position and press enter\")\n\n        self.zero_position = 0\n        self.update()\n        min_value = from_twos_complement(self.encoder_output, 14)\n\n        input(\"Set joint in upper position and press enter\")\n        self.update()\n        max_value = from_twos_complement(self.encoder_output, 14)\n        mid_value = (min_value + max_value) // 2\n        self.zero_position = to_twos_complement(mid_value, 14)\n        LOGGER.info(f\"[SET] Zero registers: {self.zero_position}\")\n\n    @property\n    def diag_compH(self) -&gt; bool:\n        \"\"\"\n        Check if the magnetic field compensation for high field is triggered.\n\n        Returns:\n            True if high field compensation is triggered, False otherwise.\n        \"\"\"\n        return bool(self._encdata_new[1] &amp; AS5048B.FLAG_COMP_H)\n\n    @property\n    def diag_compL(self) -&gt; bool:\n        \"\"\"\n        Check if the magnetic field compensation for low field is triggered.\n\n        Returns:\n            True if low field compensation is triggered, False otherwise.\n        \"\"\"\n        return bool(self._encdata_new[1] &amp; AS5048B.FLAG_COMP_L)\n\n    @property\n    def diag_COF(self) -&gt; bool:\n        \"\"\"\n        Check if a CORDIC overflow has occurred.\n\n        Returns:\n            True if a CORDIC overflow has occurred, False otherwise.\n        \"\"\"\n        return bool(self._encdata_new[1] &amp; AS5048B.FLAG_COF)\n\n    @property\n    def diag_OCF(self) -&gt; bool:\n        \"\"\"\n        Check if the data is valid (no overflow).\n\n        Returns:\n            True if the data is valid, False otherwise.\n        \"\"\"\n        return bool(self._encdata_new[1] &amp; AS5048B.FLAG_OCF)\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the encoder is currently streaming data.\n\n        Returns:\n            True if the encoder is streaming, False otherwise.\n        \"\"\"\n        return self._is_streaming\n\n    @property\n    def data(self) -&gt; bytes:\n        \"\"\"\n        Get the raw encoder data.\n\n        Returns:\n            The raw encoder data as bytes.\n        \"\"\"\n        if self._data is None:\n            return b\"\"  # Return empty bytes if no data available\n\n        return self._data\n\n    def __repr__(self) -&gt; str:\n        return f\"\\n\\tAngle: {self.position:.3f} rad\\n\\tVelocity: {self.velocity:.3f} rad/s\"\n</code></pre>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.abs_ang","title":"<code>abs_ang: float</code>  <code>property</code>","text":"<p>Get the absolute angle in radians.</p> <p>Returns:</p> Type Description <code>float</code> <p>The absolute angle in radians.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.data","title":"<code>data: bytes</code>  <code>property</code>","text":"<p>Get the raw encoder data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The raw encoder data as bytes.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.diag_COF","title":"<code>diag_COF: bool</code>  <code>property</code>","text":"<p>Check if a CORDIC overflow has occurred.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if a CORDIC overflow has occurred, False otherwise.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.diag_OCF","title":"<code>diag_OCF: bool</code>  <code>property</code>","text":"<p>Check if the data is valid (no overflow).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the data is valid, False otherwise.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.diag_compH","title":"<code>diag_compH: bool</code>  <code>property</code>","text":"<p>Check if the magnetic field compensation for high field is triggered.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if high field compensation is triggered, False otherwise.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.diag_compL","title":"<code>diag_compL: bool</code>  <code>property</code>","text":"<p>Check if the magnetic field compensation for low field is triggered.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if low field compensation is triggered, False otherwise.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.encoder_output","title":"<code>encoder_output: int</code>  <code>property</code>","text":"<p>Get the raw encoder output as counts of full scale output.</p> <p>Returns:</p> Type Description <code>int</code> <p>Encoder output in counts [0, FS].</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.is_streaming","title":"<code>is_streaming: bool</code>  <code>property</code>","text":"<p>Check if the encoder is currently streaming data.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the encoder is streaming, False otherwise.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.position","title":"<code>position: float</code>  <code>property</code>","text":"<p>Get the current angular position in radians.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current angular position in radians.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.velocity","title":"<code>velocity: float</code>  <code>property</code>","text":"<p>Calculate angular velocity in radians per second.</p> <p>Returns:</p> Type Description <code>float</code> <p>The angular velocity in radians per second.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.zero_position","title":"<code>zero_position: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the zero position of the encoder.</p> <p>Returns:</p> Type Description <code>int</code> <p>The zero position in encoder counts.</p>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.__init__","title":"<code>__init__(bus='/dev/i2c', A1_adr_pin=False, A2_adr_pin=False, name='AS5048B', zero_position=0, enable_diagnostics=False)</code>","text":"<p>Class for the AS5048B encoder, implements the Encoder interface</p> <p>https://www.mouser.com/datasheet/2/588/AS5048_DS000298_4_00-2324531.pdf</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>Path to the i2c bus ex. '/dev/i2c-1'</p> <code>'/dev/i2c'</code> <code>A1_adr_pin</code> <code>bool</code> <p>State of the adress pin A1 on the AS5048A module</p> <code>False</code> <code>A2_adr_pin</code> <code>bool</code> <p>State of the adress pin A1 on the AS5048A module</p> <code>False</code> <code>name</code> <code>str</code> <p>Tag name for the encoder</p> <code>'AS5048B'</code> <code>zero_position</code> <code>int</code> <p>The zero position of the encoder</p> <code>0</code> Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se), <p>Senthur Ayyappan (senthura@umich.edu)</p> Source code in <code>opensourceleg/sensors/encoder.py</code> <pre><code>def __init__(\n    self,\n    bus: str = \"/dev/i2c\",\n    A1_adr_pin: bool = False,\n    A2_adr_pin: bool = False,\n    name: str = \"AS5048B\",\n    zero_position: int = 0,\n    enable_diagnostics: bool = False,\n) -&gt; None:\n    \"\"\"\n    Class for the AS5048B encoder, implements the Encoder interface\n\n    https://www.mouser.com/datasheet/2/588/AS5048_DS000298_4_00-2324531.pdf\n\n\n    Args:\n        bus: Path to the i2c bus ex. '/dev/i2c-1'\n        A1_adr_pin: State of the adress pin A1 on the AS5048A module\n        A2_adr_pin: State of the adress pin A1 on the AS5048A module\n        name: Tag name for the encoder\n        zero_position: The zero position of the encoder\n\n    Author: Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se),\n            Senthur Ayyappan (senthura@umich.edu)\n    \"\"\"\n    self.name = name\n    self.bus = bus\n    self.enable_diagnostics = enable_diagnostics\n\n    super().__init__()\n\n    self.addr = AS5048B.I2C_BASE_ADR_7BIT | ((bool(A2_adr_pin)) &lt;&lt; 1) | ((bool(A1_adr_pin)) &lt;&lt; 0)\n    self._reset_data()\n\n    self._zero_to_set = zero_position\n    self._is_streaming = False\n    self._data: Union[bytes, None] = None\n    self.rotations = 0\n    self._SMBus: Union[SMBus, None] = None\n\n    # Cache for frequently used values\n    self._two_pi = 2 * np.pi\n    self._scale_factor = self._two_pi / AS5048B.ENC_RESOLUTION\n</code></pre>"},{"location":"modules/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.set_zero_position","title":"<code>set_zero_position()</code>","text":"<p>Set the current position as the zero position.</p> <p>This method reads the current encoder position and sets it as the new zero position.</p> Source code in <code>opensourceleg/sensors/encoder.py</code> <pre><code>def set_zero_position(self) -&gt; None:\n    \"\"\"\n    Set the current position as the zero position.\n\n    This method reads the current encoder position and sets it as the new zero position.\n    \"\"\"\n    input(\"Set joint in lower position and press enter\")\n\n    self.zero_position = 0\n    self.update()\n    min_value = from_twos_complement(self.encoder_output, 14)\n\n    input(\"Set joint in upper position and press enter\")\n    self.update()\n    max_value = from_twos_complement(self.encoder_output, 14)\n    mid_value = (min_value + max_value) // 2\n    self.zero_position = to_twos_complement(mid_value, 14)\n    LOGGER.info(f\"[SET] Zero registers: {self.zero_position}\")\n</code></pre>"},{"location":"modules/sensors/imu/","title":"IMU","text":"<p>Module for interfacing with IMU sensors using the MSCL and Adafruit libraries.</p> This module provides two IMU sensor implementations <ul> <li>LordMicrostrainIMU: Uses the MSCL library to interface with a Lord Microstrain IMU.</li> <li>BNO055: Uses the Adafruit BNO055 library to interface with a Bosch BNO055 IMU.</li> </ul> Dependencies <ul> <li>MSCL (for LordMicrostrainIMU): https://github.com/LORD-MicroStrain/MSCL/tree/master</li> <li>adafruit_bno055, board, busio (for BNO055)</li> </ul> <p>Ensure that the required libraries are installed and that the library paths are added to PYTHONPATH or sys.path if necessary.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055","title":"<code>BNO055</code>","text":"<p>               Bases: <code>IMUBase</code></p> <p>Sensor class for the Bosch BNO055 IMU.</p> <p>This class wraps the Adafruit BNO055 library to provide an interface consistent with the OSL sensor framework.</p> Connections <ul> <li>The sensor should be connected to the main I2C bus.</li> <li>UART connectivity is not implemented.</li> </ul> Requirements <ul> <li>adafruit_bno055</li> <li>board</li> <li>busio</li> </ul> Author <p>Kevin Best</p> Date <p>8/22/2024</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>class BNO055(IMUBase):\n    \"\"\"\n    Sensor class for the Bosch BNO055 IMU.\n\n    This class wraps the Adafruit BNO055 library to provide an interface\n    consistent with the OSL sensor framework.\n\n    Connections:\n        - The sensor should be connected to the main I2C bus.\n        - UART connectivity is not implemented.\n\n    Requirements:\n        - adafruit_bno055\n        - board\n        - busio\n\n    Author:\n        Kevin Best\n\n    Date:\n        8/22/2024\n    \"\"\"\n\n    def __init__(\n        self,\n        addr: int = 40,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the BNO055 sensor.\n\n        Args:\n            addr: I2C address of the BNO055 sensor. Defaults to 40.\n        \"\"\"\n        self._address: int = addr\n        self._gyro_data: list[float] = [0.0, 0.0, 0.0]\n        self._acc_data: list[float] = [0.0, 0.0, 0.0]\n        self._is_streaming = False\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the BNO055 sensor.\n\n        Returns:\n            A string identifying the sensor.\n        \"\"\"\n        return \"BNO055_IMU\"\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the BNO055 sensor.\n\n        Initializes the I2C bus, creates an instance of the Adafruit BNO055 sensor,\n        configures the sensor settings, and sets the streaming flag to True.\n        \"\"\"\n        i2c = busio.I2C(board.SCL, board.SDA)\n        try:\n            self._adafruit_imu = adafruit_bno055.BNO055_I2C(i2c, address=self._address)\n        except ValueError:\n            print(\"BNO055 IMU Not Found on i2c bus! Check wiring!\")\n        self.configure_IMU_settings()\n        self._is_streaming = True\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the BNO055 sensor.\n\n        Sets the streaming flag to False.\n        \"\"\"\n        self._is_streaming = False\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the sensor data from the BNO055.\n\n        Reads the latest acceleration and gyroscopic data from the sensor.\n        \"\"\"\n        self._acc_data = self._adafruit_imu.acceleration\n        self._gyro_data = self._adafruit_imu.gyro\n\n    def configure_IMU_settings(self) -&gt; None:\n        \"\"\"\n        Configure the BNO055 sensor settings.\n\n        Hard-coded configuration:\n            - Enables external crystal.\n            - Sets mode to ACCGYRO_MODE.\n            - Configures accelerometer range to ACCEL_2G and bandwidth to ACCEL_15_63HZ.\n            - Configures gyroscope range to GYRO_1000_DPS and bandwidth to GYRO_23HZ.\n        \"\"\"\n        self._adafruit_imu.use_external_crystal = True\n        self._adafruit_imu.mode = adafruit_bno055.ACCGYRO_MODE\n        self._adafruit_imu.accel_range = adafruit_bno055.ACCEL_2G\n        self._adafruit_imu.accel_bandwidth = adafruit_bno055.ACCEL_15_63HZ\n        self._adafruit_imu.gyro_range = adafruit_bno055.GYRO_1000_DPS\n        self._adafruit_imu.gyro_bandwidth = adafruit_bno055.GYRO_23HZ\n\n    @property\n    def acc_x(self) -&gt; float:\n        \"\"\"\n        Get the measured acceleration along the x-axis in m/s\u00b2.\n\n        Returns:\n            float: Acceleration (m/s\u00b2) along the x-axis.\n        \"\"\"\n        return self._acc_data[0]\n\n    @property\n    def acc_y(self) -&gt; float:\n        \"\"\"\n        Get the measured acceleration along the y-axis in m/s\u00b2.\n\n        Returns:\n            float: Acceleration (m/s\u00b2) along the y-axis.\n        \"\"\"\n        return self._acc_data[1]\n\n    @property\n    def acc_z(self) -&gt; float:\n        \"\"\"\n        Get the measured acceleration along the z-axis in m/s\u00b2.\n\n        Returns:\n            float: Acceleration (m/s\u00b2) along the z-axis.\n        \"\"\"\n        return self._acc_data[2]\n\n    @property\n    def gyro_x(self) -&gt; float:\n        \"\"\"\n        Get the measured rotational velocity about the x-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the x-axis.\n        \"\"\"\n        return self._gyro_data[0]\n\n    @property\n    def gyro_y(self) -&gt; float:\n        \"\"\"\n        Get the measured rotational velocity about the y-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the y-axis.\n        \"\"\"\n        return self._gyro_data[1]\n\n    @property\n    def gyro_z(self) -&gt; float:\n        \"\"\"\n        Get the measured rotational velocity about the z-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the z-axis.\n        \"\"\"\n        return self._gyro_data[2]\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the BNO055 sensor is streaming data.\n\n        Returns:\n            bool: True if streaming; otherwise, False.\n        \"\"\"\n        return self._is_streaming\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.acc_x","title":"<code>acc_x: float</code>  <code>property</code>","text":"<p>Get the measured acceleration along the x-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration (m/s\u00b2) along the x-axis.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.acc_y","title":"<code>acc_y: float</code>  <code>property</code>","text":"<p>Get the measured acceleration along the y-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration (m/s\u00b2) along the y-axis.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.acc_z","title":"<code>acc_z: float</code>  <code>property</code>","text":"<p>Get the measured acceleration along the z-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration (m/s\u00b2) along the z-axis.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.gyro_x","title":"<code>gyro_x: float</code>  <code>property</code>","text":"<p>Get the measured rotational velocity about the x-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the x-axis.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.gyro_y","title":"<code>gyro_y: float</code>  <code>property</code>","text":"<p>Get the measured rotational velocity about the y-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the y-axis.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.gyro_z","title":"<code>gyro_z: float</code>  <code>property</code>","text":"<p>Get the measured rotational velocity about the z-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the z-axis.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.is_streaming","title":"<code>is_streaming: bool</code>  <code>property</code>","text":"<p>Check if the BNO055 sensor is streaming data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming; otherwise, False.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.__init__","title":"<code>__init__(addr=40)</code>","text":"<p>Initialize the BNO055 sensor.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>int</code> <p>I2C address of the BNO055 sensor. Defaults to 40.</p> <code>40</code> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def __init__(\n    self,\n    addr: int = 40,\n) -&gt; None:\n    \"\"\"\n    Initialize the BNO055 sensor.\n\n    Args:\n        addr: I2C address of the BNO055 sensor. Defaults to 40.\n    \"\"\"\n    self._address: int = addr\n    self._gyro_data: list[float] = [0.0, 0.0, 0.0]\n    self._acc_data: list[float] = [0.0, 0.0, 0.0]\n    self._is_streaming = False\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the BNO055 sensor.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string identifying the sensor.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the BNO055 sensor.\n\n    Returns:\n        A string identifying the sensor.\n    \"\"\"\n    return \"BNO055_IMU\"\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.configure_IMU_settings","title":"<code>configure_IMU_settings()</code>","text":"<p>Configure the BNO055 sensor settings.</p> Hard-coded configuration <ul> <li>Enables external crystal.</li> <li>Sets mode to ACCGYRO_MODE.</li> <li>Configures accelerometer range to ACCEL_2G and bandwidth to ACCEL_15_63HZ.</li> <li>Configures gyroscope range to GYRO_1000_DPS and bandwidth to GYRO_23HZ.</li> </ul> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def configure_IMU_settings(self) -&gt; None:\n    \"\"\"\n    Configure the BNO055 sensor settings.\n\n    Hard-coded configuration:\n        - Enables external crystal.\n        - Sets mode to ACCGYRO_MODE.\n        - Configures accelerometer range to ACCEL_2G and bandwidth to ACCEL_15_63HZ.\n        - Configures gyroscope range to GYRO_1000_DPS and bandwidth to GYRO_23HZ.\n    \"\"\"\n    self._adafruit_imu.use_external_crystal = True\n    self._adafruit_imu.mode = adafruit_bno055.ACCGYRO_MODE\n    self._adafruit_imu.accel_range = adafruit_bno055.ACCEL_2G\n    self._adafruit_imu.accel_bandwidth = adafruit_bno055.ACCEL_15_63HZ\n    self._adafruit_imu.gyro_range = adafruit_bno055.GYRO_1000_DPS\n    self._adafruit_imu.gyro_bandwidth = adafruit_bno055.GYRO_23HZ\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.start","title":"<code>start()</code>","text":"<p>Start the BNO055 sensor.</p> <p>Initializes the I2C bus, creates an instance of the Adafruit BNO055 sensor, configures the sensor settings, and sets the streaming flag to True.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the BNO055 sensor.\n\n    Initializes the I2C bus, creates an instance of the Adafruit BNO055 sensor,\n    configures the sensor settings, and sets the streaming flag to True.\n    \"\"\"\n    i2c = busio.I2C(board.SCL, board.SDA)\n    try:\n        self._adafruit_imu = adafruit_bno055.BNO055_I2C(i2c, address=self._address)\n    except ValueError:\n        print(\"BNO055 IMU Not Found on i2c bus! Check wiring!\")\n    self.configure_IMU_settings()\n    self._is_streaming = True\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.stop","title":"<code>stop()</code>","text":"<p>Stop the BNO055 sensor.</p> <p>Sets the streaming flag to False.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the BNO055 sensor.\n\n    Sets the streaming flag to False.\n    \"\"\"\n    self._is_streaming = False\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.BNO055.update","title":"<code>update()</code>","text":"<p>Update the sensor data from the BNO055.</p> <p>Reads the latest acceleration and gyroscopic data from the sensor.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Update the sensor data from the BNO055.\n\n    Reads the latest acceleration and gyroscopic data from the sensor.\n    \"\"\"\n    self._acc_data = self._adafruit_imu.acceleration\n    self._gyro_data = self._adafruit_imu.gyro\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU","title":"<code>LordMicrostrainIMU</code>","text":"<p>               Bases: <code>IMUBase</code></p> <p>Sensor class for the Lord Microstrain IMU.</p> <p>This class interfaces with a Lord Microstrain Inertial Measurement Unit (IMU) via the MSCL library. It returns Euler angles (in radians), angular rates (in rad/s), and linear accelerations (in m/s^2).</p> Resources <ul> <li>Download MSCL pre-built package for Raspbian:   https://github.com/LORD-MicroStrain/MSCL/tree/master</li> <li>MSCL API Documentation:   https://lord-microstrain.github.io/MSCL/Documentation/MSCL%20API%20Documentation/index.html</li> </ul> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>class LordMicrostrainIMU(IMUBase):\n    \"\"\"\n    Sensor class for the Lord Microstrain IMU.\n\n    This class interfaces with a Lord Microstrain Inertial Measurement Unit (IMU)\n    via the MSCL library. It returns Euler angles (in radians), angular rates (in rad/s),\n    and linear accelerations (in m/s^2).\n\n    Resources:\n        - Download MSCL pre-built package for Raspbian:\n          https://github.com/LORD-MicroStrain/MSCL/tree/master\n        - MSCL API Documentation:\n          https://lord-microstrain.github.io/MSCL/Documentation/MSCL%20API%20Documentation/index.html\n    \"\"\"\n\n    def __init__(\n        self,\n        port: str = \"/dev/ttyUSB0\",\n        baud_rate: int = 921600,\n        frequency: int = 200,\n        update_timeout: int = 500,\n        max_packets: int = 1,\n        return_packets: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the LordMicrostrainIMU sensor.\n\n        Args:\n            port: Serial port for the IMU. Defaults to \"/dev/ttyUSB0\".\n            baud_rate: Baud rate for the serial connection. Defaults to 921600.\n            frequency: Data streaming frequency in Hz. Defaults to 200.\n            update_timeout: Timeout for data packet retrieval in milliseconds. Defaults to 500.\n            max_packets: Maximum number of data packets to retrieve. Defaults to 1.\n            return_packets: If True, returns the raw data packets. Defaults to False.\n        \"\"\"\n        self._port = port\n        self._baud_rate = baud_rate\n        self._frequency = frequency\n        self._update_timeout = update_timeout\n        self._max_packets = max_packets\n        self._return_packets = return_packets\n        self._is_streaming = False\n        self._connection = None\n        self._data: dict[str, float] = {}\n\n    def _configure_mip_channels(self) -&gt; Any:\n        \"\"\"\n        Configure and return the MIP channels for data streaming.\n\n        Sets up the desired channels for:\n          - Estimated orientation (Euler angles)\n          - Estimated angular rate\n          - Estimated linear acceleration\n          - GPS timestamp\n\n        Returns:\n            A configured MipChannels object for the MSCL InertialNode.\n        \"\"\"\n        channels = mscl.MipChannels()\n        channels.append(\n            mscl.MipChannel(\n                mscl.MipTypes.CH_FIELD_ESTFILTER_ESTIMATED_ORIENT_EULER,\n                mscl.SampleRate.Hertz(self.frequency),\n            )\n        )\n        channels.append(\n            mscl.MipChannel(\n                mscl.MipTypes.CH_FIELD_ESTFILTER_ESTIMATED_ANGULAR_RATE,\n                mscl.SampleRate.Hertz(self.frequency),\n            )\n        )\n        channels.append(\n            mscl.MipChannel(\n                mscl.MipTypes.CH_FIELD_ESTFILTER_ESTIMATED_LINEAR_ACCEL,\n                mscl.SampleRate.Hertz(self.frequency),\n            )\n        )\n        channels.append(\n            mscl.MipChannel(\n                mscl.MipTypes.CH_FIELD_ESTFILTER_GPS_TIMESTAMP,\n                mscl.SampleRate.Hertz(self.frequency),\n            )\n        )\n\n        return channels\n\n    def set_update_timeout(self, timeout: int) -&gt; None:\n        \"\"\"\n        Set the update timeout for the sensor.\n        \"\"\"\n        self._update_timeout = timeout\n\n    def set_max_packets(self, max_packets: int) -&gt; None:\n        \"\"\"\n        Set the maximum number of packets to retrieve.\n        \"\"\"\n        self._max_packets = max_packets\n\n    def set_return_packets(self, return_packets: bool) -&gt; None:\n        \"\"\"\n        Set the return packets flag.\n        \"\"\"\n        self._return_packets = return_packets\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the Lord Microstrain IMU sensor.\n\n        Establishes a serial connection, configures the MIP channels, enables data streaming,\n        and sets the streaming flag to True.\n        \"\"\"\n        self._connection = mscl.Connection.Serial(self.port, self.baud_rate)\n        self._node = mscl.InertialNode(self._connection)\n        self._node.setActiveChannelFields(mscl.MipTypes.CLASS_ESTFILTER, self._configure_mip_channels())\n        self._node.enableDataStream(mscl.MipTypes.CLASS_ESTFILTER)\n        self._is_streaming = True\n\n    @check_sensor_stream\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the Lord Microstrain IMU sensor.\n\n        Sets the node to idle mode and updates the streaming flag to False.\n\n        Raises:\n            SensorNotStreamingException: If the sensor is not currently streaming.\n        \"\"\"\n        self._node.setToIdle()\n        self._is_streaming = False\n\n    @check_sensor_stream\n    def ping(self) -&gt; None:\n        \"\"\"\n        Ping the Lord Microstrain IMU sensor to verify connectivity.\n\n        Logs an info message if the ping is successful, otherwise logs an error.\n\n        Raises:\n            SensorNotStreamingException: If the sensor is not currently streaming.\n        \"\"\"\n        response = self._node.ping()\n\n        if response.success():\n            LOGGER.info(f\"Successfully pinged the IMU at {self.port}\")\n        else:\n            LOGGER.error(f\"Failed to ping the IMU at {self.port}\")\n\n    def update(self) -&gt; Union[None, Any]:\n        \"\"\"\n        Retrieve and update IMU data from the sensor. To modify update parameters, use the set_update_timeout,\n        set_max_packets, and set_return_packets methods.\n\n        Returns:\n            Union[None, Any]: Returns the data packets if `return_packets` is True; otherwise, None.\n        \"\"\"\n        data_packets = self._node.getDataPackets(timeout=self.update_timeout, maxPackets=self.max_packets)\n        data_points = data_packets[-1].data()\n        self._data = {data.channelName(): data.as_float() for data in data_points}\n\n        if self.return_packets:\n            return data_packets\n        else:\n            return None\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the LordMicrostrainIMU sensor.\n\n        Returns:\n            A string identifying the sensor.\n        \"\"\"\n        return \"IMULordMicrostrain\"\n\n    @property\n    def port(self) -&gt; str:\n        \"\"\"\n        Get the serial port for the IMU.\n\n        Returns:\n            The serial port string.\n        \"\"\"\n        return self._port\n\n    @property\n    def baud_rate(self) -&gt; int:\n        \"\"\"\n        Get the baud rate for the serial connection.\n\n        Returns:\n            The baud rate in Hz.\n        \"\"\"\n        return self._baud_rate\n\n    @property\n    def frequency(self) -&gt; int:\n        \"\"\"\n        Get the data streaming frequency.\n\n        Returns:\n            The frequency in Hz.\n        \"\"\"\n        return self._frequency\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the sensor is currently streaming.\n\n        Returns:\n            True if the sensor is streaming, False otherwise.\n        \"\"\"\n        return self._is_streaming\n\n    @property\n    def update_timeout(self) -&gt; int:\n        \"\"\"\n        Get the update timeout for data packet retrieval.\n\n        Returns:\n            The timeout in milliseconds.\n        \"\"\"\n        return self._update_timeout\n\n    @property\n    def max_packets(self) -&gt; int:\n        \"\"\"\n        Get the maximum number of packets to retrieve.\n\n        Returns:\n            The maximum number of packets.\n        \"\"\"\n        return self._max_packets\n\n    @property\n    def return_packets(self) -&gt; bool:\n        \"\"\"\n        Get the return packets flag.\n\n        Returns:\n            True if raw data packets should be returned, False otherwise.\n        \"\"\"\n        return self._return_packets\n\n    @property\n    def data(self) -&gt; dict[str, float]:\n        \"\"\"\n        Get the current sensor data.\n\n        Returns:\n            A dictionary containing the current sensor data.\n        \"\"\"\n        return self._data\n\n    @property\n    def roll(self) -&gt; float:\n        \"\"\"\n        Get the roll angle.\n\n        Returns:\n            The roll angle in radians.\n        \"\"\"\n        return self._data[\"estRoll\"]\n\n    @property\n    def pitch(self) -&gt; float:\n        \"\"\"\n        Get the pitch angle.\n\n        Returns:\n            The pitch angle in radians.\n        \"\"\"\n        return self._data[\"estPitch\"]\n\n    @property\n    def yaw(self) -&gt; float:\n        \"\"\"\n        Get the yaw angle.\n\n        Returns:\n            The yaw angle in radians.\n        \"\"\"\n        return self._data[\"estYaw\"]\n\n    @property\n    def vel_x(self) -&gt; float:\n        \"\"\"\n        Get the angular velocity in the x-axis.\n\n        Returns:\n            The angular velocity in rad/s.\n        \"\"\"\n        return self._data[\"estAngularRateX\"]\n\n    @property\n    def vel_y(self) -&gt; float:\n        \"\"\"\n        Get the angular velocity in the y-axis.\n\n        Returns:\n            The angular velocity in rad/s.\n        \"\"\"\n        return self._data[\"estAngularRateY\"]\n\n    @property\n    def vel_z(self) -&gt; float:\n        \"\"\"\n        Get the angular velocity in the z-axis.\n\n        Returns:\n            The angular velocity in rad/s.\n        \"\"\"\n        return self._data[\"estAngularRateZ\"]\n\n    @property\n    def acc_x(self) -&gt; float:\n        \"\"\"\n        Get the linear acceleration in the x-axis.\n\n        Returns:\n            The linear acceleration in m/s^2.\n        \"\"\"\n        return self._data[\"estLinearAccelX\"]\n\n    @property\n    def acc_y(self) -&gt; float:\n        \"\"\"\n        Get the linear acceleration in the y-axis.\n\n        Returns:\n            The linear acceleration in m/s^2.\n        \"\"\"\n        return self._data[\"estLinearAccelY\"]\n\n    @property\n    def acc_z(self) -&gt; float:\n        \"\"\"\n        Get the linear acceleration in the z-axis.\n\n        Returns:\n            The linear acceleration in m/s^2.\n        \"\"\"\n        return self._data[\"estLinearAccelZ\"]\n\n    @property\n    def gyro_x(self) -&gt; float:\n        \"\"\"\n        Get the gyroscope reading in the x-axis.\n\n        Returns:\n            The gyroscope reading in rad/s.\n        \"\"\"\n        LOGGER.warning(\"Gyro data not available for Lord Microstrain IMU\")\n        return 0.0\n\n    @property\n    def gyro_y(self) -&gt; float:\n        \"\"\"\n        Get the gyroscope reading in the y-axis.\n\n        Returns:\n            The gyroscope reading in rad/s.\n        \"\"\"\n        LOGGER.warning(\"Gyro data not available for Lord Microstrain IMU\")\n        return 0.0\n\n    @property\n    def gyro_z(self) -&gt; float:\n        \"\"\"\n        Get the gyroscope reading in the z-axis.\n\n        Returns:\n            The gyroscope reading in rad/s.\n        \"\"\"\n        LOGGER.warning(\"Gyro data not available for Lord Microstrain IMU\")\n        return 0.0\n\n    @property\n    def timestamp(self) -&gt; float:\n        \"\"\"\n        Get the GPS timestamp.\n\n        Returns:\n            The GPS timestamp in seconds.\n        \"\"\"\n        return self._data[\"estFilterGpsTimeTow\"]\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.acc_x","title":"<code>acc_x: float</code>  <code>property</code>","text":"<p>Get the linear acceleration in the x-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The linear acceleration in m/s^2.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.acc_y","title":"<code>acc_y: float</code>  <code>property</code>","text":"<p>Get the linear acceleration in the y-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The linear acceleration in m/s^2.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.acc_z","title":"<code>acc_z: float</code>  <code>property</code>","text":"<p>Get the linear acceleration in the z-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The linear acceleration in m/s^2.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.baud_rate","title":"<code>baud_rate: int</code>  <code>property</code>","text":"<p>Get the baud rate for the serial connection.</p> <p>Returns:</p> Type Description <code>int</code> <p>The baud rate in Hz.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.data","title":"<code>data: dict[str, float]</code>  <code>property</code>","text":"<p>Get the current sensor data.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>A dictionary containing the current sensor data.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.frequency","title":"<code>frequency: int</code>  <code>property</code>","text":"<p>Get the data streaming frequency.</p> <p>Returns:</p> Type Description <code>int</code> <p>The frequency in Hz.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.gyro_x","title":"<code>gyro_x: float</code>  <code>property</code>","text":"<p>Get the gyroscope reading in the x-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The gyroscope reading in rad/s.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.gyro_y","title":"<code>gyro_y: float</code>  <code>property</code>","text":"<p>Get the gyroscope reading in the y-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The gyroscope reading in rad/s.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.gyro_z","title":"<code>gyro_z: float</code>  <code>property</code>","text":"<p>Get the gyroscope reading in the z-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The gyroscope reading in rad/s.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.is_streaming","title":"<code>is_streaming: bool</code>  <code>property</code>","text":"<p>Check if the sensor is currently streaming.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the sensor is streaming, False otherwise.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.max_packets","title":"<code>max_packets: int</code>  <code>property</code>","text":"<p>Get the maximum number of packets to retrieve.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum number of packets.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.pitch","title":"<code>pitch: float</code>  <code>property</code>","text":"<p>Get the pitch angle.</p> <p>Returns:</p> Type Description <code>float</code> <p>The pitch angle in radians.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.port","title":"<code>port: str</code>  <code>property</code>","text":"<p>Get the serial port for the IMU.</p> <p>Returns:</p> Type Description <code>str</code> <p>The serial port string.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.return_packets","title":"<code>return_packets: bool</code>  <code>property</code>","text":"<p>Get the return packets flag.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if raw data packets should be returned, False otherwise.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.roll","title":"<code>roll: float</code>  <code>property</code>","text":"<p>Get the roll angle.</p> <p>Returns:</p> Type Description <code>float</code> <p>The roll angle in radians.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.timestamp","title":"<code>timestamp: float</code>  <code>property</code>","text":"<p>Get the GPS timestamp.</p> <p>Returns:</p> Type Description <code>float</code> <p>The GPS timestamp in seconds.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.update_timeout","title":"<code>update_timeout: int</code>  <code>property</code>","text":"<p>Get the update timeout for data packet retrieval.</p> <p>Returns:</p> Type Description <code>int</code> <p>The timeout in milliseconds.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.vel_x","title":"<code>vel_x: float</code>  <code>property</code>","text":"<p>Get the angular velocity in the x-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The angular velocity in rad/s.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.vel_y","title":"<code>vel_y: float</code>  <code>property</code>","text":"<p>Get the angular velocity in the y-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The angular velocity in rad/s.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.vel_z","title":"<code>vel_z: float</code>  <code>property</code>","text":"<p>Get the angular velocity in the z-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>The angular velocity in rad/s.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.yaw","title":"<code>yaw: float</code>  <code>property</code>","text":"<p>Get the yaw angle.</p> <p>Returns:</p> Type Description <code>float</code> <p>The yaw angle in radians.</p>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.__init__","title":"<code>__init__(port='/dev/ttyUSB0', baud_rate=921600, frequency=200, update_timeout=500, max_packets=1, return_packets=False)</code>","text":"<p>Initialize the LordMicrostrainIMU sensor.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port for the IMU. Defaults to \"/dev/ttyUSB0\".</p> <code>'/dev/ttyUSB0'</code> <code>baud_rate</code> <code>int</code> <p>Baud rate for the serial connection. Defaults to 921600.</p> <code>921600</code> <code>frequency</code> <code>int</code> <p>Data streaming frequency in Hz. Defaults to 200.</p> <code>200</code> <code>update_timeout</code> <code>int</code> <p>Timeout for data packet retrieval in milliseconds. Defaults to 500.</p> <code>500</code> <code>max_packets</code> <code>int</code> <p>Maximum number of data packets to retrieve. Defaults to 1.</p> <code>1</code> <code>return_packets</code> <code>bool</code> <p>If True, returns the raw data packets. Defaults to False.</p> <code>False</code> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def __init__(\n    self,\n    port: str = \"/dev/ttyUSB0\",\n    baud_rate: int = 921600,\n    frequency: int = 200,\n    update_timeout: int = 500,\n    max_packets: int = 1,\n    return_packets: bool = False,\n) -&gt; None:\n    \"\"\"\n    Initialize the LordMicrostrainIMU sensor.\n\n    Args:\n        port: Serial port for the IMU. Defaults to \"/dev/ttyUSB0\".\n        baud_rate: Baud rate for the serial connection. Defaults to 921600.\n        frequency: Data streaming frequency in Hz. Defaults to 200.\n        update_timeout: Timeout for data packet retrieval in milliseconds. Defaults to 500.\n        max_packets: Maximum number of data packets to retrieve. Defaults to 1.\n        return_packets: If True, returns the raw data packets. Defaults to False.\n    \"\"\"\n    self._port = port\n    self._baud_rate = baud_rate\n    self._frequency = frequency\n    self._update_timeout = update_timeout\n    self._max_packets = max_packets\n    self._return_packets = return_packets\n    self._is_streaming = False\n    self._connection = None\n    self._data: dict[str, float] = {}\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the LordMicrostrainIMU sensor.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string identifying the sensor.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the LordMicrostrainIMU sensor.\n\n    Returns:\n        A string identifying the sensor.\n    \"\"\"\n    return \"IMULordMicrostrain\"\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.ping","title":"<code>ping()</code>","text":"<p>Ping the Lord Microstrain IMU sensor to verify connectivity.</p> <p>Logs an info message if the ping is successful, otherwise logs an error.</p> <p>Raises:</p> Type Description <code>SensorNotStreamingException</code> <p>If the sensor is not currently streaming.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>@check_sensor_stream\ndef ping(self) -&gt; None:\n    \"\"\"\n    Ping the Lord Microstrain IMU sensor to verify connectivity.\n\n    Logs an info message if the ping is successful, otherwise logs an error.\n\n    Raises:\n        SensorNotStreamingException: If the sensor is not currently streaming.\n    \"\"\"\n    response = self._node.ping()\n\n    if response.success():\n        LOGGER.info(f\"Successfully pinged the IMU at {self.port}\")\n    else:\n        LOGGER.error(f\"Failed to ping the IMU at {self.port}\")\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.set_max_packets","title":"<code>set_max_packets(max_packets)</code>","text":"<p>Set the maximum number of packets to retrieve.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def set_max_packets(self, max_packets: int) -&gt; None:\n    \"\"\"\n    Set the maximum number of packets to retrieve.\n    \"\"\"\n    self._max_packets = max_packets\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.set_return_packets","title":"<code>set_return_packets(return_packets)</code>","text":"<p>Set the return packets flag.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def set_return_packets(self, return_packets: bool) -&gt; None:\n    \"\"\"\n    Set the return packets flag.\n    \"\"\"\n    self._return_packets = return_packets\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.set_update_timeout","title":"<code>set_update_timeout(timeout)</code>","text":"<p>Set the update timeout for the sensor.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def set_update_timeout(self, timeout: int) -&gt; None:\n    \"\"\"\n    Set the update timeout for the sensor.\n    \"\"\"\n    self._update_timeout = timeout\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.start","title":"<code>start()</code>","text":"<p>Start the Lord Microstrain IMU sensor.</p> <p>Establishes a serial connection, configures the MIP channels, enables data streaming, and sets the streaming flag to True.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the Lord Microstrain IMU sensor.\n\n    Establishes a serial connection, configures the MIP channels, enables data streaming,\n    and sets the streaming flag to True.\n    \"\"\"\n    self._connection = mscl.Connection.Serial(self.port, self.baud_rate)\n    self._node = mscl.InertialNode(self._connection)\n    self._node.setActiveChannelFields(mscl.MipTypes.CLASS_ESTFILTER, self._configure_mip_channels())\n    self._node.enableDataStream(mscl.MipTypes.CLASS_ESTFILTER)\n    self._is_streaming = True\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.stop","title":"<code>stop()</code>","text":"<p>Stop the Lord Microstrain IMU sensor.</p> <p>Sets the node to idle mode and updates the streaming flag to False.</p> <p>Raises:</p> Type Description <code>SensorNotStreamingException</code> <p>If the sensor is not currently streaming.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>@check_sensor_stream\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop the Lord Microstrain IMU sensor.\n\n    Sets the node to idle mode and updates the streaming flag to False.\n\n    Raises:\n        SensorNotStreamingException: If the sensor is not currently streaming.\n    \"\"\"\n    self._node.setToIdle()\n    self._is_streaming = False\n</code></pre>"},{"location":"modules/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.update","title":"<code>update()</code>","text":"<p>Retrieve and update IMU data from the sensor. To modify update parameters, use the set_update_timeout, set_max_packets, and set_return_packets methods.</p> <p>Returns:</p> Type Description <code>Union[None, Any]</code> <p>Union[None, Any]: Returns the data packets if <code>return_packets</code> is True; otherwise, None.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def update(self) -&gt; Union[None, Any]:\n    \"\"\"\n    Retrieve and update IMU data from the sensor. To modify update parameters, use the set_update_timeout,\n    set_max_packets, and set_return_packets methods.\n\n    Returns:\n        Union[None, Any]: Returns the data packets if `return_packets` is True; otherwise, None.\n    \"\"\"\n    data_packets = self._node.getDataPackets(timeout=self.update_timeout, maxPackets=self.max_packets)\n    data_points = data_packets[-1].data()\n    self._data = {data.channelName(): data.as_float() for data in data_points}\n\n    if self.return_packets:\n        return data_packets\n    else:\n        return None\n</code></pre>"},{"location":"modules/sensors/loadcell/","title":"Loadcell","text":"<p>Module for interfacing with SRI Loadcell sensors.</p> <p>This module provides an implementation of a load cell sensor (DephyLoadcellAmplifier) that inherits from LoadcellBase. It uses an I2C interface via SMBus to communicate with a strain amplifier and processes raw ADC data to compute forces and moments.</p> <p>Classes:</p> Name Description <code>LoadcellNotRespondingException</code> <p>Exception raised when the load cell does not respond.</p> <code>MEMORY_CHANNELS</code> <p>Enum representing memory channel addresses for load cell readings.</p> <code>DephyLoadcellAmplifier</code> <p>Concrete implementation of a load cell sensor that provides force and moment data.</p> Dependencies <ul> <li>numpy</li> <li>smbus2</li> <li>opensourceleg.logging</li> <li>opensourceleg.sensors.base</li> </ul>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DEPHY_AMPLIFIER_MEMORY_CHANNELS","title":"<code>DEPHY_AMPLIFIER_MEMORY_CHANNELS</code>","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of memory channel addresses used by the load cell.</p> <p>Each channel corresponds to a specific high or low byte of the ADC data.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>class DEPHY_AMPLIFIER_MEMORY_CHANNELS(int, Enum):\n    \"\"\"\n    Enumeration of memory channel addresses used by the load cell.\n\n    Each channel corresponds to a specific high or low byte of the ADC data.\n    \"\"\"\n\n    CH1_H = 8\n    CH1_L = 9\n    CH2_H = 10\n    CH2_L = 11\n    CH3_H = 12\n    CH3_L = 13\n    CH4_H = 14\n    CH4_L = 15\n    CH5_H = 16\n    CH5_L = 17\n    CH6_H = 18\n    CH6_L = 19\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier","title":"<code>DephyLoadcellAmplifier</code>","text":"<p>               Bases: <code>LoadcellBase</code></p> <p>Implementation of a load cell sensor using the Dephy Loadcell Amplifier.</p> <p>This class communicates with the dephy strain amplifier via I2C using the SMBus interface, processes the raw ADC data, and computes forces (Fx, Fy, Fz) and moments (Mx, My, Mz) based on a provided calibration matrix and hardware configuration.</p> Class Attributes <p>ADC_RANGE: The maximum ADC value (212 - 1). OFFSET: The ADC mid-scale offset (half of 212).</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>class DephyLoadcellAmplifier(LoadcellBase):\n    \"\"\"\n    Implementation of a load cell sensor using the Dephy Loadcell Amplifier.\n\n    This class communicates with the dephy strain amplifier via I2C using the SMBus interface,\n    processes the raw ADC data, and computes forces (Fx, Fy, Fz) and moments (Mx, My, Mz)\n    based on a provided calibration matrix and hardware configuration.\n\n    Class Attributes:\n        ADC_RANGE: The maximum ADC value (2**12 - 1).\n        OFFSET: The ADC mid-scale offset (half of 2**12).\n    \"\"\"\n\n    ADC_RANGE = 2**12 - 1\n    OFFSET = 2**12 / 2\n\n    def __init__(\n        self,\n        calibration_matrix: npt.NDArray[np.double],\n        amp_gain: float = 125.0,\n        exc: float = 5.0,\n        bus: int = 1,\n        i2c_address: int = 0x66,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Dephy loadcell amplifier.\n\n        Validates the provided parameters and initializes internal variables for data\n        acquisition, calibration, and streaming.\n\n        Args:\n            calibration_matrix: A 6x6 calibration matrix.\n            amp_gain: Amplifier gain; must be greater than 0. Defaults to 125.0.\n            exc: Excitation voltage; must be greater than 0. Defaults to 5.0.\n            bus: I2C bus number to use. Defaults to 1.\n            i2c_address: I2C address of the strain amplifier. Defaults to 0x66.\n\n        Raises:\n            TypeError: If calibration_matrix is not a 6x6 array.\n            ValueError: If amp_gain or exc are not greater than 0.\n        \"\"\"\n        # Validate input parameters.\n        if calibration_matrix.shape != (6, 6):\n            LOGGER.info(f\"[{self.__repr__()}] calibration_matrix must be a 6x6 array of np.double.\")\n            raise TypeError(\"calibration_matrix must be a 6x6 array of np.double.\")\n        if amp_gain &lt;= 0:\n            LOGGER.info(f\"[{self.__repr__()}] amp_gain must be a floating point value greater than 0.\")\n            raise ValueError(\"amp_gain must be a floating point value greater than 0.\")\n        if exc &lt;= 0:\n            LOGGER.info(f\"[{self.__repr__()}] exc must be a floating point value greater than 0.\")\n            raise ValueError(\"exc must be a floating point value greater than 0.\")\n\n        self._amp_gain: float = amp_gain\n        self._exc: float = exc\n\n        self._bus = bus\n        self._i2c_address = i2c_address\n\n        self._calibration_matrix = calibration_matrix\n\n        self._data: npt.NDArray[np.double] = np.zeros(shape=(1, 6), dtype=np.double)\n        self._prev_data: npt.NDArray[np.double] = self._data\n        self._failed_reads = 0\n\n        self._calibration_offset: npt.NDArray[np.double] = np.zeros(shape=(1, 6), dtype=np.double)\n        self._zero_calibration_offset: npt.NDArray[np.double] = self._calibration_offset\n        self._is_calibrated: bool = False\n        self._is_streaming: bool = False\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the load cell sensor.\n\n        Opens the I2C connection using SMBus, waits briefly for hardware stabilization,\n        and sets the streaming flag to True.\n        \"\"\"\n        self._smbus = SMBus(self._bus)\n        time.sleep(1)\n        self._is_streaming = True\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the load cell calibration.\n\n        Resets the calibration offset to the zero value and marks the sensor as uncalibrated.\n        \"\"\"\n        self._calibration_offset = self._zero_calibration_offset\n        self._is_calibrated = False\n\n    def update(\n        self,\n        calibration_offset: Optional[npt.NDArray[np.double]] = None,\n        data_callback: Optional[Callable[..., npt.NDArray[np.uint8]]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Query the load cell for the latest data and update internal state.\n\n        Reads raw ADC data (either via a provided callback or by reading from I2C),\n        converts it to engineering units using the calibration matrix, amplifier gain,\n        and excitation voltage, and subtracts any calibration offset.\n\n        Args:\n            calibration_offset: An offset to subtract from the processed data. If None, uses the current calibration offset.\n            data_callback: A callback function to provide raw data. If not provided, the sensor's internal method is used.\n        \"\"\"\n        data = data_callback() if data_callback else self._read_compressed_strain()\n\n        if calibration_offset is None:\n            calibration_offset = self._calibration_offset\n\n        signed_data = ((data - self.OFFSET) / self.ADC_RANGE) * self._exc\n        coupled_data = signed_data * 1000 / (self._exc * self._amp_gain)\n\n        # Process the data using the calibration matrix and subtract the offset.\n        self._data = np.transpose(a=self._calibration_matrix.dot(b=np.transpose(a=coupled_data))) - calibration_offset\n\n    def calibrate(\n        self,\n        number_of_iterations: int = 2000,\n        reset: bool = False,\n        data_callback: Optional[Callable[[], npt.NDArray[np.uint8]]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Perform a zeroing (calibration) routine for the load cell.\n\n        This method obtains an initial zero-load reading that is subtracted from subsequent\n        measurements. If the sensor has already been calibrated and 'reset' is False, a log message\n        is displayed.\n\n        Args:\n            number_of_iterations: Number of iterations to average for calibration.\n            reset: If True, forces recalibration by resetting the current calibration.\n            data_callback: Optional callback function to provide raw data. If not provided, the sensor's internal method is used.\n        \"\"\"\n        if not self.is_calibrated:\n            LOGGER.info(\n                f\"[{self.__repr__()}] Initiating zeroing routine, please ensure that there is no ground contact force.\"\n            )\n            input(\"Press any key to start.\")\n\n            self.update(data_callback=data_callback)\n            self._calibration_offset = self._data\n\n            for _ in range(number_of_iterations):\n                self.update(\n                    calibration_offset=self._zero_calibration_offset,\n                    data_callback=data_callback,\n                )\n                iterative_calibration_offset = self._data\n                self._calibration_offset = (iterative_calibration_offset + self._calibration_offset) / 2.0\n\n            self._is_calibrated = True\n            LOGGER.info(f\"[{self.__repr__()}] Calibration routine complete.\")\n\n        elif reset:\n            self.reset()\n            self.calibrate()\n        else:\n            LOGGER.info(\n                f\"[{self.__repr__()}] Loadcell has already been zeroed. \"\n                \"To recalibrate, set reset=True in the calibrate method or call reset() first.\"\n            )\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the load cell sensor.\n\n        Sets the streaming flag to False and closes the I2C connection if it is open.\n        \"\"\"\n        self._is_streaming = False\n        if hasattr(self, \"_smbus\"):\n            self._smbus.close()\n\n    def _read_compressed_strain(self) -&gt; Any:\n        \"\"\"\n        Read raw strain data from the load cell via I2C.\n\n        Returns:\n            Raw strain data from the load cell.\n        \"\"\"\n        try:\n            data = self._smbus.read_i2c_block_data(self._i2c_address, DEPHY_AMPLIFIER_MEMORY_CHANNELS.CH1_H, 10)\n            self.failed_reads = 0\n        except OSError:\n            self.failed_reads += 1\n\n            if self.failed_reads &gt;= 5:\n                raise LoadcellNotRespondingException(\"Load cell unresponsive.\") from None\n\n        return self._unpack_compressed_strain(np.array(object=data, dtype=np.uint8))\n\n    @staticmethod\n    def _unpack_uncompressed_strain(data: npt.NDArray[np.uint8]) -&gt; npt.NDArray[np.uint16]:\n        \"\"\"\n        Unpack uncompressed strain data from raw bytes.\n\n        Args:\n            data: Raw data read from the sensor.\n\n        Returns:\n            Unpacked strain data.\n        \"\"\"\n        ch1 = (data[0] &lt;&lt; 8) | data[1]\n        ch2 = (data[2] &lt;&lt; 8) | data[3]\n        ch3 = (data[4] &lt;&lt; 8) | data[5]\n        ch4 = (data[6] &lt;&lt; 8) | data[7]\n        ch5 = (data[8] &lt;&lt; 8) | data[9]\n        ch6 = (data[10] &lt;&lt; 8) | data[11]\n        return np.array(object=[ch1, ch2, ch3, ch4, ch5, ch6])\n\n    @staticmethod\n    def _unpack_compressed_strain(data: npt.NDArray[np.uint8]) -&gt; npt.NDArray[np.uint16]:\n        \"\"\"\n        Unpack compressed strain data from raw bytes.\n\n        Args:\n            data: Raw data read from the sensor.\n\n        Returns:\n            Unpacked strain data.\n        \"\"\"\n        return np.array(\n            object=[\n                (data[0] &lt;&lt; 4) | ((data[1] &gt;&gt; 4) &amp; 0x0F),\n                ((data[1] &lt;&lt; 8) &amp; 0x0F00) | data[2],\n                (data[3] &lt;&lt; 4) | ((data[4] &gt;&gt; 4) &amp; 0x0F),\n                ((data[4] &lt;&lt; 8) &amp; 0x0F00) | data[5],\n                (data[6] &lt;&lt; 4) | ((data[7] &gt;&gt; 4) &amp; 0x0F),\n                ((data[7] &lt;&lt; 8) &amp; 0x0F00) | data[8],\n            ]\n        )\n\n    @property\n    def is_calibrated(self) -&gt; bool:\n        \"\"\"\n        Check if the load cell has been calibrated.\n\n        Returns:\n            True if the load cell has been calibrated, False otherwise.\n        \"\"\"\n        return self._is_calibrated\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the load cell is currently streaming data.\n\n        Returns:\n            True if the load cell is streaming data, False otherwise.\n        \"\"\"\n        return self._is_streaming\n\n    @property\n    def fx(self) -&gt; float:\n        \"\"\"\n        Get the force in the x-direction.\n\n        Returns:\n            Force in the x-direction in Newtons.\n        \"\"\"\n        return self.data[0]\n\n    @property\n    def fy(self) -&gt; float:\n        \"\"\"\n        Get the force in the y-direction.\n\n        Returns:\n            Force in the y-direction in Newtons.\n        \"\"\"\n        return self.data[1]\n\n    @property\n    def fz(self) -&gt; float:\n        \"\"\"\n        Get the force in the z-direction.\n\n        Returns:\n            Force in the z-direction in Newtons.\n        \"\"\"\n        return self.data[2]\n\n    @property\n    def mx(self) -&gt; float:\n        \"\"\"\n        Get the moment about the x-axis.\n\n        Returns:\n            Moment about the x-axis in Newton-meters.\n        \"\"\"\n        return self.data[3]\n\n    @property\n    def my(self) -&gt; float:\n        \"\"\"\n        Get the moment about the y-axis.\n\n        Returns:\n            Moment about the y-axis in Newton-meters.\n        \"\"\"\n        return self.data[4]\n\n    @property\n    def mz(self) -&gt; float:\n        \"\"\"\n        Get the moment about the z-axis.\n\n        Returns:\n            Moment about the z-axis in Newton-meters.\n        \"\"\"\n        return self.data[5]\n\n    @property\n    def data(self) -&gt; list[float]:\n        \"\"\"\n        Get all force and moment data as a list.\n\n        Returns:\n            List containing [Fx, Fy, Fz, Mx, My, Mz] in Newtons and Newton-meters.\n        \"\"\"\n        if self._data is not None:\n            return list(map(float, self._data[0].tolist()))\n        else:\n            return list(map(float, self._zero_calibration_offset.tolist()))\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.data","title":"<code>data: list[float]</code>  <code>property</code>","text":"<p>Get all force and moment data as a list.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>List containing [Fx, Fy, Fz, Mx, My, Mz] in Newtons and Newton-meters.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.fx","title":"<code>fx: float</code>  <code>property</code>","text":"<p>Get the force in the x-direction.</p> <p>Returns:</p> Type Description <code>float</code> <p>Force in the x-direction in Newtons.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.fy","title":"<code>fy: float</code>  <code>property</code>","text":"<p>Get the force in the y-direction.</p> <p>Returns:</p> Type Description <code>float</code> <p>Force in the y-direction in Newtons.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.fz","title":"<code>fz: float</code>  <code>property</code>","text":"<p>Get the force in the z-direction.</p> <p>Returns:</p> Type Description <code>float</code> <p>Force in the z-direction in Newtons.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.is_calibrated","title":"<code>is_calibrated: bool</code>  <code>property</code>","text":"<p>Check if the load cell has been calibrated.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the load cell has been calibrated, False otherwise.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.is_streaming","title":"<code>is_streaming: bool</code>  <code>property</code>","text":"<p>Check if the load cell is currently streaming data.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the load cell is streaming data, False otherwise.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.mx","title":"<code>mx: float</code>  <code>property</code>","text":"<p>Get the moment about the x-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>Moment about the x-axis in Newton-meters.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.my","title":"<code>my: float</code>  <code>property</code>","text":"<p>Get the moment about the y-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>Moment about the y-axis in Newton-meters.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.mz","title":"<code>mz: float</code>  <code>property</code>","text":"<p>Get the moment about the z-axis.</p> <p>Returns:</p> Type Description <code>float</code> <p>Moment about the z-axis in Newton-meters.</p>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.__init__","title":"<code>__init__(calibration_matrix, amp_gain=125.0, exc=5.0, bus=1, i2c_address=102)</code>","text":"<p>Initialize the Dephy loadcell amplifier.</p> <p>Validates the provided parameters and initializes internal variables for data acquisition, calibration, and streaming.</p> <p>Parameters:</p> Name Type Description Default <code>calibration_matrix</code> <code>NDArray[double]</code> <p>A 6x6 calibration matrix.</p> required <code>amp_gain</code> <code>float</code> <p>Amplifier gain; must be greater than 0. Defaults to 125.0.</p> <code>125.0</code> <code>exc</code> <code>float</code> <p>Excitation voltage; must be greater than 0. Defaults to 5.0.</p> <code>5.0</code> <code>bus</code> <code>int</code> <p>I2C bus number to use. Defaults to 1.</p> <code>1</code> <code>i2c_address</code> <code>int</code> <p>I2C address of the strain amplifier. Defaults to 0x66.</p> <code>102</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If calibration_matrix is not a 6x6 array.</p> <code>ValueError</code> <p>If amp_gain or exc are not greater than 0.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def __init__(\n    self,\n    calibration_matrix: npt.NDArray[np.double],\n    amp_gain: float = 125.0,\n    exc: float = 5.0,\n    bus: int = 1,\n    i2c_address: int = 0x66,\n) -&gt; None:\n    \"\"\"\n    Initialize the Dephy loadcell amplifier.\n\n    Validates the provided parameters and initializes internal variables for data\n    acquisition, calibration, and streaming.\n\n    Args:\n        calibration_matrix: A 6x6 calibration matrix.\n        amp_gain: Amplifier gain; must be greater than 0. Defaults to 125.0.\n        exc: Excitation voltage; must be greater than 0. Defaults to 5.0.\n        bus: I2C bus number to use. Defaults to 1.\n        i2c_address: I2C address of the strain amplifier. Defaults to 0x66.\n\n    Raises:\n        TypeError: If calibration_matrix is not a 6x6 array.\n        ValueError: If amp_gain or exc are not greater than 0.\n    \"\"\"\n    # Validate input parameters.\n    if calibration_matrix.shape != (6, 6):\n        LOGGER.info(f\"[{self.__repr__()}] calibration_matrix must be a 6x6 array of np.double.\")\n        raise TypeError(\"calibration_matrix must be a 6x6 array of np.double.\")\n    if amp_gain &lt;= 0:\n        LOGGER.info(f\"[{self.__repr__()}] amp_gain must be a floating point value greater than 0.\")\n        raise ValueError(\"amp_gain must be a floating point value greater than 0.\")\n    if exc &lt;= 0:\n        LOGGER.info(f\"[{self.__repr__()}] exc must be a floating point value greater than 0.\")\n        raise ValueError(\"exc must be a floating point value greater than 0.\")\n\n    self._amp_gain: float = amp_gain\n    self._exc: float = exc\n\n    self._bus = bus\n    self._i2c_address = i2c_address\n\n    self._calibration_matrix = calibration_matrix\n\n    self._data: npt.NDArray[np.double] = np.zeros(shape=(1, 6), dtype=np.double)\n    self._prev_data: npt.NDArray[np.double] = self._data\n    self._failed_reads = 0\n\n    self._calibration_offset: npt.NDArray[np.double] = np.zeros(shape=(1, 6), dtype=np.double)\n    self._zero_calibration_offset: npt.NDArray[np.double] = self._calibration_offset\n    self._is_calibrated: bool = False\n    self._is_streaming: bool = False\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.calibrate","title":"<code>calibrate(number_of_iterations=2000, reset=False, data_callback=None)</code>","text":"<p>Perform a zeroing (calibration) routine for the load cell.</p> <p>This method obtains an initial zero-load reading that is subtracted from subsequent measurements. If the sensor has already been calibrated and 'reset' is False, a log message is displayed.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_iterations</code> <code>int</code> <p>Number of iterations to average for calibration.</p> <code>2000</code> <code>reset</code> <code>bool</code> <p>If True, forces recalibration by resetting the current calibration.</p> <code>False</code> <code>data_callback</code> <code>Optional[Callable[[], NDArray[uint8]]]</code> <p>Optional callback function to provide raw data. If not provided, the sensor's internal method is used.</p> <code>None</code> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def calibrate(\n    self,\n    number_of_iterations: int = 2000,\n    reset: bool = False,\n    data_callback: Optional[Callable[[], npt.NDArray[np.uint8]]] = None,\n) -&gt; None:\n    \"\"\"\n    Perform a zeroing (calibration) routine for the load cell.\n\n    This method obtains an initial zero-load reading that is subtracted from subsequent\n    measurements. If the sensor has already been calibrated and 'reset' is False, a log message\n    is displayed.\n\n    Args:\n        number_of_iterations: Number of iterations to average for calibration.\n        reset: If True, forces recalibration by resetting the current calibration.\n        data_callback: Optional callback function to provide raw data. If not provided, the sensor's internal method is used.\n    \"\"\"\n    if not self.is_calibrated:\n        LOGGER.info(\n            f\"[{self.__repr__()}] Initiating zeroing routine, please ensure that there is no ground contact force.\"\n        )\n        input(\"Press any key to start.\")\n\n        self.update(data_callback=data_callback)\n        self._calibration_offset = self._data\n\n        for _ in range(number_of_iterations):\n            self.update(\n                calibration_offset=self._zero_calibration_offset,\n                data_callback=data_callback,\n            )\n            iterative_calibration_offset = self._data\n            self._calibration_offset = (iterative_calibration_offset + self._calibration_offset) / 2.0\n\n        self._is_calibrated = True\n        LOGGER.info(f\"[{self.__repr__()}] Calibration routine complete.\")\n\n    elif reset:\n        self.reset()\n        self.calibrate()\n    else:\n        LOGGER.info(\n            f\"[{self.__repr__()}] Loadcell has already been zeroed. \"\n            \"To recalibrate, set reset=True in the calibrate method or call reset() first.\"\n        )\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.reset","title":"<code>reset()</code>","text":"<p>Reset the load cell calibration.</p> <p>Resets the calibration offset to the zero value and marks the sensor as uncalibrated.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the load cell calibration.\n\n    Resets the calibration offset to the zero value and marks the sensor as uncalibrated.\n    \"\"\"\n    self._calibration_offset = self._zero_calibration_offset\n    self._is_calibrated = False\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.start","title":"<code>start()</code>","text":"<p>Start the load cell sensor.</p> <p>Opens the I2C connection using SMBus, waits briefly for hardware stabilization, and sets the streaming flag to True.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the load cell sensor.\n\n    Opens the I2C connection using SMBus, waits briefly for hardware stabilization,\n    and sets the streaming flag to True.\n    \"\"\"\n    self._smbus = SMBus(self._bus)\n    time.sleep(1)\n    self._is_streaming = True\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.stop","title":"<code>stop()</code>","text":"<p>Stop the load cell sensor.</p> <p>Sets the streaming flag to False and closes the I2C connection if it is open.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the load cell sensor.\n\n    Sets the streaming flag to False and closes the I2C connection if it is open.\n    \"\"\"\n    self._is_streaming = False\n    if hasattr(self, \"_smbus\"):\n        self._smbus.close()\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.update","title":"<code>update(calibration_offset=None, data_callback=None)</code>","text":"<p>Query the load cell for the latest data and update internal state.</p> <p>Reads raw ADC data (either via a provided callback or by reading from I2C), converts it to engineering units using the calibration matrix, amplifier gain, and excitation voltage, and subtracts any calibration offset.</p> <p>Parameters:</p> Name Type Description Default <code>calibration_offset</code> <code>Optional[NDArray[double]]</code> <p>An offset to subtract from the processed data. If None, uses the current calibration offset.</p> <code>None</code> <code>data_callback</code> <code>Optional[Callable[..., NDArray[uint8]]]</code> <p>A callback function to provide raw data. If not provided, the sensor's internal method is used.</p> <code>None</code> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def update(\n    self,\n    calibration_offset: Optional[npt.NDArray[np.double]] = None,\n    data_callback: Optional[Callable[..., npt.NDArray[np.uint8]]] = None,\n) -&gt; None:\n    \"\"\"\n    Query the load cell for the latest data and update internal state.\n\n    Reads raw ADC data (either via a provided callback or by reading from I2C),\n    converts it to engineering units using the calibration matrix, amplifier gain,\n    and excitation voltage, and subtracts any calibration offset.\n\n    Args:\n        calibration_offset: An offset to subtract from the processed data. If None, uses the current calibration offset.\n        data_callback: A callback function to provide raw data. If not provided, the sensor's internal method is used.\n    \"\"\"\n    data = data_callback() if data_callback else self._read_compressed_strain()\n\n    if calibration_offset is None:\n        calibration_offset = self._calibration_offset\n\n    signed_data = ((data - self.OFFSET) / self.ADC_RANGE) * self._exc\n    coupled_data = signed_data * 1000 / (self._exc * self._amp_gain)\n\n    # Process the data using the calibration matrix and subtract the offset.\n    self._data = np.transpose(a=self._calibration_matrix.dot(b=np.transpose(a=coupled_data))) - calibration_offset\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.LoadcellNotRespondingException","title":"<code>LoadcellNotRespondingException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the load cell fails to respond.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Description of the error.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>class LoadcellNotRespondingException(Exception):\n    \"\"\"\n    Exception raised when the load cell fails to respond.\n\n    Attributes:\n        message: Description of the error.\n    \"\"\"\n\n    def __init__(self, message: str = \"Load cell unresponsive.\") -&gt; None:\n        \"\"\"\n        Initialize the LoadcellNotRespondingException.\n\n        Args:\n            message: Error message. Defaults to \"Load cell unresponsive.\".\n        \"\"\"\n        super().__init__(message)\n</code></pre>"},{"location":"modules/sensors/loadcell/#opensourceleg.sensors.loadcell.LoadcellNotRespondingException.__init__","title":"<code>__init__(message='Load cell unresponsive.')</code>","text":"<p>Initialize the LoadcellNotRespondingException.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message. Defaults to \"Load cell unresponsive.\".</p> <code>'Load cell unresponsive.'</code> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def __init__(self, message: str = \"Load cell unresponsive.\") -&gt; None:\n    \"\"\"\n    Initialize the LoadcellNotRespondingException.\n\n    Args:\n        message: Error message. Defaults to \"Load cell unresponsive.\".\n    \"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"modules/sensors/sensors_base/","title":"Base","text":""},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase","title":"<code>ADCBase</code>","text":"<p>               Bases: <code>SensorBase</code>, <code>ABC</code></p> <p>Abstract base class for ADC (Analog-to-Digital Converter) sensors.</p> <p>ADC sensors are used to convert analog signals into digital data.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class ADCBase(SensorBase, ABC):\n    \"\"\"\n    Abstract base class for ADC (Analog-to-Digital Converter) sensors.\n\n    ADC sensors are used to convert analog signals into digital data.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the ADC sensor.\n        \"\"\"\n        super().__init__()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the ADC sensor.\n\n        Returns:\n            \"ADCBase\"\n        \"\"\"\n        return \"ADCBase\"\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the ADC sensor.\n\n        Implementations should clear any stored state or calibration.\n        \"\"\"\n        pass\n\n    def calibrate(self) -&gt; None:\n        \"\"\"\n        Calibrate the ADC sensor.\n\n        Implementations should perform necessary calibration procedures.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the ADC sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the ADC sensor.\n    \"\"\"\n    super().__init__()\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the ADC sensor.</p> <p>Returns:</p> Type Description <code>str</code> <p>\"ADCBase\"</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the ADC sensor.\n\n    Returns:\n        \"ADCBase\"\n    \"\"\"\n    return \"ADCBase\"\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase.calibrate","title":"<code>calibrate()</code>","text":"<p>Calibrate the ADC sensor.</p> <p>Implementations should perform necessary calibration procedures.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def calibrate(self) -&gt; None:\n    \"\"\"\n    Calibrate the ADC sensor.\n\n    Implementations should perform necessary calibration procedures.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase.reset","title":"<code>reset()</code>","text":"<p>Reset the ADC sensor.</p> <p>Implementations should clear any stored state or calibration.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the ADC sensor.\n\n    Implementations should clear any stored state or calibration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase","title":"<code>EncoderBase</code>","text":"<p>               Bases: <code>SensorBase</code>, <code>ABC</code></p> <p>Abstract base class for encoder sensors.</p> <p>Encoders are used to measure position and velocity.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class EncoderBase(SensorBase, ABC):\n    \"\"\"\n    Abstract base class for encoder sensors.\n\n    Encoders are used to measure position and velocity.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the encoder sensor.\n        \"\"\"\n        super().__init__()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the encoder sensor.\n\n        Returns:\n            \"EncoderBase\"\n        \"\"\"\n        return \"EncoderBase\"\n\n    @property\n    @abstractmethod\n    def position(self) -&gt; float:\n        \"\"\"\n        Get the current encoder position.\n\n        Returns:\n            float: The current position value.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def velocity(self) -&gt; float:\n        \"\"\"\n        Get the current encoder velocity.\n\n        Returns:\n            float: The current velocity value.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase.position","title":"<code>position: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current encoder position.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current position value.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase.velocity","title":"<code>velocity: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current encoder velocity.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current velocity value.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the encoder sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the encoder sensor.\n    \"\"\"\n    super().__init__()\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the encoder sensor.</p> <p>Returns:</p> Type Description <code>str</code> <p>\"EncoderBase\"</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the encoder sensor.\n\n    Returns:\n        \"EncoderBase\"\n    \"\"\"\n    return \"EncoderBase\"\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase","title":"<code>IMUBase</code>","text":"<p>               Bases: <code>SensorBase</code>, <code>ABC</code></p> <p>Abstract base class for Inertial Measurement Unit (IMU) sensors.</p> <p>IMUs typically provide acceleration and gyroscopic data.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class IMUBase(SensorBase, ABC):\n    \"\"\"\n    Abstract base class for Inertial Measurement Unit (IMU) sensors.\n\n    IMUs typically provide acceleration and gyroscopic data.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the IMU sensor.\n        \"\"\"\n        pass\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the IMU sensor.\n\n        Returns:\n            str: \"IMU\"\n        \"\"\"\n        return \"IMU\"\n\n    @property\n    @abstractmethod\n    def acc_x(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the x-axis.\n\n        Returns:\n            float: Acceleration in m/s^2 along the x-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def acc_y(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the y-axis.\n\n        Returns:\n            float: Acceleration in m/s^2 along the y-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def acc_z(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the z-axis.\n\n        Returns:\n            float: Acceleration in m/s^2 along the z-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def gyro_x(self) -&gt; float:\n        \"\"\"\n        Get the gyroscopic measurement along the x-axis.\n\n        Returns:\n            float: Angular velocity in rad/s along the x-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def gyro_y(self) -&gt; float:\n        \"\"\"\n        Get the gyroscopic measurement along the y-axis.\n\n        Returns:\n            float: Angular velocity in rad/s along the y-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def gyro_z(self) -&gt; float:\n        \"\"\"\n        Get the gyroscopic measurement along the z-axis.\n\n        Returns:\n            float: Angular velocity in rad/s along the z-axis.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.acc_x","title":"<code>acc_x: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the estimated linear acceleration along the x-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in m/s^2 along the x-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.acc_y","title":"<code>acc_y: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the estimated linear acceleration along the y-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in m/s^2 along the y-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.acc_z","title":"<code>acc_z: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the estimated linear acceleration along the z-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in m/s^2 along the z-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.gyro_x","title":"<code>gyro_x: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the gyroscopic measurement along the x-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in rad/s along the x-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.gyro_y","title":"<code>gyro_y: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the gyroscopic measurement along the y-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in rad/s along the y-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.gyro_z","title":"<code>gyro_z: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the gyroscopic measurement along the z-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in rad/s along the z-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the IMU sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the IMU sensor.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the IMU sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"IMU\"</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the IMU sensor.\n\n    Returns:\n        str: \"IMU\"\n    \"\"\"\n    return \"IMU\"\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase","title":"<code>LoadcellBase</code>","text":"<p>               Bases: <code>SensorBase</code>, <code>ABC</code></p> <p>Abstract base class for load cell sensors.</p> <p>Load cells are used to measure forces and moments.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class LoadcellBase(SensorBase, ABC):\n    \"\"\"\n    Abstract base class for load cell sensors.\n\n    Load cells are used to measure forces and moments.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize the load cell sensor.\n        \"\"\"\n        pass\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the load cell sensor.\n\n        Returns:\n            str: \"LoadcellBase\"\n        \"\"\"\n        return \"LoadcellBase\"\n\n    @abstractmethod\n    def calibrate(self) -&gt; None:\n        \"\"\"\n        Calibrate the load cell sensor.\n\n        Implementations should perform the calibration procedure to ensure accurate readings.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the load cell sensor.\n\n        Implementations should reset the sensor state and any calibration data.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def fx(self) -&gt; float:\n        \"\"\"\n        Get the force along the x-axis.\n\n        Returns:\n            float: The force measured along the x-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def fy(self) -&gt; float:\n        \"\"\"\n        Get the force along the y-axis.\n\n        Returns:\n            float: The force measured along the y-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def fz(self) -&gt; float:\n        \"\"\"\n        Get the force along the z-axis.\n\n        Returns:\n            float: The force measured along the z-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def mx(self) -&gt; float:\n        \"\"\"\n        Get the moment about the x-axis.\n\n        Returns:\n            float: The moment measured about the x-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def my(self) -&gt; float:\n        \"\"\"\n        Get the moment about the y-axis.\n\n        Returns:\n            float: The moment measured about the y-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def mz(self) -&gt; float:\n        \"\"\"\n        Get the moment about the z-axis.\n\n        Returns:\n            float: The moment measured about the z-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def is_calibrated(self) -&gt; bool:\n        \"\"\"\n        Check if the load cell sensor is calibrated.\n\n        Returns:\n            bool: True if calibrated, False otherwise.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.fx","title":"<code>fx: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the force along the x-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The force measured along the x-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.fy","title":"<code>fy: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the force along the y-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The force measured along the y-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.fz","title":"<code>fz: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the force along the z-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The force measured along the z-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.is_calibrated","title":"<code>is_calibrated: bool</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Check if the load cell sensor is calibrated.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if calibrated, False otherwise.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.mx","title":"<code>mx: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the moment about the x-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The moment measured about the x-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.my","title":"<code>my: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the moment about the y-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The moment measured about the y-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.mz","title":"<code>mz: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the moment about the z-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The moment measured about the z-axis.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the load cell sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the load cell sensor.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the load cell sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"LoadcellBase\"</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the load cell sensor.\n\n    Returns:\n        str: \"LoadcellBase\"\n    \"\"\"\n    return \"LoadcellBase\"\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.calibrate","title":"<code>calibrate()</code>  <code>abstractmethod</code>","text":"<p>Calibrate the load cell sensor.</p> <p>Implementations should perform the calibration procedure to ensure accurate readings.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef calibrate(self) -&gt; None:\n    \"\"\"\n    Calibrate the load cell sensor.\n\n    Implementations should perform the calibration procedure to ensure accurate readings.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Reset the load cell sensor.</p> <p>Implementations should reset the sensor state and any calibration data.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef reset(self) -&gt; None:\n    \"\"\"\n    Reset the load cell sensor.\n\n    Implementations should reset the sensor state and any calibration data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase","title":"<code>SensorBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for sensors.</p> <p>Defines the common interface for sensors including starting, stopping, updating, and streaming status.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class SensorBase(ABC):\n    \"\"\"\n    Abstract base class for sensors.\n\n    Defines the common interface for sensors including starting, stopping,\n    updating, and streaming status.\n    \"\"\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the sensor.\n\n        Returns:\n            A string identifying the sensor class.\n        \"\"\"\n        return \"SensorBase\"\n\n    @property\n    @abstractmethod\n    def data(self) -&gt; Any:\n        \"\"\"\n        Get the sensor data.\n\n        Returns:\n            The current data from the sensor.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the sensor streaming.\n\n        Implementations should handle initializing the sensor and beginning data acquisition.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the sensor streaming.\n\n        Implementations should handle gracefully shutting down the sensor.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the sensor state or data.\n\n        Implementations should refresh or poll the sensor data as needed.\n        \"\"\"\n        pass\n\n    def __enter__(self) -&gt; \"SensorBase\":\n        \"\"\"\n        Enter the runtime context for the sensor.\n\n        This method calls start() and returns the sensor instance.\n\n        Returns:\n            SensorBase: The sensor instance.\n        \"\"\"\n        self.start()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n        \"\"\"\n        Exit the runtime context for the sensor.\n\n        This method calls stop() to shut down the sensor.\n\n        Args:\n            exc_type: Exception type if raised.\n            exc_value: Exception value if raised.\n            traceback: Traceback if an exception occurred.\n        \"\"\"\n        self.stop()\n\n    @property\n    @abstractmethod\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the sensor is currently streaming.\n\n        Returns:\n            True if the sensor is streaming, False otherwise.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.data","title":"<code>data: Any</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the sensor data.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The current data from the sensor.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.is_streaming","title":"<code>is_streaming: bool</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Check if the sensor is currently streaming.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the sensor is streaming, False otherwise.</p>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context for the sensor.</p> <p>This method calls start() and returns the sensor instance.</p> <p>Returns:</p> Name Type Description <code>SensorBase</code> <code>SensorBase</code> <p>The sensor instance.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __enter__(self) -&gt; \"SensorBase\":\n    \"\"\"\n    Enter the runtime context for the sensor.\n\n    This method calls start() and returns the sensor instance.\n\n    Returns:\n        SensorBase: The sensor instance.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Exit the runtime context for the sensor.</p> <p>This method calls stop() to shut down the sensor.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>Exception type if raised.</p> required <code>exc_value</code> <code>Any</code> <p>Exception value if raised.</p> required <code>traceback</code> <code>Any</code> <p>Traceback if an exception occurred.</p> required Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n    \"\"\"\n    Exit the runtime context for the sensor.\n\n    This method calls stop() to shut down the sensor.\n\n    Args:\n        exc_type: Exception type if raised.\n        exc_value: Exception value if raised.\n        traceback: Traceback if an exception occurred.\n    \"\"\"\n    self.stop()\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the sensor.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string identifying the sensor class.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the sensor.\n\n    Returns:\n        A string identifying the sensor class.\n    \"\"\"\n    return \"SensorBase\"\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start the sensor streaming.</p> <p>Implementations should handle initializing the sensor and beginning data acquisition.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"\n    Start the sensor streaming.\n\n    Implementations should handle initializing the sensor and beginning data acquisition.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop the sensor streaming.</p> <p>Implementations should handle gracefully shutting down the sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop the sensor streaming.\n\n    Implementations should handle gracefully shutting down the sensor.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.update","title":"<code>update()</code>  <code>abstractmethod</code>","text":"<p>Update the sensor state or data.</p> <p>Implementations should refresh or poll the sensor data as needed.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"\n    Update the sensor state or data.\n\n    Implementations should refresh or poll the sensor data as needed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorNotStreamingException","title":"<code>SensorNotStreamingException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an operation is attempted on a sensor that is not streaming.</p> <p>This exception indicates that the sensor is not actively streaming data.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class SensorNotStreamingException(Exception):\n    \"\"\"\n    Exception raised when an operation is attempted on a sensor that is not streaming.\n\n    This exception indicates that the sensor is not actively streaming data.\n    \"\"\"\n\n    def __init__(self, sensor_name: str = \"Sensor\") -&gt; None:\n        \"\"\"\n        Initialize the SensorNotStreamingException.\n\n        Args:\n            sensor_name: The name or identifier of the sensor. Defaults to \"Sensor\".\n        \"\"\"\n        super().__init__(\n            f\"{sensor_name} is not streaming, please ensure that the connections are intact, \"\n            f\"power is on, and the start method is called.\"\n        )\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.SensorNotStreamingException.__init__","title":"<code>__init__(sensor_name='Sensor')</code>","text":"<p>Initialize the SensorNotStreamingException.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>The name or identifier of the sensor. Defaults to \"Sensor\".</p> <code>'Sensor'</code> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self, sensor_name: str = \"Sensor\") -&gt; None:\n    \"\"\"\n    Initialize the SensorNotStreamingException.\n\n    Args:\n        sensor_name: The name or identifier of the sensor. Defaults to \"Sensor\".\n    \"\"\"\n    super().__init__(\n        f\"{sensor_name} is not streaming, please ensure that the connections are intact, \"\n        f\"power is on, and the start method is called.\"\n    )\n</code></pre>"},{"location":"modules/sensors/sensors_base/#opensourceleg.sensors.base.check_sensor_stream","title":"<code>check_sensor_stream(func)</code>","text":"<p>Decorator to ensure that a sensor is streaming before executing the decorated method.</p> <p>If the sensor is not streaming, a SensorNotStreamingException is raised.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The sensor method to be wrapped.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The wrapped method that checks streaming status before execution.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def check_sensor_stream(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to ensure that a sensor is streaming before executing the decorated method.\n\n    If the sensor is not streaming, a SensorNotStreamingException is raised.\n\n    Args:\n        func: The sensor method to be wrapped.\n\n    Returns:\n        The wrapped method that checks streaming status before execution.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(self: Any, *args: Any, **kwargs: Any) -&gt; Any:\n        # TODO: This could be a generic type that points to actuator, sensor, etc.\n        if not self.is_streaming:\n            raise SensorNotStreamingException(sensor_name=self.__repr__())\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"}]}